
topmc_module.ko:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <topmc_uncore_global_ctrl_init_nehelam>:
	}
}

/* initialization uncore global msrs*/
void topmc_uncore_global_ctrl_init_nehelam(void)
{
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	41 57                	push   %r15
       6:	41 56                	push   %r14
       8:	41 55                	push   %r13
       a:	41 54                	push   %r12
       c:	53                   	push   %rbx
       d:	48 83 ec 18          	sub    $0x18,%rsp
      11:	e8 00 00 00 00       	callq  16 <topmc_uncore_global_ctrl_init_nehelam+0x16>
static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
{
	/* -1 is a legal arg here. */
	if (n != -1)
		cpumask_check(n);
	return find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
      16:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      1b:	41 bf 01 00 00 00    	mov    $0x1,%r15d
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      21:	4c 8d 75 c8          	lea    -0x38(%rbp),%r14
      25:	4c 8d 6d cc          	lea    -0x34(%rbp),%r13
void topmc_uncore_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      29:	eb 63                	jmp    8e <topmc_uncore_global_ctrl_init_nehelam+0x8e>
      2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      30:	4c 89 f1             	mov    %r14,%rcx
      33:	4c 89 ea             	mov    %r13,%rdx
      36:	be 91 03 00 00       	mov    $0x391,%esi
      3b:	44 89 e7             	mov    %r12d,%edi
      3e:	e8 00 00 00 00       	callq  43 <topmc_uncore_global_ctrl_init_nehelam+0x43>
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      43:	89 d8                	mov    %ebx,%eax
		//mask |= 1ULL << ( 48 + cpu_data(smp_processor_id()).cpu_core_id);
		//      printk("+->topmc: topmc_uncore_global_ctrl_init(): global control mask-> %llu\n",mask);
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      45:	be 91 03 00 00       	mov    $0x391,%esi
      4a:	44 89 e7             	mov    %r12d,%edi
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      4d:	c1 f8 1f             	sar    $0x1f,%eax
      50:	c1 e8 1e             	shr    $0x1e,%eax
      53:	8d 14 03             	lea    (%rbx,%rax,1),%edx
      56:	83 e2 03             	and    $0x3,%edx
      59:	29 c2                	sub    %eax,%edx
      5b:	48 b8 ff 00 00 00 01 	mov    $0x1000000ff,%rax
      62:	00 00 00 
      65:	8d 4a 30             	lea    0x30(%rdx),%ecx
      68:	4c 89 fa             	mov    %r15,%rdx
      6b:	48 d3 e2             	shl    %cl,%rdx
      6e:	48 09 c2             	or     %rax,%rdx
		//mask |= 1ULL << ( 48 + cpu_data(smp_processor_id()).cpu_core_id);
		//      printk("+->topmc: topmc_uncore_global_ctrl_init(): global control mask-> %llu\n",mask);
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      71:	48 89 d1             	mov    %rdx,%rcx
      74:	48 c1 e9 20          	shr    $0x20,%rcx
      78:	e8 00 00 00 00       	callq  7d <topmc_uncore_global_ctrl_init_nehelam+0x7d>

		//initialization global global overflow control msr ----------not needed at the moment
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, 0ULL, cpu);
      7d:	31 c9                	xor    %ecx,%ecx
      7f:	31 d2                	xor    %edx,%edx
      81:	be 93 03 00 00       	mov    $0x393,%esi
      86:	44 89 e7             	mov    %r12d,%edi
      89:	e8 00 00 00 00       	callq  8e <topmc_uncore_global_ctrl_init_nehelam+0x8e>
      8e:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 95 <topmc_uncore_global_ctrl_init_nehelam+0x95>
      95:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 9c <topmc_uncore_global_ctrl_init_nehelam+0x9c>
      9c:	83 c3 01             	add    $0x1,%ebx
      9f:	48 63 d3             	movslq %ebx,%rdx
      a2:	e8 00 00 00 00       	callq  a7 <topmc_uncore_global_ctrl_init_nehelam+0xa7>
void topmc_uncore_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      a7:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # ad <topmc_uncore_global_ctrl_init_nehelam+0xad>
      ad:	49 89 c4             	mov    %rax,%r12
      b0:	89 c3                	mov    %eax,%ebx
      b2:	0f 8c 78 ff ff ff    	jl     30 <topmc_uncore_global_ctrl_init_nehelam+0x30>
		//initialization global global overflow control msr ----------not needed at the moment
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, 0ULL, cpu);
		//    TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, mask, cpu);
		//  printk("+->topmc: topmc_uncore_global_ctrl_init(): global overflowed control mask-> %llu\n",mask);
	}
}
      b8:	48 83 c4 18          	add    $0x18,%rsp
      bc:	5b                   	pop    %rbx
      bd:	41 5c                	pop    %r12
      bf:	41 5d                	pop    %r13
      c1:	41 5e                	pop    %r14
      c3:	41 5f                	pop    %r15
      c5:	c9                   	leaveq 
      c6:	c3                   	retq   
      c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
      ce:	00 00 

00000000000000d0 <topmc_core_global_ctrl_init_nehelam>:

	}
}

void topmc_core_global_ctrl_init_nehelam(void)
{
      d0:	55                   	push   %rbp
      d1:	48 89 e5             	mov    %rsp,%rbp
      d4:	41 57                	push   %r15
      d6:	41 56                	push   %r14
      d8:	41 55                	push   %r13
      da:	41 54                	push   %r12
      dc:	53                   	push   %rbx
      dd:	48 83 ec 18          	sub    $0x18,%rsp
      e1:	e8 00 00 00 00       	callq  e6 <topmc_core_global_ctrl_init_nehelam+0x16>
      e6:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # ed <topmc_core_global_ctrl_init_nehelam+0x1d>
      ed:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
      f3:	4c 8d 75 c8          	lea    -0x38(%rbp),%r14
      f7:	4c 8d 6d cc          	lea    -0x34(%rbp),%r13
void topmc_core_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      fb:	eb 4f                	jmp    14c <topmc_core_global_ctrl_init_nehelam+0x7c>
      fd:	0f 1f 00             	nopl   (%rax)
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     100:	4c 89 f1             	mov    %r14,%rcx
     103:	4c 89 ea             	mov    %r13,%rdx
     106:	be 8f 03 00 00       	mov    $0x38f,%esi
     10b:	89 df                	mov    %ebx,%edi
     10d:	e8 00 00 00 00       	callq  112 <topmc_core_global_ctrl_init_nehelam+0x42>
		mask &=0ULL;
		mask |= ((1ULL << MSR_CORE_PERF_NUM_PMC) -1) << MSR_CORE_PERF_IDX_PMC;
		mask |= ((1ULL << MSR_CORE_PERF_NUM_FIX) -1) << MSR_CORE_PERF_IDX_FIX;
		TOPMC_WRMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     112:	b9 07 00 00 00       	mov    $0x7,%ecx
     117:	ba 0f 00 00 00       	mov    $0xf,%edx
     11c:	be 8f 03 00 00       	mov    $0x38f,%esi
     121:	89 df                	mov    %ebx,%edi
     123:	e8 00 00 00 00       	callq  128 <topmc_core_global_ctrl_init_nehelam+0x58>
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     128:	4c 89 e9             	mov    %r13,%rcx
     12b:	4c 89 f2             	mov    %r14,%rdx
     12e:	be 8f 03 00 00       	mov    $0x38f,%esi
     133:	89 df                	mov    %ebx,%edi
     135:	e8 00 00 00 00       	callq  13a <topmc_core_global_ctrl_init_nehelam+0x6a>
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global control mask -> %llu\n", mask);

		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_OVF_CTRL, mask, cpu);
     13a:	4c 89 f1             	mov    %r14,%rcx
     13d:	4c 89 ea             	mov    %r13,%rdx
     140:	be 90 03 00 00       	mov    $0x390,%esi
     145:	89 df                	mov    %ebx,%edi
     147:	e8 00 00 00 00       	callq  14c <topmc_core_global_ctrl_init_nehelam+0x7c>
     14c:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 153 <topmc_core_global_ctrl_init_nehelam+0x83>
     153:	41 83 c4 01          	add    $0x1,%r12d
     157:	4c 89 ff             	mov    %r15,%rdi
     15a:	49 63 d4             	movslq %r12d,%rdx
     15d:	e8 00 00 00 00       	callq  162 <topmc_core_global_ctrl_init_nehelam+0x92>
void topmc_core_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
     162:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 168 <topmc_core_global_ctrl_init_nehelam+0x98>
     168:	48 89 c3             	mov    %rax,%rbx
     16b:	41 89 c4             	mov    %eax,%r12d
     16e:	7c 90                	jl     100 <topmc_core_global_ctrl_init_nehelam+0x30>
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global control mask -> %llu\n", mask);

		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_OVF_CTRL, mask, cpu);
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global overflow control mask -> %llu\n", mask);
	}
}
     170:	48 83 c4 18          	add    $0x18,%rsp
     174:	5b                   	pop    %rbx
     175:	41 5c                	pop    %r12
     177:	41 5d                	pop    %r13
     179:	41 5e                	pop    %r14
     17b:	41 5f                	pop    %r15
     17d:	c9                   	leaveq 
     17e:	c3                   	retq   
     17f:	90                   	nop

0000000000000180 <topmc_msr_init_nehelam>:

	return count;
}

void topmc_msr_init_nehelam(void)
{
     180:	55                   	push   %rbp
     181:	48 89 e5             	mov    %rsp,%rbp
     184:	41 57                	push   %r15
     186:	41 56                	push   %r14
     188:	41 55                	push   %r13
     18a:	41 54                	push   %r12
     18c:	53                   	push   %rbx
     18d:	48 83 ec 18          	sub    $0x18,%rsp
     191:	e8 00 00 00 00       	callq  196 <topmc_msr_init_nehelam+0x16>
     196:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     19b:	49 bf 00 00 20 00 ff 	mov    $0xffffffff00200000,%r15
     1a2:	ff ff ff 
		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1a5:	4c 8d 75 cc          	lea    -0x34(%rbp),%r14
     1a9:	4c 8d 6d c8          	lea    -0x38(%rbp),%r13
     1ad:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 1b4 <topmc_msr_init_nehelam+0x34>
     1b4:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1bb <topmc_msr_init_nehelam+0x3b>
     1bb:	83 c3 01             	add    $0x1,%ebx
     1be:	48 63 d3             	movslq %ebx,%rdx
     1c1:	e8 00 00 00 00       	callq  1c6 <topmc_msr_init_nehelam+0x46>
void topmc_msr_init_nehelam(void)
{
	int i,cpu;
	u64 val;

	for_each_online_cpu(cpu){
     1c6:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 1cc <topmc_msr_init_nehelam+0x4c>
     1cc:	89 c3                	mov    %eax,%ebx
     1ce:	0f 8d fc 00 00 00    	jge    2d0 <topmc_msr_init_nehelam+0x150>
     1d4:	41 bc 01 00 00 00    	mov    $0x1,%r12d
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
     1da:	41 83 fc 01          	cmp    $0x1,%r12d
     1de:	75 3f                	jne    21f <topmc_msr_init_nehelam+0x9f>
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1e0:	4c 89 f1             	mov    %r14,%rcx
     1e3:	4c 89 ea             	mov    %r13,%rdx
     1e6:	be 86 01 00 00       	mov    $0x186,%esi
     1eb:	89 df                	mov    %ebx,%edi
     1ed:	e8 00 00 00 00       	callq  1f2 <topmc_msr_init_nehelam+0x72>
     1f2:	8b 55 cc             	mov    -0x34(%rbp),%edx
     1f5:	8b 45 c8             	mov    -0x38(%rbp),%eax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1f8:	be 86 01 00 00       	mov    $0x186,%esi
     1fd:	89 df                	mov    %ebx,%edi
		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1ff:	48 c1 e2 20          	shl    $0x20,%rdx
     203:	48 09 c2             	or     %rax,%rdx
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     206:	4c 21 fa             	and    %r15,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     209:	48 89 d1             	mov    %rdx,%rcx
     20c:	48 c1 e9 20          	shr    $0x20,%rcx
     210:	e8 00 00 00 00       	callq  215 <topmc_msr_init_nehelam+0x95>
void topmc_msr_init_nehelam(void)
{
	int i,cpu;
	u64 val;

	for_each_online_cpu(cpu){
     215:	41 83 c4 01          	add    $0x1,%r12d
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
     219:	41 83 fc 01          	cmp    $0x1,%r12d
     21d:	74 c1                	je     1e0 <topmc_msr_init_nehelam+0x60>
	for_each_online_cpu(cpu){
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     21f:	41 83 fc 03          	cmp    $0x3,%r12d
     223:	7e f0                	jle    215 <topmc_msr_init_nehelam+0x95>
     225:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     22b:	eb 17                	jmp    244 <topmc_msr_init_nehelam+0xc4>
     22d:	0f 1f 00             	nopl   (%rax)

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_PERFCTR0+i))
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
     230:	31 c9                	xor    %ecx,%ecx
     232:	31 d2                	xor    %edx,%edx
     234:	be c1 00 00 00       	mov    $0xc1,%esi
     239:	89 df                	mov    %ebx,%edi
     23b:	e8 00 00 00 00       	callq  240 <topmc_msr_init_nehelam+0xc0>
	for_each_online_cpu(cpu){
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     240:	41 83 c4 01          	add    $0x1,%r12d
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_PERFCTR0+i))
     244:	41 83 fc 01          	cmp    $0x1,%r12d
     248:	74 e6                	je     230 <topmc_msr_init_nehelam+0xb0>
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     24a:	41 83 fc 03          	cmp    $0x3,%r12d
     24e:	7e f0                	jle    240 <topmc_msr_init_nehelam+0xc0>
     250:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     256:	eb 2e                	jmp    286 <topmc_msr_init_nehelam+0x106>
     258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     25f:	00 

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
     260:	4c 89 e9             	mov    %r13,%rcx
     263:	4c 89 f2             	mov    %r14,%rdx
     266:	be c0 03 00 00       	mov    $0x3c0,%esi
     26b:	89 df                	mov    %ebx,%edi
     26d:	e8 00 00 00 00       	callq  272 <topmc_msr_init_nehelam+0xf2>
			val &= 0ULL;
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
     272:	31 c9                	xor    %ecx,%ecx
     274:	31 d2                	xor    %edx,%edx
     276:	be c0 03 00 00       	mov    $0x3c0,%esi
     27b:	89 df                	mov    %ebx,%edi
     27d:	e8 00 00 00 00       	callq  282 <topmc_msr_init_nehelam+0x102>
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     282:	41 83 c4 01          	add    $0x1,%r12d
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i))
     286:	41 83 fc 01          	cmp    $0x1,%r12d
     28a:	74 d4                	je     260 <topmc_msr_init_nehelam+0xe0>
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     28c:	41 83 fc 07          	cmp    $0x7,%r12d
     290:	7e f0                	jle    282 <topmc_msr_init_nehelam+0x102>
     292:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     298:	eb 1a                	jmp    2b4 <topmc_msr_init_nehelam+0x134>
     29a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i))
				continue;

			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i, 0LL, cpu);
     2a0:	31 c9                	xor    %ecx,%ecx
     2a2:	31 d2                	xor    %edx,%edx
     2a4:	be b0 03 00 00       	mov    $0x3b0,%esi
     2a9:	89 df                	mov    %ebx,%edi
     2ab:	e8 00 00 00 00       	callq  2b0 <topmc_msr_init_nehelam+0x130>
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     2b0:	41 83 c4 01          	add    $0x1,%r12d
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
		}

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i))
     2b4:	41 83 fc 01          	cmp    $0x1,%r12d
     2b8:	74 e6                	je     2a0 <topmc_msr_init_nehelam+0x120>
			val &= 0ULL;
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
		}

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     2ba:	41 83 fc 07          	cmp    $0x7,%r12d
     2be:	0f 8f e9 fe ff ff    	jg     1ad <topmc_msr_init_nehelam+0x2d>
     2c4:	eb ea                	jmp    2b0 <topmc_msr_init_nehelam+0x130>
     2c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     2cd:	00 00 00 

			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i, 0LL, cpu);
		}

	}
}
     2d0:	48 83 c4 18          	add    $0x18,%rsp
     2d4:	5b                   	pop    %rbx
     2d5:	41 5c                	pop    %r12
     2d7:	41 5d                	pop    %r13
     2d9:	41 5e                	pop    %r14
     2db:	41 5f                	pop    %r15
     2dd:	c9                   	leaveq 
     2de:	c3                   	retq   
     2df:	90                   	nop

00000000000002e0 <topmc_enable_read_nehelam>:
	return count;
}


int topmc_enable_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     2e0:	55                   	push   %rbp
     2e1:	48 89 e5             	mov    %rsp,%rbp
     2e4:	53                   	push   %rbx
     2e5:	48 83 ec 18          	sub    $0x18,%rsp
     2e9:	e8 00 00 00 00       	callq  2ee <topmc_enable_read_nehelam+0xe>
     2ee:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     2f1:	41 8b 39             	mov    (%r9),%edi
     2f4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     2f8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     2fc:	e8 00 00 00 00       	callq  301 <topmc_enable_read_nehelam+0x21>

	*page   = topmc_procs[cpu][counter].enable==1?'1':'0';
     301:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
     305:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
     309:	48 c1 e0 05          	shl    $0x5,%rax
     30d:	48 01 d0             	add    %rdx,%rax
     310:	48 c1 e0 04          	shl    $0x4,%rax
     314:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
	*(page+1) = '\n';
     31b:	c6 43 01 0a          	movb   $0xa,0x1(%rbx)
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);

	*page   = topmc_procs[cpu][counter].enable==1?'1':'0';
     31f:	0f 94 c0             	sete   %al
     322:	83 c0 30             	add    $0x30,%eax
     325:	88 03                	mov    %al,(%rbx)
	*(page+1) = '\n';
	return 2; //len of read
}
     327:	48 83 c4 18          	add    $0x18,%rsp
     32b:	b8 02 00 00 00       	mov    $0x2,%eax
     330:	5b                   	pop    %rbx
     331:	c9                   	leaveq 
     332:	c3                   	retq   
     333:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
     33a:	84 00 00 00 00 00 

0000000000000340 <topmc_enable_all_read_nehelam>:
extern struct topmc_proc_entry topmc_procs[NR_CPUS][TOPMC_MAX_COUNTER];

static int topmc_all_enabled = 0;

int topmc_enable_all_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     340:	55                   	push   %rbp
     341:	48 89 e5             	mov    %rsp,%rbp
     344:	53                   	push   %rbx
     345:	48 83 ec 18          	sub    $0x18,%rsp
     349:	e8 00 00 00 00       	callq  34e <topmc_enable_all_read_nehelam+0xe>
     34e:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     351:	41 8b 39             	mov    (%r9),%edi
     354:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     358:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     35c:	e8 00 00 00 00       	callq  361 <topmc_enable_all_read_nehelam+0x21>

	*page   = topmc_all_enabled==1?'1':'0';
     361:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0(%rip)        # 368 <topmc_enable_all_read_nehelam+0x28>
	*(page+1) = '\n';
     368:	c6 43 01 0a          	movb   $0xa,0x1(%rbx)
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);

	*page   = topmc_all_enabled==1?'1':'0';
     36c:	0f 94 c0             	sete   %al
     36f:	83 c0 30             	add    $0x30,%eax
     372:	88 03                	mov    %al,(%rbx)
	*(page+1) = '\n';
	return 2; //len of read
}
     374:	48 83 c4 18          	add    $0x18,%rsp
     378:	b8 02 00 00 00       	mov    $0x2,%eax
     37d:	5b                   	pop    %rbx
     37e:	c9                   	leaveq 
     37f:	c3                   	retq   

0000000000000380 <topmc_value_write_nehelam>:

	return strlen(page); //len of read
}

int topmc_value_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     380:	55                   	push   %rbp
     381:	48 89 e5             	mov    %rsp,%rbp
     384:	53                   	push   %rbx
     385:	48 83 ec 18          	sub    $0x18,%rsp
     389:	e8 00 00 00 00       	callq  38e <topmc_value_write_nehelam+0xe>
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);
     38e:	8b 39                	mov    (%rcx),%edi
     390:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi

	return strlen(page); //len of read
}

int topmc_value_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     394:	48 89 d3             	mov    %rdx,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);
     397:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     39b:	e8 00 00 00 00       	callq  3a0 <topmc_value_write_nehelam+0x20>

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     3a0:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3a4:	66 83 fe 0b          	cmp    $0xb,%si
     3a8:	0f 87 ba 00 00 00    	ja     468 <topmc_value_write_nehelam+0xe8>
		printk("+->topmc: topmc_value_write(): counter err : %d!!!\n",counter);
		return 0;
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
     3ae:	66 83 fe 03          	cmp    $0x3,%si
     3b2:	76 54                	jbe    408 <topmc_value_write_nehelam+0x88>
		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
	}
	else if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum) {
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter-TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     3b4:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3b8:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
     3bc:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
     3c0:	0f b7 f6             	movzwl %si,%esi
     3c3:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     3c9:	e8 00 00 00 00       	callq  3ce <topmc_value_write_nehelam+0x4e>
		//      printk("+->uncore event selector val: 0x%llu\n", val);
		//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
		val &= 0ULL;
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter-TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     3ce:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3d2:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3d6:	31 c9                	xor    %ecx,%ecx
     3d8:	31 d2                	xor    %edx,%edx
     3da:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     3e0:	e8 00 00 00 00       	callq  3e5 <topmc_value_write_nehelam+0x65>

		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     3e5:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3e9:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3ed:	31 c9                	xor    %ecx,%ecx
     3ef:	31 d2                	xor    %edx,%edx
     3f1:	81 c6 b0 03 00 00    	add    $0x3b0,%esi
     3f7:	e8 00 00 00 00       	callq  3fc <topmc_value_write_nehelam+0x7c>
	}


	return count;
     3fc:	89 d8                	mov    %ebx,%eax
}
     3fe:	48 83 c4 18          	add    $0x18,%rsp
     402:	5b                   	pop    %rbx
     403:	c9                   	leaveq 
     404:	c3                   	retq   
     405:	0f 1f 00             	nopl   (%rax)
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     408:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     40c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
     410:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
     414:	0f b7 f6             	movzwl %si,%esi
     417:	81 c6 86 01 00 00    	add    $0x186,%esi
     41d:	e8 00 00 00 00       	callq  422 <topmc_value_write_nehelam+0xa2>
     422:	8b 45 e8             	mov    -0x18(%rbp),%eax
     425:	8b 55 e4             	mov    -0x1c(%rbp),%edx
		//        printk("+->incore event selector val: 0x%llu\n", val);
		val &= MSR_PPRO_EVENTSEL_RESERVED;
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     428:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     42c:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     430:	48 c1 e0 20          	shl    $0x20,%rax
		//        printk("+->incore event selector val: 0x%llu\n", val);
		val &= MSR_PPRO_EVENTSEL_RESERVED;
     434:	81 e2 00 00 20 00    	and    $0x200000,%edx
     43a:	48 09 c2             	or     %rax,%rdx
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     43d:	81 c6 86 01 00 00    	add    $0x186,%esi
     443:	48 89 d1             	mov    %rdx,%rcx
     446:	48 c1 e9 20          	shr    $0x20,%rcx
     44a:	e8 00 00 00 00       	callq  44f <topmc_value_write_nehelam+0xcf>

		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     44f:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     453:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     457:	31 c9                	xor    %ecx,%ecx
     459:	31 d2                	xor    %edx,%edx
     45b:	81 c6 c1 00 00 00    	add    $0xc1,%esi
     461:	e8 00 00 00 00       	callq  466 <topmc_value_write_nehelam+0xe6>
     466:	eb 94                	jmp    3fc <topmc_value_write_nehelam+0x7c>
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_write(): counter err : %d!!!\n",counter);
     468:	0f b7 f6             	movzwl %si,%esi
     46b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     472:	31 c0                	xor    %eax,%eax
     474:	e8 00 00 00 00       	callq  479 <topmc_value_write_nehelam+0xf9>
     479:	31 c0                	xor    %eax,%eax
		return 0;
     47b:	eb 81                	jmp    3fe <topmc_value_write_nehelam+0x7e>
     47d:	0f 1f 00             	nopl   (%rax)

0000000000000480 <topmc_value_read_callable_impl_nehelam>:
}


#ifdef TOPMC_PER_SECOND
u64 topmc_value_read_callable_impl_nehelam(unsigned short cpu, unsigned short counter)
{
     480:	55                   	push   %rbp
     481:	48 89 e5             	mov    %rsp,%rbp
     484:	e8 00 00 00 00       	callq  489 <topmc_value_read_callable_impl_nehelam+0x9>
	u64 val;
	u32 lo,hi;
	unsigned int perfctr;

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     489:	66 83 fe 0b          	cmp    $0xb,%si
     48d:	77 2c                	ja     4bb <topmc_value_read_callable_impl_nehelam+0x3b>
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     48f:	66 83 fe 03          	cmp    $0x3,%si
     493:	76 1b                	jbe    4b0 <topmc_value_read_callable_impl_nehelam+0x30>
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
		//      perfctrl = TOPMC_MSR_XEON55XX_EVNTSEL0 + counter;
	}
	else {  
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
     495:	0f b7 ce             	movzwl %si,%ecx
     498:	81 c1 ac 03 00 00    	add    $0x3ac,%ecx
	//      printk("+->topmc_value_read() : enable == 0\n");
	val = topmc_procs[cpu][counter].value;
	}
	 */
//	printk("topmc_value_read_callable:perfctr= %x\n", perfctr);
	__asm__ __volatile__ ("rdmsr" : "=a" (lo), "=d" (hi) : "c" (perfctr));
     49e:	0f 32                	rdmsr  
     4a0:	89 c1                	mov    %eax,%ecx
	val = (u64)hi<<32 | lo;
     4a2:	48 89 d0             	mov    %rdx,%rax
     4a5:	48 c1 e0 20          	shl    $0x20,%rax
     4a9:	89 c9                	mov    %ecx,%ecx
     4ab:	48 09 c8             	or     %rcx,%rax
//	val = counter + cpu;
//	printk("topmc_value_read_callable: %llu\n", val);
	return val;
}
     4ae:	c9                   	leaveq 
     4af:	c3                   	retq   

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
     4b0:	0f b7 ce             	movzwl %si,%ecx
     4b3:	81 c1 c1 00 00 00    	add    $0xc1,%ecx
     4b9:	eb e3                	jmp    49e <topmc_value_read_callable_impl_nehelam+0x1e>
	u64 val;
	u32 lo,hi;
	unsigned int perfctr;

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);
     4bb:	0f b7 f6             	movzwl %si,%esi
     4be:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     4c5:	31 c0                	xor    %eax,%eax
     4c7:	e8 00 00 00 00       	callq  4cc <topmc_value_read_callable_impl_nehelam+0x4c>
     4cc:	31 c0                	xor    %eax,%eax
	__asm__ __volatile__ ("rdmsr" : "=a" (lo), "=d" (hi) : "c" (perfctr));
	val = (u64)hi<<32 | lo;
//	val = counter + cpu;
//	printk("topmc_value_read_callable: %llu\n", val);
	return val;
}
     4ce:	c9                   	leaveq 
     4cf:	c3                   	retq   

00000000000004d0 <topmc_value_read_nehelam>:

#endif
//EXPORT_SYMBOL(topmc_value_read_callable);

int topmc_value_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     4d0:	55                   	push   %rbp
     4d1:	48 89 e5             	mov    %rsp,%rbp
     4d4:	53                   	push   %rbx
     4d5:	48 83 ec 18          	sub    $0x18,%rsp
     4d9:	e8 00 00 00 00       	callq  4de <topmc_value_read_nehelam+0xe>
     4de:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;
	//u64 val_ctrl;

	topmc_split32to16(mix,&cpu,&counter);
     4e1:	41 8b 39             	mov    (%r9),%edi
     4e4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     4e8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     4ec:	e8 00 00 00 00       	callq  4f1 <topmc_value_read_nehelam+0x21>

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     4f1:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
     4f5:	66 83 f8 0b          	cmp    $0xb,%ax
     4f9:	0f 87 96 00 00 00    	ja     595 <topmc_value_read_nehelam+0xc5>
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     4ff:	66 83 f8 03          	cmp    $0x3,%ax
     503:	76 53                	jbe    558 <topmc_value_read_nehelam+0x88>
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
	}
	else {
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
     505:	0f b7 c0             	movzwl %ax,%eax
     508:	8d b0 ac 03 00 00    	lea    0x3ac(%rax),%esi
	}
	if(topmc_procs[cpu][counter].enable == 1){
     50e:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     512:	48 98                	cltq   
     514:	48 63 d7             	movslq %edi,%rdx
     517:	48 c1 e2 05          	shl    $0x5,%rdx
     51b:	48 8d 04 02          	lea    (%rdx,%rax,1),%rax
     51f:	48 c1 e0 04          	shl    $0x4,%rax
     523:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     52a:	74 3c                	je     568 <topmc_value_read_nehelam+0x98>
		TOPMC_RDMSRL(perfctr, val, cpu);
		sprintf(page, "%llu\n", val);

	}else{
		//      printk("+->topmc_value_read() : enable == 0\n");
		sprintf(page,"%llu\n",topmc_procs[cpu][counter].value);
     52c:	48 8b 90 00 00 00 00 	mov    0x0(%rax),%rdx
     533:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     53a:	48 89 df             	mov    %rbx,%rdi
     53d:	31 c0                	xor    %eax,%eax
     53f:	e8 00 00 00 00       	callq  544 <topmc_value_read_nehelam+0x74>
	}

	return strlen(page); //len of read
     544:	48 89 df             	mov    %rbx,%rdi
     547:	e8 00 00 00 00       	callq  54c <topmc_value_read_nehelam+0x7c>
}
     54c:	48 83 c4 18          	add    $0x18,%rsp
     550:	5b                   	pop    %rbx
     551:	c9                   	leaveq 
     552:	c3                   	retq   
     553:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
     558:	0f b7 c0             	movzwl %ax,%eax
     55b:	8d b0 c1 00 00 00    	lea    0xc1(%rax),%esi
     561:	eb ab                	jmp    50e <topmc_value_read_nehelam+0x3e>
     563:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	else {
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
	}
	if(topmc_procs[cpu][counter].enable == 1){
		//      printk("+->topmc_value_read() : enable ==1   \n");
		TOPMC_RDMSRL(perfctr, val, cpu);
     568:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
     56c:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
     570:	e8 00 00 00 00       	callq  575 <topmc_value_read_nehelam+0xa5>
		sprintf(page, "%llu\n", val);
     575:	8b 55 e4             	mov    -0x1c(%rbp),%edx
     578:	8b 45 e8             	mov    -0x18(%rbp),%eax
     57b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     582:	48 89 df             	mov    %rbx,%rdi
     585:	48 c1 e2 20          	shl    $0x20,%rdx
     589:	48 09 c2             	or     %rax,%rdx
     58c:	31 c0                	xor    %eax,%eax
     58e:	e8 00 00 00 00       	callq  593 <topmc_value_read_nehelam+0xc3>
     593:	eb af                	jmp    544 <topmc_value_read_nehelam+0x74>
	//u64 val_ctrl;

	topmc_split32to16(mix,&cpu,&counter);

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);
     595:	0f b7 f0             	movzwl %ax,%esi
     598:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     59f:	31 c0                	xor    %eax,%eax
     5a1:	e8 00 00 00 00       	callq  5a6 <topmc_value_read_nehelam+0xd6>
     5a6:	31 c0                	xor    %eax,%eax

		return 0;
     5a8:	eb a2                	jmp    54c <topmc_value_read_nehelam+0x7c>
     5aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000005b0 <topmc_event_read_nehelam>:
unit---MUST BE two numbers
kernel/user---MUST BE one of the following number: 0-"neither",1-"only user",2-"only kernel",3-"both"

*/
int topmc_event_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     5b0:	55                   	push   %rbp
     5b1:	48 89 e5             	mov    %rsp,%rbp
     5b4:	53                   	push   %rbx
     5b5:	48 83 ec 18          	sub    $0x18,%rsp
     5b9:	e8 00 00 00 00       	callq  5be <topmc_event_read_nehelam+0xe>
     5be:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     5c1:	41 8b 39             	mov    (%r9),%edi
     5c4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     5c8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     5cc:	e8 00 00 00 00       	callq  5d1 <topmc_event_read_nehelam+0x21>

	sprintf(page,"0x%08x\n",topmc_procs[cpu][counter].event);
     5d1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
     5d5:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
     5d9:	48 89 df             	mov    %rbx,%rdi
     5dc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     5e3:	48 c1 e0 05          	shl    $0x5,%rax
     5e7:	48 01 d0             	add    %rdx,%rax
     5ea:	48 c1 e0 04          	shl    $0x4,%rax
     5ee:	8b 90 00 00 00 00    	mov    0x0(%rax),%edx
     5f4:	31 c0                	xor    %eax,%eax
     5f6:	e8 00 00 00 00       	callq  5fb <topmc_event_read_nehelam+0x4b>

	return strlen(page); //len of read, event must between 01~99
     5fb:	48 89 df             	mov    %rbx,%rdi
     5fe:	e8 00 00 00 00       	callq  603 <topmc_event_read_nehelam+0x53>
}
     603:	48 83 c4 18          	add    $0x18,%rsp
     607:	5b                   	pop    %rbx
     608:	c9                   	leaveq 
     609:	c3                   	retq   
     60a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000610 <topmc_event_write_nehelam>:

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     610:	55                   	push   %rbp
     611:	48 89 e5             	mov    %rsp,%rbp
     614:	48 83 ec 40          	sub    $0x40,%rsp
     618:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
     61c:	4c 89 65 e8          	mov    %r12,-0x18(%rbp)
     620:	4c 89 6d f0          	mov    %r13,-0x10(%rbp)
     624:	4c 89 75 f8          	mov    %r14,-0x8(%rbp)
     628:	e8 00 00 00 00       	callq  62d <topmc_event_write_nehelam+0x1d>
     62d:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     634:	00 00 
     636:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
     63a:	31 c0                	xor    %eax,%eax
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     63c:	8b 39                	mov    (%rcx),%edi

	return strlen(page); //len of read, event must between 01~99
}

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     63e:	49 89 f5             	mov    %rsi,%r13
     641:	48 89 d3             	mov    %rdx,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     644:	48 8d 75 ce          	lea    -0x32(%rbp),%rsi
     648:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
     64c:	4c 8d 65 d0          	lea    -0x30(%rbp),%r12
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     650:	e8 00 00 00 00       	callq  655 <topmc_event_write_nehelam+0x45>

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
     655:	ba 08 00 00 00       	mov    $0x8,%edx
     65a:	4c 89 ee             	mov    %r13,%rsi
     65d:	4c 89 e7             	mov    %r12,%rdi
     660:	e8 00 00 00 00       	callq  665 <topmc_event_write_nehelam+0x55>
	if (ret < 0)
     665:	48 85 c0             	test   %rax,%rax
     668:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
     66d:	79 31                	jns    6a0 <topmc_event_write_nehelam+0x90>
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
}
     66f:	89 d0                	mov    %edx,%eax
     671:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
     675:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
     67c:	00 00 
     67e:	0f 85 96 00 00 00    	jne    71a <topmc_event_write_nehelam+0x10a>
     684:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
     688:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
     68c:	4c 8b 6d f0          	mov    -0x10(%rbp),%r13
     690:	4c 8b 75 f8          	mov    -0x8(%rbp),%r14
     694:	c9                   	leaveq 
     695:	c3                   	retq   
     696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     69d:	00 00 00 
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     6a0:	48 83 f8 08          	cmp    $0x8,%rax
     6a4:	7f 6a                	jg     710 <topmc_event_write_nehelam+0x100>
     6a6:	48 85 c0             	test   %rax,%rax
     6a9:	74 65                	je     710 <topmc_event_write_nehelam+0x100>
	sprintf(page,"0x%08x\n",topmc_procs[cpu][counter].event);

	return strlen(page); //len of read, event must between 01~99
}

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
     6ab:	49 8d 4c 24 08       	lea    0x8(%r12),%rcx
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     6b0:	4c 89 e0             	mov    %r12,%rax
     6b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
     6b8:	0f b6 10             	movzbl (%rax),%edx
     6bb:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
     6c2:	83 e2 44             	and    $0x44,%edx
     6c5:	74 58                	je     71f <topmc_event_write_nehelam+0x10f>
			topmc_procs[cpu][counter].event = 0;
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
     6c7:	48 83 c0 01          	add    $0x1,%rax
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
     6cb:	48 39 c8             	cmp    %rcx,%rax
     6ce:	75 e8                	jne    6b8 <topmc_event_write_nehelam+0xa8>
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
     6d0:	44 0f b7 6d ce       	movzwl -0x32(%rbp),%r13d
     6d5:	44 0f b7 75 cc       	movzwl -0x34(%rbp),%r14d
     6da:	ba 10 00 00 00       	mov    $0x10,%edx
     6df:	be 08 00 00 00       	mov    $0x8,%esi
     6e4:	4c 89 e7             	mov    %r12,%rdi
     6e7:	e8 00 00 00 00       	callq  6ec <topmc_event_write_nehelam+0xdc>
out:
	return count;
     6ec:	89 da                	mov    %ebx,%edx
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
     6ee:	4d 63 ed             	movslq %r13d,%r13
     6f1:	4d 63 f6             	movslq %r14d,%r14
     6f4:	49 c1 e5 05          	shl    $0x5,%r13
     6f8:	4d 01 f5             	add    %r14,%r13
     6fb:	49 c1 e5 04          	shl    $0x4,%r13
     6ff:	41 89 85 00 00 00 00 	mov    %eax,0x0(%r13)
out:
	return count;
     706:	e9 64 ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
     70b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     710:	ba ea ff ff ff       	mov    $0xffffffea,%edx
     715:	e9 55 ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
}
     71a:	e8 00 00 00 00       	callq  71f <topmc_event_write_nehelam+0x10f>
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
			topmc_procs[cpu][counter].event = 0;
     71f:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     723:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
			printk("+->topmc_event_write():event error:%s!!!\n",event);
     727:	4c 89 e6             	mov    %r12,%rsi
     72a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
			topmc_procs[cpu][counter].event = 0;
     731:	48 c1 e0 05          	shl    $0x5,%rax
     735:	48 01 d0             	add    %rdx,%rax
     738:	48 c1 e0 04          	shl    $0x4,%rax
     73c:	c7 80 00 00 00 00 00 	movl   $0x0,0x0(%rax)
     743:	00 00 00 
			printk("+->topmc_event_write():event error:%s!!!\n",event);
     746:	31 c0                	xor    %eax,%eax
     748:	e8 00 00 00 00       	callq  74d <topmc_event_write_nehelam+0x13d>
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
     74d:	89 da                	mov    %ebx,%edx
     74f:	e9 1b ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
     754:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
     75b:	00 00 00 00 00 

0000000000000760 <topmc_enable_write_nehelam>:
	return 2; //len of read
}


int topmc_enable_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     760:	55                   	push   %rbp
     761:	48 89 e5             	mov    %rsp,%rbp
     764:	41 57                	push   %r15
     766:	41 56                	push   %r14
     768:	41 55                	push   %r13
     76a:	41 54                	push   %r12
     76c:	53                   	push   %rbx
     76d:	48 83 ec 18          	sub    $0x18,%rsp
     771:	e8 00 00 00 00       	callq  776 <topmc_enable_write_nehelam+0x16>
	//unsigned int low = 0,high =0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
     776:	8b 39                	mov    (%rcx),%edi
	return 2; //len of read
}


int topmc_enable_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     778:	48 89 f3             	mov    %rsi,%rbx
     77b:	49 89 d4             	mov    %rdx,%r12
	//unsigned int low = 0,high =0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
     77e:	48 8d 75 ce          	lea    -0x32(%rbp),%rsi
     782:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     786:	e8 00 00 00 00       	callq  78b <topmc_enable_write_nehelam+0x2b>
	get_user(enable,buffer);
     78b:	48 89 d8             	mov    %rbx,%rax
     78e:	e8 00 00 00 00       	callq  793 <topmc_enable_write_nehelam+0x33>

	event   = topmc_procs[cpu][counter].event;
     793:	44 0f b7 45 ce       	movzwl -0x32(%rbp),%r8d
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);
     798:	41 89 d7             	mov    %edx,%r15d

	event   = topmc_procs[cpu][counter].event;
     79b:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
     79f:	41 0f b7 f8          	movzwl %r8w,%edi
     7a3:	0f b7 ca             	movzwl %dx,%ecx
     7a6:	48 63 c7             	movslq %edi,%rax
     7a9:	48 63 d9             	movslq %ecx,%rbx
     7ac:	48 c1 e0 05          	shl    $0x5,%rax
     7b0:	48 01 d8             	add    %rbx,%rax
     7b3:	48 c1 e0 04          	shl    $0x4,%rax
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     7b7:	66 83 fa 03          	cmp    $0x3,%dx
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
     7bb:	8b 98 00 00 00 00    	mov    0x0(%rax),%ebx
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     7c1:	0f 87 99 01 00 00    	ja     960 <topmc_enable_write_nehelam+0x200>
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     7c7:	89 de                	mov    %ebx,%esi
     7c9:	45 31 f6             	xor    %r14d,%r14d
     7cc:	41 bd 01 00 00 00    	mov    $0x1,%r13d
     7d2:	83 e6 0f             	and    $0xf,%esi
     7d5:	83 fe 01             	cmp    $0x1,%esi
     7d8:	74 39                	je     813 <topmc_enable_write_nehelam+0xb3>
     7da:	0f 8e 00 04 00 00    	jle    be0 <topmc_enable_write_nehelam+0x480>
     7e0:	45 31 ed             	xor    %r13d,%r13d
     7e3:	83 fe 02             	cmp    $0x2,%esi
     7e6:	41 be 01 00 00 00    	mov    $0x1,%r14d
     7ec:	74 25                	je     813 <topmc_enable_write_nehelam+0xb3>
     7ee:	83 fe 03             	cmp    $0x3,%esi
				user=1;
				break;
			case 2:
				kernel=1;
				user=0;
				break;
     7f1:	41 b5 01             	mov    $0x1,%r13b
	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     7f4:	74 1d                	je     813 <topmc_enable_write_nehelam+0xb3>
				break;
			case 3:
				kernel=user=1;
				break;
			default:
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
     7f6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     7fd:	31 c0                	xor    %eax,%eax
     7ff:	45 31 ed             	xor    %r13d,%r13d
     802:	e8 00 00 00 00       	callq  807 <topmc_enable_write_nehelam+0xa7>
     807:	0f b7 4d cc          	movzwl -0x34(%rbp),%ecx
     80b:	44 0f b7 45 ce       	movzwl -0x32(%rbp),%r8d
     810:	45 31 f6             	xor    %r14d,%r14d
				break;
		}
		if(enable=='1'){
     813:	41 80 ff 31          	cmp    $0x31,%r15b
     817:	0f 84 1b 02 00 00    	je     a38 <topmc_enable_write_nehelam+0x2d8>
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     81d:	8d b1 c1 00 00 00    	lea    0xc1(%rcx),%esi
     823:	41 0f b7 f8          	movzwl %r8w,%edi
     827:	31 c9                	xor    %ecx,%ecx
     829:	31 d2                	xor    %edx,%edx
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     82b:	48 8d 5d c4          	lea    -0x3c(%rbp),%rbx
     82f:	4c 8d 6d c8          	lea    -0x38(%rbp),%r13
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     833:	e8 00 00 00 00       	callq  838 <topmc_enable_write_nehelam+0xd8>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     838:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     83c:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     840:	48 89 d9             	mov    %rbx,%rcx
     843:	4c 89 ea             	mov    %r13,%rdx
     846:	81 c6 86 01 00 00    	add    $0x186,%esi
     84c:	e8 00 00 00 00       	callq  851 <topmc_enable_write_nehelam+0xf1>
     851:	8b 45 c4             	mov    -0x3c(%rbp),%eax
     854:	8b 55 c8             	mov    -0x38(%rbp),%edx
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     857:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     85b:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     85f:	48 c1 e0 20          	shl    $0x20,%rax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     863:	81 e2 00 00 20 00    	and    $0x200000,%edx
     869:	48 09 c2             	or     %rax,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     86c:	81 c6 86 01 00 00    	add    $0x186,%esi
     872:	48 89 d1             	mov    %rdx,%rcx
     875:	48 c1 e9 20          	shr    $0x20,%rcx
     879:	e8 00 00 00 00       	callq  87e <topmc_enable_write_nehelam+0x11e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
     87e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     882:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     886:	4c 89 e9             	mov    %r13,%rcx
     889:	48 89 da             	mov    %rbx,%rdx
     88c:	81 c6 c1 00 00 00    	add    $0xc1,%esi
     892:	e8 00 00 00 00       	callq  897 <topmc_enable_write_nehelam+0x137>
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     897:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     89b:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     89f:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
     8a2:	0f b7 c7             	movzwl %di,%eax
     8a5:	48 63 d6             	movslq %esi,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     8a8:	81 c6 c1 00 00 00    	add    $0xc1,%esi
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     8ae:	48 c1 e0 05          	shl    $0x5,%rax
     8b2:	48 8d 14 10          	lea    (%rax,%rdx,1),%rdx
     8b6:	8b 45 c8             	mov    -0x38(%rbp),%eax
     8b9:	48 c1 e2 04          	shl    $0x4,%rdx
     8bd:	48 c1 e0 20          	shl    $0x20,%rax
     8c1:	48 09 c8             	or     %rcx,%rax
     8c4:	48 89 82 00 00 00 00 	mov    %rax,0x0(%rdx)
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     8cb:	31 c9                	xor    %ecx,%ecx
     8cd:	31 d2                	xor    %edx,%edx
     8cf:	e8 00 00 00 00       	callq  8d4 <topmc_enable_write_nehelam+0x174>
			topmc_procs[cpu][counter].enable = 0;
     8d4:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     8d8:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     8dc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
			topmc_procs[cpu][counter].enable = 0;
     8e3:	48 c1 e0 05          	shl    $0x5,%rax
     8e7:	48 01 d0             	add    %rdx,%rax
     8ea:	48 c1 e0 04          	shl    $0x4,%rax
     8ee:	c7 80 00 00 00 00 00 	movl   $0x0,0x0(%rax)
     8f5:	00 00 00 
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     8f8:	e8 00 00 00 00       	callq  8fd <topmc_enable_write_nehelam+0x19d>
     8fd:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 904 <topmc_enable_write_nehelam+0x1a4>
	{
		set_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
	}
	else
	{
		clr_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
     904:	66 c7 05 00 00 00 00 	movw   $0x0,0x0(%rip)        # 90d <topmc_enable_write_nehelam+0x1ad>
     90b:	00 00 
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     90d:	48 89 c6             	mov    %rax,%rsi
     910:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     917:	e8 00 00 00 00       	callq  91c <topmc_enable_write_nehelam+0x1bc>
	}
	spin_unlock_irqrestore(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
	spin_lock_irqsave(&topmc_chg_lock, topmc_pmc_chg_flags);
     91c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     923:	e8 00 00 00 00       	callq  928 <topmc_enable_write_nehelam+0x1c8>
     928:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     92f:	48 89 c6             	mov    %rax,%rsi
     932:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 939 <topmc_enable_write_nehelam+0x1d9>
//	printk("topmc_enable_write: before topmc_pmc_chg=%d\n",topmc_pmc_chg);
	topmc_pmc_chg = 1;
     939:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 943 <topmc_enable_write_nehelam+0x1e3>
     940:	00 00 00 
     943:	e8 00 00 00 00       	callq  948 <topmc_enable_write_nehelam+0x1e8>
	spin_unlock_irqrestore(&topmc_chg_lock, topmc_pmc_chg_flags);
#endif

out:
	return count;
}
     948:	48 83 c4 18          	add    $0x18,%rsp
     94c:	44 89 e0             	mov    %r12d,%eax
     94f:	5b                   	pop    %rbx
     950:	41 5c                	pop    %r12
     952:	41 5d                	pop    %r13
     954:	41 5e                	pop    %r14
     956:	41 5f                	pop    %r15
     958:	c9                   	leaveq 
     959:	c3                   	retq   
     95a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			topmc_procs[cpu][counter].enable        = 0;
		}
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
     960:	83 ea 04             	sub    $0x4,%edx
     963:	66 83 fa 07          	cmp    $0x7,%dx
     967:	0f 87 a3 00 00 00    	ja     a10 <topmc_enable_write_nehelam+0x2b0>
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
     96d:	41 80 ff 31          	cmp    $0x31,%r15b
     971:	0f 84 d9 01 00 00    	je     b50 <topmc_enable_write_nehelam+0x3f0>
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
			//printk("+->topmc_enable_write() enabled [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
		}
		else {
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     977:	8d b1 ac 03 00 00    	lea    0x3ac(%rcx),%esi
     97d:	31 d2                	xor    %edx,%edx
     97f:	31 c9                	xor    %ecx,%ecx
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     981:	48 8d 5d c8          	lea    -0x38(%rbp),%rbx
     985:	4c 8d 6d c4          	lea    -0x3c(%rbp),%r13
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
			//printk("+->topmc_enable_write() enabled [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
		}
		else {
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     989:	e8 00 00 00 00       	callq  98e <topmc_enable_write_nehelam+0x22e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     98e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     992:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     996:	48 89 d9             	mov    %rbx,%rcx
     999:	4c 89 ea             	mov    %r13,%rdx
     99c:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     9a2:	e8 00 00 00 00       	callq  9a7 <topmc_enable_write_nehelam+0x247>
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     9a7:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9ab:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9af:	31 c9                	xor    %ecx,%ecx
     9b1:	31 d2                	xor    %edx,%edx
     9b3:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     9b9:	e8 00 00 00 00       	callq  9be <topmc_enable_write_nehelam+0x25e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     9be:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9c2:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9c6:	4c 89 e9             	mov    %r13,%rcx
     9c9:	48 89 da             	mov    %rbx,%rdx
     9cc:	81 c6 ac 03 00 00    	add    $0x3ac,%esi
     9d2:	e8 00 00 00 00       	callq  9d7 <topmc_enable_write_nehelam+0x277>
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     9d7:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9db:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9df:	8b 4d c8             	mov    -0x38(%rbp),%ecx
     9e2:	0f b7 c7             	movzwl %di,%eax
     9e5:	48 63 d6             	movslq %esi,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     9e8:	81 c6 ac 03 00 00    	add    $0x3ac,%esi
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     9ee:	48 c1 e0 05          	shl    $0x5,%rax
     9f2:	48 8d 14 10          	lea    (%rax,%rdx,1),%rdx
     9f6:	8b 45 c4             	mov    -0x3c(%rbp),%eax
     9f9:	48 c1 e2 04          	shl    $0x4,%rdx
     9fd:	48 c1 e0 20          	shl    $0x20,%rax
     a01:	48 09 c8             	or     %rcx,%rax
     a04:	48 89 82 00 00 00 00 	mov    %rax,0x0(%rdx)
     a0b:	e9 bb fe ff ff       	jmpq   8cb <topmc_enable_write_nehelam+0x16b>
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     a10:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     a17:	e8 00 00 00 00       	callq  a1c <topmc_enable_write_nehelam+0x2bc>
	if(enable == '1')
     a1c:	41 80 ff 31          	cmp    $0x31,%r15b
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     a20:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # a27 <topmc_enable_write_nehelam+0x2c7>
	if(enable == '1')
     a27:	0f 85 d7 fe ff ff    	jne    904 <topmc_enable_write_nehelam+0x1a4>
     a2d:	e9 01 01 00 00       	jmpq   b33 <topmc_enable_write_nehelam+0x3d3>
     a32:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			default:
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
				break;
		}
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
     a38:	41 0f b7 c0          	movzwl %r8w,%eax
     a3c:	48 63 d1             	movslq %ecx,%rdx
     a3f:	48 c1 e0 05          	shl    $0x5,%rax
     a43:	48 01 d0             	add    %rdx,%rax
     a46:	48 c1 e0 04          	shl    $0x4,%rax
     a4a:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     a51:	0f 84 99 01 00 00    	je     bf0 <topmc_enable_write_nehelam+0x490>
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     a57:	8d b1 c1 00 00 00    	lea    0xc1(%rcx),%esi
     a5d:	41 0f b7 f8          	movzwl %r8w,%edi
     a61:	31 c9                	xor    %ecx,%ecx
     a63:	31 d2                	xor    %edx,%edx
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     a65:	41 c1 e5 10          	shl    $0x10,%r13d
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     a69:	41 c1 e6 11          	shl    $0x11,%r14d
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     a6d:	e8 00 00 00 00       	callq  a72 <topmc_enable_write_nehelam+0x312>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a72:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     a76:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     a7a:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     a7e:	48 8d 55 c4          	lea    -0x3c(%rbp),%rdx
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     a82:	4d 63 ed             	movslq %r13d,%r13
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     a85:	4d 63 f6             	movslq %r14d,%r14
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a88:	81 c6 86 01 00 00    	add    $0x186,%esi
     a8e:	e8 00 00 00 00       	callq  a93 <topmc_enable_write_nehelam+0x333>
     a93:	8b 45 c8             	mov    -0x38(%rbp),%eax
     a96:	8b 55 c4             	mov    -0x3c(%rbp),%edx
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     a99:	89 d9                	mov    %ebx,%ecx
     a9b:	c1 e1 0f             	shl    $0xf,%ecx
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a9e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     aa2:	81 e1 00 00 80 00    	and    $0x800000,%ecx
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     aa8:	48 c1 e0 20          	shl    $0x20,%rax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     aac:	81 e2 00 00 20 00    	and    $0x200000,%edx
     ab2:	48 09 c2             	or     %rax,%rdx
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
     ab5:	89 d8                	mov    %ebx,%eax
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     ab7:	81 c6 86 01 00 00    	add    $0x186,%esi
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
     abd:	c1 e8 18             	shr    $0x18,%eax
     ac0:	89 c0                	mov    %eax,%eax
     ac2:	48 0d 00 00 50 00    	or     $0x500000,%rax
			TOPMC_CTRL_SET_KERN(val, kernel);
     ac8:	48 09 d0             	or     %rdx,%rax
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     acb:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ace:	c1 e3 0e             	shl    $0xe,%ebx
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     ad1:	48 c1 ea 08          	shr    $0x8,%rdx
     ad5:	81 e2 00 ff 00 00    	and    $0xff00,%edx
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
     adb:	48 09 d0             	or     %rdx,%rax
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ade:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     ae1:	48 09 c1             	or     %rax,%rcx
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ae4:	81 e2 00 00 04 00    	and    $0x40000,%edx
     aea:	48 09 ca             	or     %rcx,%rdx
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     aed:	4c 09 ea             	or     %r13,%rdx
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     af0:	4c 09 f2             	or     %r14,%rdx
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     af3:	48 89 d1             	mov    %rdx,%rcx
     af6:	48 c1 e9 20          	shr    $0x20,%rcx
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     afa:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     afe:	e8 00 00 00 00       	callq  b03 <topmc_enable_write_nehelam+0x3a3>
			topmc_procs[cpu][counter].enable = 1;
     b03:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     b07:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     b0b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
     b12:	48 c1 e0 05          	shl    $0x5,%rax
     b16:	48 01 d0             	add    %rdx,%rax
     b19:	48 c1 e0 04          	shl    $0x4,%rax
     b1d:	c7 80 00 00 00 00 01 	movl   $0x1,0x0(%rax)
     b24:	00 00 00 
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     b27:	e8 00 00 00 00       	callq  b2c <topmc_enable_write_nehelam+0x3cc>
     b2c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # b33 <topmc_enable_write_nehelam+0x3d3>
	if(enable == '1')
	{
		set_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
     b33:	0f b7 4d cc          	movzwl -0x34(%rbp),%ecx
     b37:	ba 01 00 00 00       	mov    $0x1,%edx
     b3c:	d3 e2                	shl    %cl,%edx
     b3e:	66 09 15 00 00 00 00 	or     %dx,0x0(%rip)        # b45 <topmc_enable_write_nehelam+0x3e5>
     b45:	e9 c3 fd ff ff       	jmpq   90d <topmc_enable_write_nehelam+0x1ad>
     b4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		}
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
			if( topmc_procs[cpu][counter].enable == 1) {
     b50:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     b57:	0f 84 a6 00 00 00    	je     c03 <topmc_enable_write_nehelam+0x4a3>
				printk("+->topmc_enable_write(): already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     b5d:	8d b1 ac 03 00 00    	lea    0x3ac(%rcx),%esi
     b63:	31 d2                	xor    %edx,%edx
     b65:	31 c9                	xor    %ecx,%ecx
     b67:	e8 00 00 00 00       	callq  b6c <topmc_enable_write_nehelam+0x40c>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     b6c:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     b70:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     b74:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
     b78:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     b7c:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     b82:	e8 00 00 00 00       	callq  b87 <topmc_enable_write_nehelam+0x427>
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b87:	89 d8                	mov    %ebx,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b89:	48 89 da             	mov    %rbx,%rdx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     b8c:	89 d9                	mov    %ebx,%ecx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b8e:	c1 e8 18             	shr    $0x18,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b91:	48 c1 ea 08          	shr    $0x8,%rdx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     b95:	c1 e1 0f             	shl    $0xf,%ecx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b98:	89 c0                	mov    %eax,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b9a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     ba0:	c1 e3 0e             	shl    $0xe,%ebx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     ba3:	48 0d 00 00 50 00    	or     $0x500000,%rax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     ba9:	81 e1 00 00 80 00    	and    $0x800000,%ecx
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     baf:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     bb3:	48 09 d0             	or     %rdx,%rax
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     bb6:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     bb9:	48 09 c1             	or     %rax,%rcx
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     bbc:	81 e2 00 00 04 00    	and    $0x40000,%edx
     bc2:	48 09 ca             	or     %rcx,%rdx
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     bc5:	48 89 d1             	mov    %rdx,%rcx
     bc8:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     bce:	48 c1 e9 20          	shr    $0x20,%rcx
     bd2:	e9 23 ff ff ff       	jmpq   afa <topmc_enable_write_nehelam+0x39a>
     bd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     bde:	00 00 
	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     be0:	45 30 ed             	xor    %r13b,%r13b
     be3:	85 f6                	test   %esi,%esi
     be5:	0f 84 28 fc ff ff    	je     813 <topmc_enable_write_nehelam+0xb3>
     beb:	e9 06 fc ff ff       	jmpq   7f6 <topmc_enable_write_nehelam+0x96>
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
				break;
		}
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
     bf0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     bf7:	31 c0                	xor    %eax,%eax
     bf9:	e8 00 00 00 00       	callq  bfe <topmc_enable_write_nehelam+0x49e>
				goto out;
     bfe:	e9 45 fd ff ff       	jmpq   948 <topmc_enable_write_nehelam+0x1e8>
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
			if( topmc_procs[cpu][counter].enable == 1) {
				printk("+->topmc_enable_write(): already enabled, skip this!!!\n");
     c03:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     c0a:	31 c0                	xor    %eax,%eax
     c0c:	e8 00 00 00 00       	callq  c11 <topmc_enable_write_nehelam+0x4b1>
				goto out;
     c11:	e9 32 fd ff ff       	jmpq   948 <topmc_enable_write_nehelam+0x1e8>
     c16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     c1d:	00 00 00 

0000000000000c20 <topmc_enable_all_write_nehelam>:
	*(page+1) = '\n';
	return 2; //len of read
}

int topmc_enable_all_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     c20:	55                   	push   %rbp
     c21:	48 89 e5             	mov    %rsp,%rbp
     c24:	41 57                	push   %r15
     c26:	41 56                	push   %r14
     c28:	41 55                	push   %r13
     c2a:	41 54                	push   %r12
     c2c:	53                   	push   %rbx
     c2d:	48 83 ec 38          	sub    $0x38,%rsp
     c31:	e8 00 00 00 00       	callq  c36 <topmc_enable_all_write_nehelam+0x16>
     c36:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
	//unsigned int low=0,high=0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val;

	get_user(enable,buffer);
     c3a:	48 89 f0             	mov    %rsi,%rax
     c3d:	e8 00 00 00 00       	callq  c42 <topmc_enable_all_write_nehelam+0x22>
     c42:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
     c47:	88 55 bf             	mov    %dl,-0x41(%rbp)
     c4a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     c51:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     c58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     c5f:	00 
     c60:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # c67 <topmc_enable_all_write_nehelam+0x47>
     c67:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # c6e <topmc_enable_all_write_nehelam+0x4e>
     c6e:	83 c3 01             	add    $0x1,%ebx
     c71:	48 63 d3             	movslq %ebx,%rdx
     c74:	e8 00 00 00 00       	callq  c79 <topmc_enable_all_write_nehelam+0x59>
	for_each_online_cpu(cpu){
     c79:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # c7f <topmc_enable_all_write_nehelam+0x5f>
     c7f:	89 c3                	mov    %eax,%ebx
     c81:	0f 8d 64 03 00 00    	jge    feb <topmc_enable_all_write_nehelam+0x3cb>
     c87:	48 98                	cltq   
     c89:	41 be 86 01 00 00    	mov    $0x186,%r14d
     c8f:	41 bc c1 00 00 00    	mov    $0xc1,%r12d
     c95:	49 89 c5             	mov    %rax,%r13
     c98:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
     c9c:	49 c1 e5 09          	shl    $0x9,%r13
     ca0:	49 81 c5 00 00 00 00 	add    $0x0,%r13
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
     ca7:	45 8b 7d 00          	mov    0x0(%r13),%r15d
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     cab:	44 89 fe             	mov    %r15d,%esi
     cae:	83 e6 0f             	and    $0xf,%esi
     cb1:	83 fe 01             	cmp    $0x1,%esi
     cb4:	0f 84 fe 02 00 00    	je     fb8 <topmc_enable_all_write_nehelam+0x398>
     cba:	0f 8e 10 03 00 00    	jle    fd0 <topmc_enable_all_write_nehelam+0x3b0>
     cc0:	83 fe 02             	cmp    $0x2,%esi
     cc3:	0f 84 d7 02 00 00    	je     fa0 <topmc_enable_all_write_nehelam+0x380>
     cc9:	83 fe 03             	cmp    $0x3,%esi
     ccc:	0f 1f 40 00          	nopl   0x0(%rax)
     cd0:	0f 84 b2 02 00 00    	je     f88 <topmc_enable_all_write_nehelam+0x368>
					break;
				case 3:
					kernel=user=1;
					break;
				default:
					printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
     cd6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     cdd:	31 c0                	xor    %eax,%eax
     cdf:	e8 00 00 00 00       	callq  ce4 <topmc_enable_all_write_nehelam+0xc4>
					break;
			}

			if(enable=='1'){
     ce4:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
     ce8:	0f 85 0a 02 00 00    	jne    ef8 <topmc_enable_all_write_nehelam+0x2d8>
				if(topmc_procs[cpu][counter].enable==1){
     cee:	41 83 7d fc 01       	cmpl   $0x1,-0x4(%r13)
     cf3:	0f 84 80 03 00 00    	je     1079 <topmc_enable_all_write_nehelam+0x459>
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}

				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     cf9:	31 c9                	xor    %ecx,%ecx
     cfb:	31 d2                	xor    %edx,%edx
     cfd:	44 89 e6             	mov    %r12d,%esi
     d00:	89 df                	mov    %ebx,%edi
     d02:	e8 00 00 00 00       	callq  d07 <topmc_enable_all_write_nehelam+0xe7>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d07:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     d0b:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     d0f:	44 89 f6             	mov    %r14d,%esi
     d12:	89 df                	mov    %ebx,%edi
     d14:	e8 00 00 00 00       	callq  d19 <topmc_enable_all_write_nehelam+0xf9>
     d19:	8b 55 cc             	mov    -0x34(%rbp),%edx
     d1c:	8b 45 c8             	mov    -0x38(%rbp),%eax
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d1f:	44 89 f9             	mov    %r15d,%ecx
     d22:	c1 e1 0f             	shl    $0xf,%ecx
				//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
				//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

				TOPMC_CTRL_SET_ACTIVE(val);
				//val = (u64)( low | ((u64)(high) << 32));
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d25:	44 89 f6             	mov    %r14d,%esi
     d28:	89 df                	mov    %ebx,%edi
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d2a:	81 e1 00 00 80 00    	and    $0x800000,%ecx
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}

				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d30:	48 c1 e2 20          	shl    $0x20,%rdx
     d34:	48 09 c2             	or     %rax,%rdx
				val &= MSR_PPRO_EVENTSEL_RESERVED;
     d37:	48 b8 00 00 20 00 ff 	mov    $0xffffffff00200000,%rax
     d3e:	ff ff ff 
     d41:	48 21 c2             	and    %rax,%rdx
				//low = (unsigned int)(val & 0xffffffff);
				//high = (unsigned int)((val & 0xffffffff00000000) >> 32);
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
     d44:	44 89 f8             	mov    %r15d,%eax
     d47:	c1 e8 18             	shr    $0x18,%eax
     d4a:	89 c0                	mov    %eax,%eax
     d4c:	48 0d 00 00 50 00    	or     $0x500000,%rax
				TOPMC_CTRL_SET_KERN(val, kernel);
     d52:	48 09 d0             	or     %rdx,%rax
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     d55:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d58:	41 c1 e7 0e          	shl    $0xe,%r15d
				//low = (unsigned int)(val & 0xffffffff);
				//high = (unsigned int)((val & 0xffffffff00000000) >> 32);
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     d5c:	48 c1 ea 08          	shr    $0x8,%rdx
     d60:	81 e2 00 ff 00 00    	and    $0xff00,%edx
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
     d66:	48 09 d0             	or     %rdx,%rax
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d69:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d6c:	48 09 c1             	or     %rax,%rcx
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                                TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     d6f:	8b 45 b8             	mov    -0x48(%rbp),%eax
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d72:	81 e2 00 00 04 00    	and    $0x40000,%edx
     d78:	48 09 ca             	or     %rcx,%rdx
                                TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     d7b:	c1 e0 10             	shl    $0x10,%eax
     d7e:	48 98                	cltq   
     d80:	48 09 c2             	or     %rax,%rdx
				//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
				//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
				//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

				TOPMC_CTRL_SET_ACTIVE(val);
     d83:	8b 45 b4             	mov    -0x4c(%rbp),%eax
     d86:	c1 e0 11             	shl    $0x11,%eax
     d89:	48 98                	cltq   
     d8b:	48 09 c2             	or     %rax,%rdx
				//val = (u64)( low | ((u64)(high) << 32));
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d8e:	48 89 d1             	mov    %rdx,%rcx
     d91:	48 c1 e9 20          	shr    $0x20,%rcx
     d95:	e8 00 00 00 00       	callq  d9a <topmc_enable_all_write_nehelam+0x17a>
				topmc_procs[cpu][counter].enable        = 1;
     d9a:	41 c7 45 fc 01 00 00 	movl   $0x1,-0x4(%r13)
     da1:	00 
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][counter].enable        = 0;
     da2:	41 83 c4 01          	add    $0x1,%r12d
     da6:	49 83 c5 10          	add    $0x10,%r13
     daa:	41 83 c6 01          	add    $0x1,%r14d
	unsigned long long value;
	u64 val;

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
     dae:	41 81 fc c5 00 00 00 	cmp    $0xc5,%r12d
     db5:	0f 85 ec fe ff ff    	jne    ca7 <topmc_enable_all_write_nehelam+0x87>
     dbb:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
     dbf:	41 be c0 03 00 00    	mov    $0x3c0,%r14d
     dc5:	66 41 bc b0 03       	mov    $0x3b0,%r12w
     dca:	49 c1 e5 09          	shl    $0x9,%r13
     dce:	49 81 c5 00 00 00 00 	add    $0x0,%r13
     dd5:	e9 a0 00 00 00       	jmpq   e7a <topmc_enable_all_write_nehelam+0x25a>
     dda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
				if( topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable == 1) {
     de0:	41 83 7d fc 01       	cmpl   $0x1,-0x4(%r13)
     de5:	0f 84 8e 02 00 00    	je     1079 <topmc_enable_all_write_nehelam+0x459>
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}                                     
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     deb:	31 c9                	xor    %ecx,%ecx
     ded:	31 d2                	xor    %edx,%edx
     def:	44 89 e6             	mov    %r12d,%esi
     df2:	89 df                	mov    %ebx,%edi
     df4:	e8 00 00 00 00       	callq  df9 <topmc_enable_all_write_nehelam+0x1d9>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     df9:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     dfd:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     e01:	44 89 f6             	mov    %r14d,%esi
     e04:	89 df                	mov    %ebx,%edi
     e06:	e8 00 00 00 00       	callq  e0b <topmc_enable_all_write_nehelam+0x1eb>
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e0b:	44 89 f8             	mov    %r15d,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e0e:	4c 89 fa             	mov    %r15,%rdx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e11:	44 89 f9             	mov    %r15d,%ecx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e14:	c1 e8 18             	shr    $0x18,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e17:	48 c1 ea 08          	shr    $0x8,%rdx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e1b:	c1 e1 0f             	shl    $0xf,%ecx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e1e:	89 c0                	mov    %eax,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e20:	81 e2 00 ff 00 00    	and    $0xff00,%edx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);

				TOPMC_CTRL_SET_ACTIVE(val);
     e26:	41 c1 e7 0e          	shl    $0xe,%r15d
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e2a:	48 0d 00 00 50 00    	or     $0x500000,%rax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e30:	81 e1 00 00 80 00    	and    $0x800000,%ecx

				TOPMC_CTRL_SET_ACTIVE(val);
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e36:	44 89 f6             	mov    %r14d,%esi
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     e39:	48 09 d0             	or     %rdx,%rax
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);

				TOPMC_CTRL_SET_ACTIVE(val);
     e3c:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e3f:	89 df                	mov    %ebx,%edi
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e41:	48 09 c1             	or     %rax,%rcx

				TOPMC_CTRL_SET_ACTIVE(val);
     e44:	81 e2 00 00 04 00    	and    $0x40000,%edx
     e4a:	48 09 ca             	or     %rcx,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e4d:	48 89 d1             	mov    %rdx,%rcx
     e50:	48 c1 e9 20          	shr    $0x20,%rcx
     e54:	e8 00 00 00 00       	callq  e59 <topmc_enable_all_write_nehelam+0x239>
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 1;
     e59:	41 c7 45 fc 01 00 00 	movl   $0x1,-0x4(%r13)
     e60:	00 
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 0;
     e61:	41 83 c4 01          	add    $0x1,%r12d
     e65:	49 83 c5 10          	add    $0x10,%r13
     e69:	41 83 c6 01          	add    $0x1,%r14d
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][counter].enable        = 0;
				//                              printk("+->topmc_enable_all_write(): disabled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);                                      
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
     e6d:	41 81 fc b8 03 00 00 	cmp    $0x3b8,%r12d
     e74:	0f 84 e6 fd ff ff    	je     c60 <topmc_enable_all_write_nehelam+0x40>
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
     e7a:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
				topmc_procs[cpu][counter].enable        = 0;
				//                              printk("+->topmc_enable_all_write(): disabled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);                                      
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
     e7e:	45 8b 7d 00          	mov    0x0(%r13),%r15d
			if (enable == '1') {
     e82:	0f 84 58 ff ff ff    	je     de0 <topmc_enable_all_write_nehelam+0x1c0>
				TOPMC_CTRL_SET_ACTIVE(val);
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 1;
			}
			else {
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     e88:	31 c9                	xor    %ecx,%ecx
     e8a:	31 d2                	xor    %edx,%edx
     e8c:	44 89 e6             	mov    %r12d,%esi
     e8f:	89 df                	mov    %ebx,%edi
     e91:	e8 00 00 00 00       	callq  e96 <topmc_enable_all_write_nehelam+0x276>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e96:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     e9a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     e9e:	44 89 f6             	mov    %r14d,%esi
     ea1:	89 df                	mov    %ebx,%edi
     ea3:	e8 00 00 00 00       	callq  ea8 <topmc_enable_all_write_nehelam+0x288>
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     ea8:	31 c9                	xor    %ecx,%ecx
     eaa:	31 d2                	xor    %edx,%edx
     eac:	44 89 f6             	mov    %r14d,%esi
     eaf:	89 df                	mov    %ebx,%edi
     eb1:	e8 00 00 00 00       	callq  eb6 <topmc_enable_all_write_nehelam+0x296>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
     eb6:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     eba:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     ebe:	44 89 e6             	mov    %r12d,%esi
     ec1:	89 df                	mov    %ebx,%edi
     ec3:	e8 00 00 00 00       	callq  ec8 <topmc_enable_all_write_nehelam+0x2a8>
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ec8:	8b 45 c8             	mov    -0x38(%rbp),%eax
     ecb:	8b 55 cc             	mov    -0x34(%rbp),%edx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     ece:	31 c9                	xor    %ecx,%ecx
     ed0:	44 89 e6             	mov    %r12d,%esi
     ed3:	89 df                	mov    %ebx,%edi
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ed5:	48 c1 e0 20          	shl    $0x20,%rax
     ed9:	48 09 d0             	or     %rdx,%rax
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     edc:	31 d2                	xor    %edx,%edx
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ede:	49 89 45 04          	mov    %rax,0x4(%r13)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     ee2:	e8 00 00 00 00       	callq  ee7 <topmc_enable_all_write_nehelam+0x2c7>
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 0;
     ee7:	41 c7 45 fc 00 00 00 	movl   $0x0,-0x4(%r13)
     eee:	00 
     eef:	e9 6d ff ff ff       	jmpq   e61 <topmc_enable_all_write_nehelam+0x241>
     ef4:	0f 1f 40 00          	nopl   0x0(%rax)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				topmc_procs[cpu][counter].enable        = 1;
				//                              printk("+->topmc_enable_all_write(): abled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);
			}
			else{
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     ef8:	31 c9                	xor    %ecx,%ecx
     efa:	31 d2                	xor    %edx,%edx
     efc:	44 89 e6             	mov    %r12d,%esi
     eff:	89 df                	mov    %ebx,%edi
     f01:	e8 00 00 00 00       	callq  f06 <topmc_enable_all_write_nehelam+0x2e6>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f06:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     f0a:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     f0e:	44 89 f6             	mov    %r14d,%esi
     f11:	89 df                	mov    %ebx,%edi
     f13:	e8 00 00 00 00       	callq  f18 <topmc_enable_all_write_nehelam+0x2f8>
     f18:	8b 55 c8             	mov    -0x38(%rbp),%edx
     f1b:	8b 45 cc             	mov    -0x34(%rbp),%eax
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f1e:	44 89 f6             	mov    %r14d,%esi
     f21:	89 df                	mov    %ebx,%edi
				topmc_procs[cpu][counter].enable        = 1;
				//                              printk("+->topmc_enable_all_write(): abled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);
			}
			else{
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f23:	48 c1 e2 20          	shl    $0x20,%rdx
     f27:	48 09 c2             	or     %rax,%rdx
				val &= MSR_PPRO_EVENTSEL_RESERVED;
     f2a:	48 b8 00 00 20 00 ff 	mov    $0xffffffff00200000,%rax
     f31:	ff ff ff 
     f34:	48 21 c2             	and    %rax,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f37:	48 89 d1             	mov    %rdx,%rcx
     f3a:	48 c1 e9 20          	shr    $0x20,%rcx
     f3e:	e8 00 00 00 00       	callq  f43 <topmc_enable_all_write_nehelam+0x323>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
     f43:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     f47:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     f4b:	44 89 e6             	mov    %r12d,%esi
     f4e:	89 df                	mov    %ebx,%edi
     f50:	e8 00 00 00 00       	callq  f55 <topmc_enable_all_write_nehelam+0x335>
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f55:	8b 45 cc             	mov    -0x34(%rbp),%eax
     f58:	8b 55 c8             	mov    -0x38(%rbp),%edx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f5b:	31 c9                	xor    %ecx,%ecx
     f5d:	44 89 e6             	mov    %r12d,%esi
     f60:	89 df                	mov    %ebx,%edi
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f62:	48 c1 e0 20          	shl    $0x20,%rax
     f66:	48 09 d0             	or     %rdx,%rax
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f69:	31 d2                	xor    %edx,%edx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f6b:	49 89 45 04          	mov    %rax,0x4(%r13)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f6f:	e8 00 00 00 00       	callq  f74 <topmc_enable_all_write_nehelam+0x354>
				topmc_procs[cpu][counter].enable        = 0;
     f74:	41 c7 45 fc 00 00 00 	movl   $0x0,-0x4(%r13)
     f7b:	00 
     f7c:	e9 21 fe ff ff       	jmpq   da2 <topmc_enable_all_write_nehelam+0x182>
     f81:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
					user=1;
					break;
				case 2:
					kernel=1;
					user=0;
					break;
     f88:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
     f8f:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				case 3:
					kernel=user=1;
					break;
     f96:	e9 49 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     f9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     fa0:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     fa7:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
					user=1;
					break;
				case 2:
					kernel=1;
					user=0;
					break;
     fae:	e9 31 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     fb3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     fb8:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
     fbf:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     fc6:	e9 19 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     fcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     fd0:	85 f6                	test   %esi,%esi
     fd2:	0f 85 fe fc ff ff    	jne    cd6 <topmc_enable_all_write_nehelam+0xb6>
     fd8:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     fdf:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     fe6:	e9 f9 fc ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
		}
	}


#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     feb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ff2:	e8 00 00 00 00       	callq  ff7 <topmc_enable_all_write_nehelam+0x3d7>
#endif

	if(enable=='1')
     ff7:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
		}
	}


#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     ffb:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1002 <topmc_enable_all_write_nehelam+0x3e2>
#endif

	if(enable=='1')
    1002:	74 60                	je     1064 <topmc_enable_all_write_nehelam+0x444>
#endif

	}
	else
	{
		topmc_all_enabled       = 0;
    1004:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 100e <topmc_enable_all_write_nehelam+0x3ee>
    100b:	00 00 00 

#ifdef TOPMC_PER_SECOND
		clr_topmc_cnt_all(topmc_pmc_cnt_bitmap);
    100e:	66 c7 05 00 00 00 00 	movw   $0x0,0x0(%rip)        # 1017 <topmc_enable_all_write_nehelam+0x3f7>
    1015:	00 00 
    1017:	48 89 c6             	mov    %rax,%rsi
    101a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1021:	e8 00 00 00 00       	callq  1026 <topmc_enable_all_write_nehelam+0x406>

	}

#ifdef TOPMC_PER_SECOND
	spin_unlock_irqrestore(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
	spin_lock_irqsave(&topmc_chg_lock, topmc_pmc_chg_flags);
    1026:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    102d:	e8 00 00 00 00       	callq  1032 <topmc_enable_all_write_nehelam+0x412>
    1032:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1039:	48 89 c6             	mov    %rax,%rsi
    103c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1043 <topmc_enable_all_write_nehelam+0x423>
//	printk("topmc_enable_all_write: before topmc_pmc_chg=%d\n",topmc_pmc_chg);
	topmc_pmc_chg = 1;
    1043:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 104d <topmc_enable_all_write_nehelam+0x42d>
    104a:	00 00 00 
    104d:	e8 00 00 00 00       	callq  1052 <topmc_enable_all_write_nehelam+0x432>
	spin_unlock_irqrestore(&topmc_chg_lock, topmc_pmc_chg_flags);
#endif

out:
	return count;
}
    1052:	8b 45 a0             	mov    -0x60(%rbp),%eax
    1055:	48 83 c4 38          	add    $0x38,%rsp
    1059:	5b                   	pop    %rbx
    105a:	41 5c                	pop    %r12
    105c:	41 5d                	pop    %r13
    105e:	41 5e                	pop    %r14
    1060:	41 5f                	pop    %r15
    1062:	c9                   	leaveq 
    1063:	c3                   	retq   
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
#endif

	if(enable=='1')
	{
		topmc_all_enabled       = 1;
    1064:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 106e <topmc_enable_all_write_nehelam+0x44e>
    106b:	00 00 00 

#ifdef TOPMC_PER_SECOND
		set_topmc_cnt_all(topmc_pmc_cnt_bitmap);
    106e:	66 81 0d 00 00 00 00 	orw    $0xfff,0x0(%rip)        # 1077 <topmc_enable_all_write_nehelam+0x457>
    1075:	ff 0f 
    1077:	eb 9e                	jmp    1017 <topmc_enable_all_write_nehelam+0x3f7>
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
				if( topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable == 1) {
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
    1079:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1080:	31 c0                	xor    %eax,%eax
    1082:	e8 00 00 00 00       	callq  1087 <topmc_enable_all_write_nehelam+0x467>
					goto out;
    1087:	eb c9                	jmp    1052 <topmc_enable_all_write_nehelam+0x432>
    1089:	90                   	nop
    108a:	90                   	nop
    108b:	90                   	nop
    108c:	90                   	nop
    108d:	90                   	nop
    108e:	90                   	nop
    108f:	90                   	nop

0000000000001090 <topmc_msr_init_amd>:

	return 0;
}
// ---------------------------------------------------------------- 
void topmc_msr_init_amd(void)
{
    1090:	55                   	push   %rbp
    1091:	48 89 e5             	mov    %rsp,%rbp
    1094:	41 57                	push   %r15
    1096:	41 56                	push   %r14
    1098:	41 55                	push   %r13
    109a:	41 54                	push   %r12
    109c:	53                   	push   %rbx
    109d:	48 83 ec 28          	sub    $0x28,%rsp
    10a1:	e8 00 00 00 00       	callq  10a6 <topmc_msr_init_amd+0x16>
    10a6:	4c 8b 35 00 00 00 00 	mov    0x0(%rip),%r14        # 10ad <topmc_msr_init_amd+0x1d>
    for_each_online_cpu(cpu) { 
        /* in core section */
        for (counter = 0 ; counter < PMC_NUM; ++counter) {
            //clear the event selectors
            RDMSR(EVNT_SEL0+counter, val, cpu);
            val &=  EVNT_SEL_RESERVED;
    10ad:	48 bb ff 82 ff ff f0 	mov    $0xfffffcf0ffff82ff,%rbx
    10b4:	fc ff ff 
    10b7:	4c 8d 6d c8          	lea    -0x38(%rbp),%r13
    10bb:	4c 8d 65 cc          	lea    -0x34(%rbp),%r12
    10bf:	c7 45 bc ff ff 00 00 	movl   $0xffff,-0x44(%rbp)
    10c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    10cd:	00 00 00 
    10d0:	8b 55 bc             	mov    -0x44(%rbp),%edx
    10d3:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 10da <topmc_msr_init_amd+0x4a>
    10da:	4c 89 f7             	mov    %r14,%rdi
    10dd:	83 c2 01             	add    $0x1,%edx
    10e0:	48 63 d2             	movslq %edx,%rdx
    10e3:	e8 00 00 00 00       	callq  10e8 <topmc_msr_init_amd+0x58>
void topmc_msr_init_amd(void)
{
    unsigned short cpu, counter;
    u64 val;

    for_each_online_cpu(cpu) { 
    10e8:	0f b7 c0             	movzwl %ax,%eax
    10eb:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 10f1 <topmc_msr_init_amd+0x61>
    10f1:	89 45 bc             	mov    %eax,-0x44(%rbp)
    10f4:	7d 5a                	jge    1150 <topmc_msr_init_amd+0xc0>
    10f6:	41 bf 00 00 01 c0    	mov    $0xc0010000,%r15d
        /* in core section */
        for (counter = 0 ; counter < PMC_NUM; ++counter) {
            //clear the event selectors
            RDMSR(EVNT_SEL0+counter, val, cpu);
    10fc:	8b 7d bc             	mov    -0x44(%rbp),%edi
    10ff:	44 89 fe             	mov    %r15d,%esi
    1102:	4c 89 e9             	mov    %r13,%rcx
    1105:	4c 89 e2             	mov    %r12,%rdx
    1108:	e8 00 00 00 00       	callq  110d <topmc_msr_init_amd+0x7d>
    110d:	8b 55 c8             	mov    -0x38(%rbp),%edx
    1110:	8b 45 cc             	mov    -0x34(%rbp),%eax
            val &=  EVNT_SEL_RESERVED;
            WRMSR(EVNT_SEL0+counter, val, cpu);
    1113:	44 89 fe             	mov    %r15d,%esi
    1116:	8b 7d bc             	mov    -0x44(%rbp),%edi

    for_each_online_cpu(cpu) { 
        /* in core section */
        for (counter = 0 ; counter < PMC_NUM; ++counter) {
            //clear the event selectors
            RDMSR(EVNT_SEL0+counter, val, cpu);
    1119:	48 c1 e2 20          	shl    $0x20,%rdx
    111d:	48 09 c2             	or     %rax,%rdx
            val &=  EVNT_SEL_RESERVED;
    1120:	48 21 da             	and    %rbx,%rdx
            WRMSR(EVNT_SEL0+counter, val, cpu);
    1123:	48 89 d1             	mov    %rdx,%rcx
    1126:	48 c1 e9 20          	shr    $0x20,%rcx
    112a:	e8 00 00 00 00       	callq  112f <topmc_msr_init_amd+0x9f>

            // clear the counter
            WRMSR(PMC0+counter, 0LL, cpu);
    112f:	8b 7d bc             	mov    -0x44(%rbp),%edi
    1132:	41 8d 77 04          	lea    0x4(%r15),%esi
    1136:	31 c9                	xor    %ecx,%ecx
    1138:	31 d2                	xor    %edx,%edx
    113a:	41 83 c7 01          	add    $0x1,%r15d
    113e:	e8 00 00 00 00       	callq  1143 <topmc_msr_init_amd+0xb3>
    unsigned short cpu, counter;
    u64 val;

    for_each_online_cpu(cpu) { 
        /* in core section */
        for (counter = 0 ; counter < PMC_NUM; ++counter) {
    1143:	41 81 ff 04 00 01 c0 	cmp    $0xc0010004,%r15d
    114a:	75 b0                	jne    10fc <topmc_msr_init_amd+0x6c>
    114c:	eb 82                	jmp    10d0 <topmc_msr_init_amd+0x40>
    114e:	66 90                	xchg   %ax,%ax

            // clear the counter
            WRMSR(PMC0+counter, 0LL, cpu);
        } 
    }       
}               
    1150:	48 83 c4 28          	add    $0x28,%rsp
    1154:	5b                   	pop    %rbx
    1155:	41 5c                	pop    %r12
    1157:	41 5d                	pop    %r13
    1159:	41 5e                	pop    %r14
    115b:	41 5f                	pop    %r15
    115d:	c9                   	leaveq 
    115e:	c3                   	retq   
    115f:	90                   	nop

0000000000001160 <topmc_value_write_amd>:

    return count;
}       

int topmc_value_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    1160:	55                   	push   %rbp
    1161:	48 89 e5             	mov    %rsp,%rbp
    1164:	48 83 ec 50          	sub    $0x50,%rsp
    1168:	48 89 5d e8          	mov    %rbx,-0x18(%rbp)
    116c:	4c 89 65 f0          	mov    %r12,-0x10(%rbp)
    1170:	4c 89 6d f8          	mov    %r13,-0x8(%rbp)
    1174:	e8 00 00 00 00       	callq  1179 <topmc_value_write_amd+0x19>
    1179:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1180:	00 00 
    1182:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    1186:	31 c0                	xor    %eax,%eax
	long ret;

	char str[20];
	u64 val;

	topmc_split32to16(mix, &cpu, &counter);
    1188:	8b 39                	mov    (%rcx),%edi

    return count;
}       

int topmc_value_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    118a:	49 89 f5             	mov    %rsi,%r13
    118d:	48 89 d3             	mov    %rdx,%rbx
	long ret;

	char str[20];
	u64 val;

	topmc_split32to16(mix, &cpu, &counter);
    1190:	48 8d 75 be          	lea    -0x42(%rbp),%rsi
    1194:	48 8d 55 bc          	lea    -0x44(%rbp),%rdx

	//    copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
    1198:	4c 8d 65 c0          	lea    -0x40(%rbp),%r12
	long ret;

	char str[20];
	u64 val;

	topmc_split32to16(mix, &cpu, &counter);
    119c:	e8 00 00 00 00       	callq  11a1 <topmc_value_write_amd+0x41>

	//    copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
    11a1:	48 89 da             	mov    %rbx,%rdx
    11a4:	4c 89 ee             	mov    %r13,%rsi
    11a7:	4c 89 e7             	mov    %r12,%rdi
    11aa:	e8 00 00 00 00       	callq  11af <topmc_value_write_amd+0x4f>
	if(ret < 0)
    11af:	48 85 c0             	test   %rax,%rax
    11b2:	b9 f2 ff ff ff       	mov    $0xfffffff2,%ecx
    11b7:	79 27                	jns    11e0 <topmc_value_write_amd+0x80>
	if(topmc_procs[cpu][counter].enable == 0) {
		WRMSR(PMC0 + counter, val, cpu);
	}

	return 0;
}
    11b9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
    11bd:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
    11c4:	00 00 
    11c6:	89 c8                	mov    %ecx,%eax
    11c8:	75 79                	jne    1243 <topmc_value_write_amd+0xe3>
    11ca:	48 8b 5d e8          	mov    -0x18(%rbp),%rbx
    11ce:	4c 8b 65 f0          	mov    -0x10(%rbp),%r12
    11d2:	4c 8b 6d f8          	mov    -0x8(%rbp),%r13
    11d6:	c9                   	leaveq 
    11d7:	c3                   	retq   
    11d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    11df:	00 

	//    copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
	if(ret < 0)
		return -EFAULT;
	if(ret == 0 || ret > count)
    11e0:	48 39 d8             	cmp    %rbx,%rax
    11e3:	76 0b                	jbe    11f0 <topmc_value_write_amd+0x90>
    11e5:	b9 ea ff ff ff       	mov    $0xffffffea,%ecx
    11ea:	eb cd                	jmp    11b9 <topmc_value_write_amd+0x59>
    11ec:	0f 1f 40 00          	nopl   0x0(%rax)
    11f0:	48 85 c0             	test   %rax,%rax
    11f3:	74 f0                	je     11e5 <topmc_value_write_amd+0x85>
		return -EINVAL;
	val = topmc_str2int(str, 6, 20);
    11f5:	ba 14 00 00 00       	mov    $0x14,%edx
    11fa:	4c 89 e7             	mov    %r12,%rdi
    11fd:	be 06 00 00 00       	mov    $0x6,%esi
    1202:	e8 00 00 00 00       	callq  1207 <topmc_value_write_amd+0xa7>
	if(topmc_procs[cpu][counter].enable == 0) {
    1207:	0f b7 7d be          	movzwl -0x42(%rbp),%edi
    120b:	0f b7 5d bc          	movzwl -0x44(%rbp),%ebx
	ret = strncpy_from_user(str, buffer, count);
	if(ret < 0)
		return -EFAULT;
	if(ret == 0 || ret > count)
		return -EINVAL;
	val = topmc_str2int(str, 6, 20);
    120f:	89 c2                	mov    %eax,%edx
	if(topmc_procs[cpu][counter].enable == 0) {
    1211:	48 63 c7             	movslq %edi,%rax
    1214:	0f b7 cb             	movzwl %bx,%ecx
    1217:	48 c1 e0 05          	shl    $0x5,%rax
    121b:	48 01 c8             	add    %rcx,%rax
    121e:	31 c9                	xor    %ecx,%ecx
    1220:	48 c1 e0 04          	shl    $0x4,%rax
    1224:	8b 80 00 00 00 00    	mov    0x0(%rax),%eax
    122a:	85 c0                	test   %eax,%eax
    122c:	75 8b                	jne    11b9 <topmc_value_write_amd+0x59>
		WRMSR(PMC0 + counter, val, cpu);
    122e:	0f b7 db             	movzwl %bx,%ebx
    1231:	8d b3 04 00 01 c0    	lea    -0x3ffefffc(%rbx),%esi
    1237:	e8 00 00 00 00       	callq  123c <topmc_value_write_amd+0xdc>
    123c:	31 c9                	xor    %ecx,%ecx
    123e:	e9 76 ff ff ff       	jmpq   11b9 <topmc_value_write_amd+0x59>
	}

	return 0;
}
    1243:	e8 00 00 00 00       	callq  1248 <topmc_value_write_amd+0xe8>
    1248:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    124f:	00 

0000000000001250 <topmc_value_read_amd>:
	return count;
} 

// -----------------------------------------------------------------
int topmc_value_read_amd(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    1250:	55                   	push   %rbp
    1251:	48 89 e5             	mov    %rsp,%rbp
    1254:	53                   	push   %rbx
    1255:	48 83 ec 18          	sub    $0x18,%rsp
    1259:	e8 00 00 00 00       	callq  125e <topmc_value_read_amd+0xe>
    125e:	48 89 fb             	mov    %rdi,%rbx
    unsigned int mix = *(unsigned int *)data;
    unsigned short cpu, counter;

    u64 val;

    topmc_split32to16(mix, &cpu, &counter);
    1261:	41 8b 39             	mov    (%r9),%edi
    1264:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
    1268:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
    126c:	e8 00 00 00 00       	callq  1271 <topmc_value_read_amd+0x21>

    if(topmc_procs[cpu][counter].enable == 1) {
    1271:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
    1275:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
    1279:	48 63 c7             	movslq %edi,%rax
    127c:	0f b7 d6             	movzwl %si,%edx
    127f:	48 c1 e0 05          	shl    $0x5,%rax
    1283:	48 01 d0             	add    %rdx,%rax
    1286:	48 c1 e0 04          	shl    $0x4,%rax
    128a:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
    1291:	74 1d                	je     12b0 <topmc_value_read_amd+0x60>
        RDMSR(PMC0 + counter, val, cpu);
        count = sprintf(page, "%llu\n", val);
    } else {  
        count = sprintf(page, "%llu\n", 0LLU);
    1293:	48 89 df             	mov    %rbx,%rdi
    1296:	31 d2                	xor    %edx,%edx
    1298:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    129f:	31 c0                	xor    %eax,%eax
    12a1:	e8 00 00 00 00       	callq  12a6 <topmc_value_read_amd+0x56>
    }

    return count;
}       
    12a6:	48 83 c4 18          	add    $0x18,%rsp
    12aa:	5b                   	pop    %rbx
    12ab:	c9                   	leaveq 
    12ac:	c3                   	retq   
    12ad:	0f 1f 00             	nopl   (%rax)
    u64 val;

    topmc_split32to16(mix, &cpu, &counter);

    if(topmc_procs[cpu][counter].enable == 1) {
        RDMSR(PMC0 + counter, val, cpu);
    12b0:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
    12b4:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
    12b8:	0f b7 f6             	movzwl %si,%esi
    12bb:	81 ee fc ff fe 3f    	sub    $0x3ffefffc,%esi
    12c1:	e8 00 00 00 00       	callq  12c6 <topmc_value_read_amd+0x76>
        count = sprintf(page, "%llu\n", val);
    12c6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
    12c9:	8b 45 e8             	mov    -0x18(%rbp),%eax
    12cc:	48 89 df             	mov    %rbx,%rdi
    12cf:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    12d6:	48 c1 e2 20          	shl    $0x20,%rdx
    12da:	48 09 c2             	or     %rax,%rdx
    12dd:	31 c0                	xor    %eax,%eax
    12df:	e8 00 00 00 00       	callq  12e4 <topmc_value_read_amd+0x94>
    } else {  
        count = sprintf(page, "%llu\n", 0LLU);
    }

    return count;
}       
    12e4:	48 83 c4 18          	add    $0x18,%rsp
    12e8:	5b                   	pop    %rbx
    12e9:	c9                   	leaveq 
    12ea:	c3                   	retq   
    12eb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000012f0 <topmc_event_write_amd>:
 * '--' stands for unit mask
 * '#' stands for usr/kernel:0-nothing,1-user,2-kernel,3-user and kernel
 * Example: '041ff1'
 */
int topmc_event_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    12f0:	55                   	push   %rbp
    12f1:	48 89 e5             	mov    %rsp,%rbp
    12f4:	48 83 ec 40          	sub    $0x40,%rsp
    12f8:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
    12fc:	4c 89 65 e8          	mov    %r12,-0x18(%rbp)
    1300:	4c 89 6d f0          	mov    %r13,-0x10(%rbp)
    1304:	4c 89 75 f8          	mov    %r14,-0x8(%rbp)
    1308:	e8 00 00 00 00       	callq  130d <topmc_event_write_amd+0x1d>
	char str[6];
	int event;
	int kernel = 0, user = 0;
	u64 val = 0;                

	topmc_split32to16(mix, &cpu, &counter);
    130d:	8b 39                	mov    (%rcx),%edi
 * '--' stands for unit mask
 * '#' stands for usr/kernel:0-nothing,1-user,2-kernel,3-user and kernel
 * Example: '041ff1'
 */
int topmc_event_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    130f:	49 89 f4             	mov    %rsi,%r12
    1312:	48 89 d3             	mov    %rdx,%rbx
	char str[6];
	int event;
	int kernel = 0, user = 0;
	u64 val = 0;                

	topmc_split32to16(mix, &cpu, &counter);
    1315:	48 8d 75 de          	lea    -0x22(%rbp),%rsi
    1319:	48 8d 55 dc          	lea    -0x24(%rbp),%rdx
	printk("event write (before) ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);

	//copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
    131d:	4c 8d 6d c0          	lea    -0x40(%rbp),%r13
	char str[6];
	int event;
	int kernel = 0, user = 0;
	u64 val = 0;                

	topmc_split32to16(mix, &cpu, &counter);
    1321:	e8 00 00 00 00       	callq  1326 <topmc_event_write_amd+0x36>
	printk("event write (before) ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);
    1326:	0f b7 75 de          	movzwl -0x22(%rbp),%esi
    132a:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
    132e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1335:	48 63 c6             	movslq %esi,%rax
    1338:	48 63 ca             	movslq %edx,%rcx
    133b:	48 c1 e0 05          	shl    $0x5,%rax
    133f:	48 01 c8             	add    %rcx,%rax
    1342:	48 c1 e0 04          	shl    $0x4,%rax
    1346:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    134c:	31 c0                	xor    %eax,%eax
    134e:	e8 00 00 00 00       	callq  1353 <topmc_event_write_amd+0x63>

	//copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
    1353:	48 89 da             	mov    %rbx,%rdx
    1356:	4c 89 e6             	mov    %r12,%rsi
    1359:	4c 89 ef             	mov    %r13,%rdi
    135c:	e8 00 00 00 00       	callq  1361 <topmc_event_write_amd+0x71>
    1361:	48 89 c2             	mov    %rax,%rdx
	if(ret <0) 
    1364:	b8 f2 ff ff ff       	mov    $0xfffffff2,%eax
    1369:	48 85 d2             	test   %rdx,%rdx
    136c:	79 12                	jns    1380 <topmc_event_write_amd+0x90>

	WRMSR(PMC0+counter, 0LL, cpu);
	printk("event write (after)  ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);

	return count;
} 
    136e:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
    1372:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
    1376:	4c 8b 6d f0          	mov    -0x10(%rbp),%r13
    137a:	4c 8b 75 f8          	mov    -0x8(%rbp),%r14
    137e:	c9                   	leaveq 
    137f:	c3                   	retq   

	//copy_from_user(str, buffer, count);
	ret = strncpy_from_user(str, buffer, count);
	if(ret <0) 
		return -EFAULT;
	if(ret ==0 || ret > count)
    1380:	48 39 da             	cmp    %rbx,%rdx
    1383:	76 07                	jbe    138c <topmc_event_write_amd+0x9c>
    1385:	b8 ea ff ff ff       	mov    $0xffffffea,%eax
    138a:	eb e2                	jmp    136e <topmc_event_write_amd+0x7e>
    138c:	48 85 d2             	test   %rdx,%rdx
    138f:	74 f4                	je     1385 <topmc_event_write_amd+0x95>
		return -EINVAL;

	event = topmc_str2int(str, 6, 16);
    1391:	ba 10 00 00 00       	mov    $0x10,%edx
    1396:	be 06 00 00 00       	mov    $0x6,%esi
    139b:	4c 89 ef             	mov    %r13,%rdi
    139e:	e8 00 00 00 00       	callq  13a3 <topmc_event_write_amd+0xb3>
	topmc_procs[cpu][counter].event = event;
    13a3:	0f b7 7d de          	movzwl -0x22(%rbp),%edi
    13a7:	0f b7 75 dc          	movzwl -0x24(%rbp),%esi
	if(ret <0) 
		return -EFAULT;
	if(ret ==0 || ret > count)
		return -EINVAL;

	event = topmc_str2int(str, 6, 16);
    13ab:	41 89 c4             	mov    %eax,%r12d
	topmc_procs[cpu][counter].event = event;
    13ae:	48 63 c7             	movslq %edi,%rax
    13b1:	0f b7 d6             	movzwl %si,%edx
    13b4:	48 c1 e0 05          	shl    $0x5,%rax
    13b8:	48 01 d0             	add    %rdx,%rax
    13bb:	48 c1 e0 04          	shl    $0x4,%rax
    13bf:	44 89 a0 00 00 00 00 	mov    %r12d,0x0(%rax)

	switch(event & 0x00000f) {
    13c6:	44 89 e0             	mov    %r12d,%eax
    13c9:	83 e0 0f             	and    $0xf,%eax
    13cc:	83 f8 01             	cmp    $0x1,%eax
    13cf:	0f 84 ef 00 00 00    	je     14c4 <topmc_event_write_amd+0x1d4>
    13d5:	0f 8e 16 01 00 00    	jle    14f1 <topmc_event_write_amd+0x201>
    13db:	83 f8 02             	cmp    $0x2,%eax
    13de:	0f 84 ff 00 00 00    	je     14e3 <topmc_event_write_amd+0x1f3>
    13e4:	83 f8 03             	cmp    $0x3,%eax
    13e7:	0f 84 e5 00 00 00    	je     14d2 <topmc_event_write_amd+0x1e2>
		case 2: 
			kernel = 1; user = 0; break;
		case 3: 
			kernel = 1; user = 1; break;
		default: 
			printk("+->topmc_enable_write(): kernel_user error!\n"); break;
    13ed:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    13f4:	31 c0                	xor    %eax,%eax
    13f6:	e8 00 00 00 00       	callq  13fb <topmc_event_write_amd+0x10b>
    13fb:	0f b7 75 dc          	movzwl -0x24(%rbp),%esi
    13ff:	0f b7 7d de          	movzwl -0x22(%rbp),%edi
    1403:	45 31 ed             	xor    %r13d,%r13d
    1406:	45 31 f6             	xor    %r14d,%r14d
	}
	RDMSR(EVNT_SEL0+counter, val, cpu);
    1409:	48 8d 4d d4          	lea    -0x2c(%rbp),%rcx
    140d:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
    1411:	0f b7 f6             	movzwl %si,%esi
    1414:	81 ee 00 00 ff 3f    	sub    $0x3fff0000,%esi
    141a:	e8 00 00 00 00       	callq  141f <topmc_event_write_amd+0x12f>
    141f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
    1422:	8b 55 d8             	mov    -0x28(%rbp),%edx
	val &=  EVNT_SEL_RESERVED;
	SET_USR(val, user);
    1425:	4c 89 e1             	mov    %r12,%rcx
    1428:	48 c1 e9 0c          	shr    $0xc,%rcx
	SET_KERN(val, kernel);
	SET_UNIT_MASK(val, event);
	SET_EVENT_SELECT(val, event);
	WRMSR(EVNT_SEL0+counter, val, cpu);
    142c:	0f b7 75 dc          	movzwl -0x24(%rbp),%esi
    1430:	0f b7 7d de          	movzwl -0x22(%rbp),%edi
		default: 
			printk("+->topmc_enable_write(): kernel_user error!\n"); break;
	}
	RDMSR(EVNT_SEL0+counter, val, cpu);
	val &=  EVNT_SEL_RESERVED;
	SET_USR(val, user);
    1434:	81 e1 ff 00 00 00    	and    $0xff,%ecx
		case 3: 
			kernel = 1; user = 1; break;
		default: 
			printk("+->topmc_enable_write(): kernel_user error!\n"); break;
	}
	RDMSR(EVNT_SEL0+counter, val, cpu);
    143a:	48 c1 e0 20          	shl    $0x20,%rax
    143e:	48 09 d0             	or     %rdx,%rax
	val &=  EVNT_SEL_RESERVED;
    1441:	48 ba ff 82 ff ff f0 	mov    $0xfffffcf0ffff82ff,%rdx
    1448:	fc ff ff 
	SET_USR(val, user);
	SET_KERN(val, kernel);
	SET_UNIT_MASK(val, event);
	SET_EVENT_SELECT(val, event);
	WRMSR(EVNT_SEL0+counter, val, cpu);
    144b:	81 ee 00 00 ff 3f    	sub    $0x3fff0000,%esi
			kernel = 1; user = 1; break;
		default: 
			printk("+->topmc_enable_write(): kernel_user error!\n"); break;
	}
	RDMSR(EVNT_SEL0+counter, val, cpu);
	val &=  EVNT_SEL_RESERVED;
    1451:	48 21 d0             	and    %rdx,%rax
	SET_USR(val, user);
    1454:	4c 89 e2             	mov    %r12,%rdx
    1457:	48 c1 e2 04          	shl    $0x4,%rdx
    145b:	81 e2 00 ff 00 00    	and    $0xff00,%edx
    1461:	48 09 ca             	or     %rcx,%rdx
	SET_KERN(val, kernel);
    1464:	48 09 c2             	or     %rax,%rdx
	SET_UNIT_MASK(val, event);
    1467:	4c 09 f2             	or     %r14,%rdx
	SET_EVENT_SELECT(val, event);
    146a:	4c 09 ea             	or     %r13,%rdx
	WRMSR(EVNT_SEL0+counter, val, cpu);
    146d:	48 89 d1             	mov    %rdx,%rcx
    1470:	48 c1 e9 20          	shr    $0x20,%rcx
    1474:	e8 00 00 00 00       	callq  1479 <topmc_event_write_amd+0x189>

	WRMSR(PMC0+counter, 0LL, cpu);
    1479:	0f b7 75 dc          	movzwl -0x24(%rbp),%esi
    147d:	0f b7 7d de          	movzwl -0x22(%rbp),%edi
    1481:	31 c9                	xor    %ecx,%ecx
    1483:	31 d2                	xor    %edx,%edx
    1485:	81 ee fc ff fe 3f    	sub    $0x3ffefffc,%esi
    148b:	e8 00 00 00 00       	callq  1490 <topmc_event_write_amd+0x1a0>
	printk("event write (after)  ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);
    1490:	0f b7 75 de          	movzwl -0x22(%rbp),%esi
    1494:	0f b7 55 dc          	movzwl -0x24(%rbp),%edx
    1498:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    149f:	48 63 c6             	movslq %esi,%rax
    14a2:	48 63 ca             	movslq %edx,%rcx
    14a5:	48 c1 e0 05          	shl    $0x5,%rax
    14a9:	48 01 c8             	add    %rcx,%rax
    14ac:	48 c1 e0 04          	shl    $0x4,%rax
    14b0:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    14b6:	31 c0                	xor    %eax,%eax
    14b8:	e8 00 00 00 00       	callq  14bd <topmc_event_write_amd+0x1cd>

	return count;
    14bd:	89 d8                	mov    %ebx,%eax
    14bf:	e9 aa fe ff ff       	jmpq   136e <topmc_event_write_amd+0x7e>
		return -EINVAL;

	event = topmc_str2int(str, 6, 16);
	topmc_procs[cpu][counter].event = event;

	switch(event & 0x00000f) {
    14c4:	45 31 ed             	xor    %r13d,%r13d
    14c7:	41 be 00 00 01 00    	mov    $0x10000,%r14d
    14cd:	e9 37 ff ff ff       	jmpq   1409 <topmc_event_write_amd+0x119>
		case 0: 
			kernel = 0; user = 0; break;
		case 1: 
			kernel = 0; user = 1; break;
		case 2: 
			kernel = 1; user = 0; break;
    14d2:	41 bd 00 00 02 00    	mov    $0x20000,%r13d
    14d8:	41 be 00 00 01 00    	mov    $0x10000,%r14d
		case 3: 
			kernel = 1; user = 1; break;
    14de:	e9 26 ff ff ff       	jmpq   1409 <topmc_event_write_amd+0x119>
		return -EINVAL;

	event = topmc_str2int(str, 6, 16);
	topmc_procs[cpu][counter].event = event;

	switch(event & 0x00000f) {
    14e3:	41 bd 00 00 02 00    	mov    $0x20000,%r13d
    14e9:	45 31 f6             	xor    %r14d,%r14d
		case 0: 
			kernel = 0; user = 0; break;
		case 1: 
			kernel = 0; user = 1; break;
		case 2: 
			kernel = 1; user = 0; break;
    14ec:	e9 18 ff ff ff       	jmpq   1409 <topmc_event_write_amd+0x119>
		return -EINVAL;

	event = topmc_str2int(str, 6, 16);
	topmc_procs[cpu][counter].event = event;

	switch(event & 0x00000f) {
    14f1:	85 c0                	test   %eax,%eax
    14f3:	0f 84 0a ff ff ff    	je     1403 <topmc_event_write_amd+0x113>
    14f9:	e9 ef fe ff ff       	jmpq   13ed <topmc_event_write_amd+0xfd>
    14fe:	66 90                	xchg   %ax,%ax

0000000000001500 <topmc_event_read_amd>:
    return count;
}

// -----------------------------------------------------------------
int topmc_event_read_amd(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    1500:	55                   	push   %rbp
    1501:	48 89 e5             	mov    %rsp,%rbp
    1504:	53                   	push   %rbx
    1505:	48 83 ec 18          	sub    $0x18,%rsp
    1509:	e8 00 00 00 00       	callq  150e <topmc_event_read_amd+0xe>
    150e:	48 89 fb             	mov    %rdi,%rbx
    unsigned int mix = *(unsigned int *)data;
    unsigned short cpu, counter;

    topmc_split32to16(mix, &cpu, &counter);
    1511:	41 8b 39             	mov    (%r9),%edi
    1514:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
    1518:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
    151c:	e8 00 00 00 00       	callq  1521 <topmc_event_read_amd+0x21>
    count = sprintf(page, "0x%08x\n", topmc_procs[cpu][counter].event);
    1521:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
    1525:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    1529:	48 89 df             	mov    %rbx,%rdi
    152c:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1533:	48 c1 e0 05          	shl    $0x5,%rax
    1537:	48 01 d0             	add    %rdx,%rax
    153a:	48 c1 e0 04          	shl    $0x4,%rax
    153e:	8b 90 00 00 00 00    	mov    0x0(%rax),%edx
    1544:	31 c0                	xor    %eax,%eax
    1546:	e8 00 00 00 00       	callq  154b <topmc_event_read_amd+0x4b>
    printk("event read ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);
    154b:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
    154f:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
{
    unsigned int mix = *(unsigned int *)data;
    unsigned short cpu, counter;

    topmc_split32to16(mix, &cpu, &counter);
    count = sprintf(page, "0x%08x\n", topmc_procs[cpu][counter].event);
    1553:	89 c3                	mov    %eax,%ebx
    printk("event read ==> cpu %d, counter %d : 0x%06x\n", cpu, counter, topmc_procs[cpu][counter].event);
    1555:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    155c:	48 63 c6             	movslq %esi,%rax
    155f:	48 63 ca             	movslq %edx,%rcx
    1562:	48 c1 e0 05          	shl    $0x5,%rax
    1566:	48 01 c8             	add    %rcx,%rax
    1569:	48 c1 e0 04          	shl    $0x4,%rax
    156d:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    1573:	31 c0                	xor    %eax,%eax
    1575:	e8 00 00 00 00       	callq  157a <topmc_event_read_amd+0x7a>

    return count;
}
    157a:	89 d8                	mov    %ebx,%eax
    157c:	48 83 c4 18          	add    $0x18,%rsp
    1580:	5b                   	pop    %rbx
    1581:	c9                   	leaveq 
    1582:	c3                   	retq   
    1583:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    158a:	84 00 00 00 00 00 

0000000000001590 <topmc_enable_write_amd>:

    return count;
} 

int topmc_enable_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    1590:	55                   	push   %rbp
    1591:	48 89 e5             	mov    %rsp,%rbp
    1594:	41 54                	push   %r12
    1596:	53                   	push   %rbx
    1597:	48 83 ec 10          	sub    $0x10,%rsp
    159b:	e8 00 00 00 00       	callq  15a0 <topmc_enable_write_amd+0x10>
    unsigned short cpu, counter;

    char enable;
    u64 val = 0;

    topmc_split32to16(mix, &cpu, &counter);
    15a0:	8b 39                	mov    (%rcx),%edi

    return count;
} 

int topmc_enable_write_amd(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    15a2:	48 89 f3             	mov    %rsi,%rbx
    15a5:	49 89 d4             	mov    %rdx,%r12
    unsigned short cpu, counter;

    char enable;
    u64 val = 0;

    topmc_split32to16(mix, &cpu, &counter);
    15a8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
    15ac:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
    15b0:	e8 00 00 00 00       	callq  15b5 <topmc_enable_write_amd+0x25>

    printk("enable write before ==> cpu %d, counter %d : %u\n", cpu, counter, topmc_procs[cpu][counter].enable);
    15b5:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
    15b9:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    15bd:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    15c4:	48 63 c6             	movslq %esi,%rax
    15c7:	48 63 ca             	movslq %edx,%rcx
    15ca:	48 c1 e0 05          	shl    $0x5,%rax
    15ce:	48 01 c8             	add    %rcx,%rax
    15d1:	48 c1 e0 04          	shl    $0x4,%rax
    15d5:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    15db:	31 c0                	xor    %eax,%eax
    15dd:	e8 00 00 00 00       	callq  15e2 <topmc_enable_write_amd+0x52>

    get_user(enable, buffer);
    15e2:	48 89 d8             	mov    %rbx,%rax
    15e5:	e8 00 00 00 00       	callq  15ea <topmc_enable_write_amd+0x5a>

    RDMSR(EVNT_SEL0+counter, val, cpu);
    15ea:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
    15ee:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi

    topmc_split32to16(mix, &cpu, &counter);

    printk("enable write before ==> cpu %d, counter %d : %u\n", cpu, counter, topmc_procs[cpu][counter].enable);

    get_user(enable, buffer);
    15f2:	48 89 d3             	mov    %rdx,%rbx

    RDMSR(EVNT_SEL0+counter, val, cpu);
    15f5:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
    15f9:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
    15fd:	81 ee 00 00 ff 3f    	sub    $0x3fff0000,%esi
    1603:	e8 00 00 00 00       	callq  1608 <topmc_enable_write_amd+0x78>
    1608:	8b 55 e4             	mov    -0x1c(%rbp),%edx
    160b:	8b 45 e8             	mov    -0x18(%rbp),%eax
    160e:	48 c1 e2 20          	shl    $0x20,%rdx
    1612:	48 09 c2             	or     %rax,%rdx
    if(enable == '1') {
    1615:	80 fb 31             	cmp    $0x31,%bl
    1618:	74 7e                	je     1698 <topmc_enable_write_amd+0x108>
        topmc_procs[cpu][counter].enable = 1;
        SET_ENABLE(val);
    } else {
        topmc_procs[cpu][counter].enable = 0;
    161a:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
    161e:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
        SET_DISABLE(val);
    1622:	48 81 e2 ff ff bf ff 	and    $0xffffffffffbfffff,%rdx
    RDMSR(EVNT_SEL0+counter, val, cpu);
    if(enable == '1') {
        topmc_procs[cpu][counter].enable = 1;
        SET_ENABLE(val);
    } else {
        topmc_procs[cpu][counter].enable = 0;
    1629:	48 63 c7             	movslq %edi,%rax
    162c:	0f b7 ce             	movzwl %si,%ecx
    162f:	48 c1 e0 05          	shl    $0x5,%rax
    1633:	48 01 c8             	add    %rcx,%rax
    1636:	48 c1 e0 04          	shl    $0x4,%rax
    163a:	c7 80 00 00 00 00 00 	movl   $0x0,0x0(%rax)
    1641:	00 00 00 
        SET_DISABLE(val);
    }
    WRMSR(EVNT_SEL0+counter, val, cpu);
    1644:	48 89 d1             	mov    %rdx,%rcx
    1647:	0f b7 f6             	movzwl %si,%esi
    164a:	48 c1 e9 20          	shr    $0x20,%rcx
    164e:	81 ee 00 00 ff 3f    	sub    $0x3fff0000,%esi
    1654:	e8 00 00 00 00       	callq  1659 <topmc_enable_write_amd+0xc9>

    printk("enable write after  ==> cpu %d, counter %d : %u\n", cpu, counter, topmc_procs[cpu][counter].enable);
    1659:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
    165d:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    1661:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1668:	48 63 c6             	movslq %esi,%rax
    166b:	48 63 ca             	movslq %edx,%rcx
    166e:	48 c1 e0 05          	shl    $0x5,%rax
    1672:	48 01 c8             	add    %rcx,%rax
    1675:	48 c1 e0 04          	shl    $0x4,%rax
    1679:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    167f:	31 c0                	xor    %eax,%eax
    1681:	e8 00 00 00 00       	callq  1686 <topmc_enable_write_amd+0xf6>
    return count;
}
    1686:	48 83 c4 10          	add    $0x10,%rsp
    168a:	44 89 e0             	mov    %r12d,%eax
    168d:	5b                   	pop    %rbx
    168e:	41 5c                	pop    %r12
    1690:	c9                   	leaveq 
    1691:	c3                   	retq   
    1692:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

    get_user(enable, buffer);

    RDMSR(EVNT_SEL0+counter, val, cpu);
    if(enable == '1') {
        topmc_procs[cpu][counter].enable = 1;
    1698:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
    169c:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
        SET_ENABLE(val);
    16a0:	48 81 ca 00 00 40 00 	or     $0x400000,%rdx

    get_user(enable, buffer);

    RDMSR(EVNT_SEL0+counter, val, cpu);
    if(enable == '1') {
        topmc_procs[cpu][counter].enable = 1;
    16a7:	48 63 c7             	movslq %edi,%rax
    16aa:	0f b7 ce             	movzwl %si,%ecx
    16ad:	48 c1 e0 05          	shl    $0x5,%rax
    16b1:	48 01 c8             	add    %rcx,%rax
    16b4:	48 c1 e0 04          	shl    $0x4,%rax
    16b8:	c7 80 00 00 00 00 01 	movl   $0x1,0x0(%rax)
    16bf:	00 00 00 
    16c2:	eb 80                	jmp    1644 <topmc_enable_write_amd+0xb4>
    16c4:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    16cb:	00 00 00 00 00 

00000000000016d0 <topmc_enable_read_amd>:

extern struct topmc_proc_entry topmc_procs[NR_CPUS][TOPMC_MAX_COUNTER];

// -----------------------------------------------------------------
int topmc_enable_read_amd(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    16d0:	55                   	push   %rbp
    16d1:	48 89 e5             	mov    %rsp,%rbp
    16d4:	53                   	push   %rbx
    16d5:	48 83 ec 18          	sub    $0x18,%rsp
    16d9:	e8 00 00 00 00       	callq  16de <topmc_enable_read_amd+0xe>
    16de:	48 89 fb             	mov    %rdi,%rbx
    unsigned int mix = *(unsigned int *)data;
    unsigned short cpu, counter;

    topmc_split32to16(mix, &cpu, &counter);
    16e1:	41 8b 39             	mov    (%r9),%edi
    16e4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
    16e8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
    16ec:	e8 00 00 00 00       	callq  16f1 <topmc_enable_read_amd+0x21>
    count = sprintf(page, "%u\n", topmc_procs[cpu][counter].enable);
    16f1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
    16f5:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
    16f9:	48 89 df             	mov    %rbx,%rdi
    16fc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1703:	48 c1 e0 05          	shl    $0x5,%rax
    1707:	48 01 d0             	add    %rdx,%rax
    170a:	48 c1 e0 04          	shl    $0x4,%rax
    170e:	8b 90 00 00 00 00    	mov    0x0(%rax),%edx
    1714:	31 c0                	xor    %eax,%eax
    1716:	e8 00 00 00 00       	callq  171b <topmc_enable_read_amd+0x4b>

    printk("enable read ==> cpu %d, counter %d : %u\n", cpu, counter, topmc_procs[cpu][counter].enable);
    171b:	0f b7 75 ee          	movzwl -0x12(%rbp),%esi
    171f:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
{
    unsigned int mix = *(unsigned int *)data;
    unsigned short cpu, counter;

    topmc_split32to16(mix, &cpu, &counter);
    count = sprintf(page, "%u\n", topmc_procs[cpu][counter].enable);
    1723:	89 c3                	mov    %eax,%ebx

    printk("enable read ==> cpu %d, counter %d : %u\n", cpu, counter, topmc_procs[cpu][counter].enable);
    1725:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    172c:	48 63 c6             	movslq %esi,%rax
    172f:	48 63 ca             	movslq %edx,%rcx
    1732:	48 c1 e0 05          	shl    $0x5,%rax
    1736:	48 01 c8             	add    %rcx,%rax
    1739:	48 c1 e0 04          	shl    $0x4,%rax
    173d:	8b 88 00 00 00 00    	mov    0x0(%rax),%ecx
    1743:	31 c0                	xor    %eax,%eax
    1745:	e8 00 00 00 00       	callq  174a <topmc_enable_read_amd+0x7a>

    return count;
} 
    174a:	89 d8                	mov    %ebx,%eax
    174c:	48 83 c4 18          	add    $0x18,%rsp
    1750:	5b                   	pop    %rbx
    1751:	c9                   	leaveq 
    1752:	c3                   	retq   
    1753:	90                   	nop
    1754:	90                   	nop
    1755:	90                   	nop
    1756:	90                   	nop
    1757:	90                   	nop
    1758:	90                   	nop
    1759:	90                   	nop
    175a:	90                   	nop
    175b:	90                   	nop
    175c:	90                   	nop
    175d:	90                   	nop
    175e:	90                   	nop
    175f:	90                   	nop

0000000000001760 <topmc_enable_all_read>:
	.read = topmc_cr4_pce_read,
	.write = topmc_cr4_pce_write,
};

int topmc_enable_all_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    1760:	55                   	push   %rbp
    1761:	48 89 e5             	mov    %rsp,%rbp
    1764:	e8 00 00 00 00       	callq  1769 <topmc_enable_all_read+0x9>
	if(model->topmc_enable_all_read != NULL)
    1769:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1770 <topmc_enable_all_read+0x10>
    1770:	4c 8b 50 30          	mov    0x30(%rax),%r10
    1774:	31 c0                	xor    %eax,%eax
    1776:	4d 85 d2             	test   %r10,%r10
    1779:	74 03                	je     177e <topmc_enable_all_read+0x1e>
		return model->topmc_enable_all_read(page, start, off, count, eof, data);
    177b:	41 ff d2             	callq  *%r10
	else
		return 0;
}
    177e:	c9                   	leaveq 
    177f:	c3                   	retq   

0000000000001780 <topmc_enable_all_write>:

int topmc_enable_all_write(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
    1780:	55                   	push   %rbp
    1781:	48 89 e5             	mov    %rsp,%rbp
    1784:	e8 00 00 00 00       	callq  1789 <topmc_enable_all_write+0x9>
	if(model->topmc_enable_all_write != NULL) 
    1789:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1790 <topmc_enable_all_write+0x10>
    1790:	4c 8b 40 38          	mov    0x38(%rax),%r8
    1794:	31 c0                	xor    %eax,%eax
    1796:	4d 85 c0             	test   %r8,%r8
    1799:	74 03                	je     179e <topmc_enable_all_write+0x1e>
		return model->topmc_enable_all_write(file, buffer, count, data);
    179b:	41 ff d0             	callq  *%r8
	else
		return 0;
}
    179e:	c9                   	leaveq 
    179f:	c3                   	retq   

00000000000017a0 <topmc_enable_read>:
	.read = topmc_enable_all_read,
	.write = topmc_enable_all_write,
};

int topmc_enable_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    17a0:	55                   	push   %rbp
    17a1:	48 89 e5             	mov    %rsp,%rbp
    17a4:	e8 00 00 00 00       	callq  17a9 <topmc_enable_read+0x9>
	return model->topmc_enable_read(page, start, off, count,eof,data); 
    17a9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 17b0 <topmc_enable_read+0x10>
    17b0:	ff 50 40             	callq  *0x40(%rax)
}
    17b3:	c9                   	leaveq 
    17b4:	c3                   	retq   
    17b5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    17bc:	00 00 00 00 

00000000000017c0 <topmc_enable_write>:


int topmc_enable_write(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
    17c0:	55                   	push   %rbp
    17c1:	48 89 e5             	mov    %rsp,%rbp
    17c4:	e8 00 00 00 00       	callq  17c9 <topmc_enable_write+0x9>
	return model->topmc_enable_write(file, buffer, count, data); 
    17c9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 17d0 <topmc_enable_write+0x10>
    17d0:	ff 50 48             	callq  *0x48(%rax)
}
    17d3:	c9                   	leaveq 
    17d4:	c3                   	retq   
    17d5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    17dc:	00 00 00 00 

00000000000017e0 <topmc_event_read>:
unit---MUST BE two numbers
kernel/user---MUST BE one of the following number: 0-"neither",1-"only user",2-"only kernel",3-"both"

*/
int topmc_event_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    17e0:	55                   	push   %rbp
    17e1:	48 89 e5             	mov    %rsp,%rbp
    17e4:	e8 00 00 00 00       	callq  17e9 <topmc_event_read+0x9>
	return model->topmc_event_read(page, start, off, count, eof, data); 
    17e9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 17f0 <topmc_event_read+0x10>
    17f0:	ff 50 50             	callq  *0x50(%rax)
}
    17f3:	c9                   	leaveq 
    17f4:	c3                   	retq   
    17f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    17fc:	00 00 00 00 

0000000000001800 <topmc_event_write>:

int topmc_event_write(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
    1800:	55                   	push   %rbp
    1801:	48 89 e5             	mov    %rsp,%rbp
    1804:	e8 00 00 00 00       	callq  1809 <topmc_event_write+0x9>
	return model->topmc_event_write(file, buffer, count, data); 
    1809:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1810 <topmc_event_write+0x10>
    1810:	ff 50 58             	callq  *0x58(%rax)
}
    1813:	c9                   	leaveq 
    1814:	c3                   	retq   
    1815:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    181c:	00 00 00 00 

0000000000001820 <topmc_value_read_callable_impl>:
};


#ifdef TOPMC_PER_SECOND
u64 topmc_value_read_callable_impl(unsigned short cpu, unsigned short counter)
{
    1820:	55                   	push   %rbp
    1821:	48 89 e5             	mov    %rsp,%rbp
    1824:	e8 00 00 00 00       	callq  1829 <topmc_value_read_callable_impl+0x9>
	return model->topmc_value_read_callable_impl(cpu, counter); 
    1829:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1830 <topmc_value_read_callable_impl+0x10>
    1830:	0f b7 f6             	movzwl %si,%esi
    1833:	0f b7 ff             	movzwl %di,%edi
    1836:	ff 50 60             	callq  *0x60(%rax)
}
    1839:	c9                   	leaveq 
    183a:	c3                   	retq   
    183b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

0000000000001840 <topmc_value_read>:

#endif

int topmc_value_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    1840:	55                   	push   %rbp
    1841:	48 89 e5             	mov    %rsp,%rbp
    1844:	e8 00 00 00 00       	callq  1849 <topmc_value_read+0x9>
	return model->topmc_value_read(page, start, off, count, eof, data); 
    1849:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1850 <topmc_value_read+0x10>
    1850:	ff 50 68             	callq  *0x68(%rax)
}
    1853:	c9                   	leaveq 
    1854:	c3                   	retq   
    1855:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    185c:	00 00 00 00 

0000000000001860 <topmc_value_write>:

int topmc_value_write(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
    1860:	55                   	push   %rbp
    1861:	48 89 e5             	mov    %rsp,%rbp
    1864:	e8 00 00 00 00       	callq  1869 <topmc_value_write+0x9>
	return model->topmc_value_write(file, buffer, count, data); 
    1869:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1870 <topmc_value_write+0x10>
    1870:	ff 50 70             	callq  *0x70(%rax)
}
    1873:	c9                   	leaveq 
    1874:	c3                   	retq   
    1875:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    187c:	00 00 00 00 

0000000000001880 <topmc_msr_init>:
	.read = topmc_value_read,
	.write = topmc_value_write,
};

void topmc_msr_init(void)
{
    1880:	55                   	push   %rbp
    1881:	48 89 e5             	mov    %rsp,%rbp
    1884:	e8 00 00 00 00       	callq  1889 <topmc_msr_init+0x9>
	model->topmc_msr_init();
    1889:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1890 <topmc_msr_init+0x10>
    1890:	ff 10                	callq  *(%rax)
}
    1892:	c9                   	leaveq 
    1893:	c3                   	retq   
    1894:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    189b:	00 00 00 00 00 

00000000000018a0 <topmc_core_global_ctrl_init>:

void topmc_core_global_ctrl_init(void)
{
    18a0:	55                   	push   %rbp
    18a1:	48 89 e5             	mov    %rsp,%rbp
    18a4:	e8 00 00 00 00       	callq  18a9 <topmc_core_global_ctrl_init+0x9>
	if(model->is_exist_topmc_core_global_ctrl_init)
    18a9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 18b0 <topmc_core_global_ctrl_init+0x10>
    18b0:	80 78 08 00          	cmpb   $0x0,0x8(%rax)
    18b4:	75 0a                	jne    18c0 <topmc_core_global_ctrl_init+0x20>
		model->topmc_core_global_ctrl_init();
	return;
}
    18b6:	c9                   	leaveq 
    18b7:	c3                   	retq   
    18b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    18bf:	00 
}

void topmc_core_global_ctrl_init(void)
{
	if(model->is_exist_topmc_core_global_ctrl_init)
		model->topmc_core_global_ctrl_init();
    18c0:	ff 50 10             	callq  *0x10(%rax)
	return;
}
    18c3:	c9                   	leaveq 
    18c4:	c3                   	retq   
    18c5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    18cc:	00 00 00 00 

00000000000018d0 <topmc_uncore_global_ctrl_init>:

/* initialization uncore global msrs*/
void topmc_uncore_global_ctrl_init(void)
{
    18d0:	55                   	push   %rbp
    18d1:	48 89 e5             	mov    %rsp,%rbp
    18d4:	e8 00 00 00 00       	callq  18d9 <topmc_uncore_global_ctrl_init+0x9>
	if(model->is_exist_topmc_uncore_global_ctrl_init)
    18d9:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 18e0 <topmc_uncore_global_ctrl_init+0x10>
    18e0:	80 78 18 00          	cmpb   $0x0,0x18(%rax)
    18e4:	75 0a                	jne    18f0 <topmc_uncore_global_ctrl_init+0x20>
		model->topmc_uncore_global_ctrl_init();
	return;
}
    18e6:	c9                   	leaveq 
    18e7:	c3                   	retq   
    18e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    18ef:	00 

/* initialization uncore global msrs*/
void topmc_uncore_global_ctrl_init(void)
{
	if(model->is_exist_topmc_uncore_global_ctrl_init)
		model->topmc_uncore_global_ctrl_init();
    18f0:	ff 50 20             	callq  *0x20(%rax)
	return;
}
    18f3:	c9                   	leaveq 
    18f4:	c3                   	retq   
    18f5:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%rax,%rax,1)
    18fc:	00 00 00 00 

0000000000001900 <topmc_model_detect>:
	}

}

int topmc_model_detect(void)
{
    1900:	55                   	push   %rbp
    1901:	48 89 e5             	mov    %rsp,%rbp
    1904:	48 83 ec 30          	sub    $0x30,%rsp
    1908:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
    190c:	4c 89 65 e8          	mov    %r12,-0x18(%rbp)
    1910:	4c 89 6d f0          	mov    %r13,-0x10(%rbp)
    1914:	4c 89 75 f8          	mov    %r14,-0x8(%rbp)
    1918:	e8 00 00 00 00       	callq  191d <topmc_model_detect+0x1d>
}

static __always_inline int constant_test_bit(long nr, const volatile unsigned long *addr)
{
	return ((1UL << (nr & (BITS_PER_LONG-1))) &
		(addr[nr >> _BITOPS_LONG_SHIFT])) != 0;
    191d:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1924 <topmc_model_detect+0x24>
	__u8 vendor = boot_cpu_data.x86_vendor;
    1924:	44 0f b6 2d 00 00 00 	movzbl 0x0(%rip),%r13d        # 192c <topmc_model_detect+0x2c>
    192b:	00 
	__u8 family = boot_cpu_data.x86;
    192c:	44 0f b6 25 00 00 00 	movzbl 0x0(%rip),%r12d        # 1934 <topmc_model_detect+0x34>
    1933:	00 
	__u8 cpu_model = /*current_cpu_data*/boot_cpu_data.x86_model;
    1934:	0f b6 0d 00 00 00 00 	movzbl 0x0(%rip),%ecx        # 193b <topmc_model_detect+0x3b>

	if(!cpu_has_apic)
    193b:	f6 c4 02             	test   $0x2,%ah
    193e:	75 17                	jne    1957 <topmc_model_detect+0x57>
    1940:	b8 ed ff ff ff       	mov    $0xffffffed,%eax
	default:
		printk("topmc->topmc_model_detect(): vendor %d not supported.\n", vendor);
		return 0;
	}
	return 1;
}
    1945:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
    1949:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
    194d:	4c 8b 6d f0          	mov    -0x10(%rbp),%r13
    1951:	4c 8b 75 f8          	mov    -0x8(%rbp),%r14
    1955:	c9                   	leaveq 
    1956:	c3                   	retq   
	__u8 family = boot_cpu_data.x86;
	__u8 cpu_model = /*current_cpu_data*/boot_cpu_data.x86_model;

	if(!cpu_has_apic)
		return -ENODEV;
	printk("topmc->topmc_model_detect(): vendor:%d, family: %d.\n", vendor, family);
    1957:	41 0f b6 dc          	movzbl %r12b,%ebx
    195b:	45 0f b6 f5          	movzbl %r13b,%r14d
    195f:	31 c0                	xor    %eax,%eax
    1961:	89 da                	mov    %ebx,%edx
    1963:	44 89 f6             	mov    %r14d,%esi
    1966:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    196d:	88 4d d8             	mov    %cl,-0x28(%rbp)
    1970:	e8 00 00 00 00       	callq  1975 <topmc_model_detect+0x75>
	switch(vendor) {
    1975:	45 84 ed             	test   %r13b,%r13b
    1978:	0f b6 4d d8          	movzbl -0x28(%rbp),%ecx
    197c:	75 1a                	jne    1998 <topmc_model_detect+0x98>
			break;
		}
		break;
	
	case X86_VENDOR_INTEL:
		switch(family) {
    197e:	41 80 fc 06          	cmp    $0x6,%r12b
    1982:	74 2f                	je     19b3 <topmc_model_detect+0xb3>
			        default:
			            printk("topmc->topmc_model_detect(): family of intel %d  model %d not supported.\n", family,cpu_model);
			            return 0;
			}
		default:
			printk("topmc->topmc_model_detect(): family of intel %d not supported.\n", family);
    1984:	89 de                	mov    %ebx,%esi
    1986:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    198d:	31 c0                	xor    %eax,%eax
    198f:	e8 00 00 00 00       	callq  1994 <topmc_model_detect+0x94>
    1994:	31 c0                	xor    %eax,%eax
			return 0;
    1996:	eb ad                	jmp    1945 <topmc_model_detect+0x45>
	__u8 cpu_model = /*current_cpu_data*/boot_cpu_data.x86_model;

	if(!cpu_has_apic)
		return -ENODEV;
	printk("topmc->topmc_model_detect(): vendor:%d, family: %d.\n", vendor, family);
	switch(vendor) {
    1998:	41 80 fd 02          	cmp    $0x2,%r13b
    199c:	74 59                	je     19f7 <topmc_model_detect+0xf7>
			printk("topmc->topmc_model_detect(): family of intel %d not supported.\n", family);
			return 0;
		}
		break;
	default:
		printk("topmc->topmc_model_detect(): vendor %d not supported.\n", vendor);
    199e:	44 89 f6             	mov    %r14d,%esi
    19a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    19a8:	31 c0                	xor    %eax,%eax
    19aa:	e8 00 00 00 00       	callq  19af <topmc_model_detect+0xaf>
    19af:	31 c0                	xor    %eax,%eax
		return 0;
    19b1:	eb 92                	jmp    1945 <topmc_model_detect+0x45>
		break;
	
	case X86_VENDOR_INTEL:
		switch(family) {
		case 6:
			switch(cpu_model)
    19b3:	80 f9 3e             	cmp    $0x3e,%cl
    19b6:	77 6a                	ja     1a22 <topmc_model_detect+0x122>
    19b8:	b8 01 00 00 00       	mov    $0x1,%eax
    19bd:	48 ba 00 04 00 04 00 	mov    $0x4000000004000400,%rdx
    19c4:	00 00 40 
    19c7:	48 d3 e0             	shl    %cl,%rax
    19ca:	48 85 d0             	test   %rdx,%rax
    19cd:	74 53                	je     1a22 <topmc_model_detect+0x122>
			{
				case 10:
				case 26:
				case 62:
					model = &topmc_op_intel_nehelam;
					printk("topmc->topmc_model_detect(): family:intel %d  model %d.\n", family,cpu_model);
    19cf:	0f b6 d1             	movzbl %cl,%edx
    19d2:	89 de                	mov    %ebx,%esi
    19d4:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    19db:	31 c0                	xor    %eax,%eax
			switch(cpu_model)
			{
				case 10:
				case 26:
				case 62:
					model = &topmc_op_intel_nehelam;
    19dd:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 19e8 <topmc_model_detect+0xe8>
    19e4:	00 00 00 00 
					printk("topmc->topmc_model_detect(): family:intel %d  model %d.\n", family,cpu_model);
    19e8:	e8 00 00 00 00       	callq  19ed <topmc_model_detect+0xed>
    19ed:	b8 01 00 00 00       	mov    $0x1,%eax
					return 1;
    19f2:	e9 4e ff ff ff       	jmpq   1945 <topmc_model_detect+0x45>
	if(!cpu_has_apic)
		return -ENODEV;
	printk("topmc->topmc_model_detect(): vendor:%d, family: %d.\n", vendor, family);
	switch(vendor) {
	case X86_VENDOR_AMD:
		switch(family) {
    19f7:	41 80 fc 10          	cmp    $0x10,%r12b
    19fb:	74 3f                	je     1a3c <topmc_model_detect+0x13c>
			model = &topmc_op_amd;
			printk("topmc->topmc_model_detect(): family: amd/6.\n");
			break;
		default:
			model = &topmc_op_amd;
			printk("topmc->topmc_model_detect(): family of amd %d not supported, use dafault AMD topmc_module.\n", family);
    19fd:	89 de                	mov    %ebx,%esi
    19ff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1a06:	31 c0                	xor    %eax,%eax
		case 16:
			model = &topmc_op_amd;
			printk("topmc->topmc_model_detect(): family: amd/6.\n");
			break;
		default:
			model = &topmc_op_amd;
    1a08:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1a13 <topmc_model_detect+0x113>
    1a0f:	00 00 00 00 
			printk("topmc->topmc_model_detect(): family of amd %d not supported, use dafault AMD topmc_module.\n", family);
    1a13:	e8 00 00 00 00       	callq  1a18 <topmc_model_detect+0x118>
    1a18:	b8 01 00 00 00       	mov    $0x1,%eax
    1a1d:	e9 23 ff ff ff       	jmpq   1945 <topmc_model_detect+0x45>
					model = &topmc_op_intel_nehelam;
					printk("topmc->topmc_model_detect(): family:intel %d  model %d.\n", family,cpu_model);
					return 1;
					//return 0;
			        default:
			            printk("topmc->topmc_model_detect(): family of intel %d  model %d not supported.\n", family,cpu_model);
    1a22:	0f b6 d1             	movzbl %cl,%edx
    1a25:	89 de                	mov    %ebx,%esi
    1a27:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1a2e:	31 c0                	xor    %eax,%eax
    1a30:	e8 00 00 00 00       	callq  1a35 <topmc_model_detect+0x135>
    1a35:	31 c0                	xor    %eax,%eax
			            return 0;
    1a37:	e9 09 ff ff ff       	jmpq   1945 <topmc_model_detect+0x45>
	switch(vendor) {
	case X86_VENDOR_AMD:
		switch(family) {
		case 16:
			model = &topmc_op_amd;
			printk("topmc->topmc_model_detect(): family: amd/6.\n");
    1a3c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1a43:	31 c0                	xor    %eax,%eax
	printk("topmc->topmc_model_detect(): vendor:%d, family: %d.\n", vendor, family);
	switch(vendor) {
	case X86_VENDOR_AMD:
		switch(family) {
		case 16:
			model = &topmc_op_amd;
    1a45:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1a50 <topmc_model_detect+0x150>
    1a4c:	00 00 00 00 
			printk("topmc->topmc_model_detect(): family: amd/6.\n");
    1a50:	e8 00 00 00 00       	callq  1a55 <topmc_model_detect+0x155>
    1a55:	b8 01 00 00 00       	mov    $0x1,%eax
			break;
    1a5a:	e9 e6 fe ff ff       	jmpq   1945 <topmc_model_detect+0x45>
    1a5f:	90                   	nop

0000000000001a60 <topmc_proc_clean>:

/* proc filesystem clean process: entry -> counter -> core -> topmc
 */

void topmc_proc_clean(void)
{
    1a60:	55                   	push   %rbp
    1a61:	48 89 e5             	mov    %rsp,%rbp
    1a64:	41 57                	push   %r15
    1a66:	41 56                	push   %r14
    1a68:	41 55                	push   %r13
    1a6a:	41 54                	push   %r12
    1a6c:	53                   	push   %rbx
    1a6d:	48 83 ec 38          	sub    $0x38,%rsp
    1a71:	e8 00 00 00 00       	callq  1a76 <topmc_proc_clean+0x16>
    1a76:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1a7d:	00 00 
    1a7f:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    1a83:	31 c0                	xor    %eax,%eax

	//int i;
	int cpu,counter;
	char namebuf[TOPMC_MAX_NAMELEN];

	if(enable_entry) {
    1a85:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 1a8d <topmc_proc_clean+0x2d>
    1a8c:	00 
    1a8d:	74 1e                	je     1aad <topmc_proc_clean+0x4d>
		remove_proc_entry("enable_all",root_dir);
    1a8f:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 1a96 <topmc_proc_clean+0x36>
    1a96:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1a9d:	e8 00 00 00 00       	callq  1aa2 <topmc_proc_clean+0x42>
		enable_entry = NULL;
    1aa2:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1aad <topmc_proc_clean+0x4d>
    1aa9:	00 00 00 00 
	}

    if(enable_all_cr4_pce_entry) {
    1aad:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 1ab5 <topmc_proc_clean+0x55>
    1ab4:	00 
    1ab5:	74 1e                	je     1ad5 <topmc_proc_clean+0x75>
        remove_proc_entry("enable_cr4_pce", root_dir);
    1ab7:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 1abe <topmc_proc_clean+0x5e>
    1abe:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1ac5:	e8 00 00 00 00       	callq  1aca <topmc_proc_clean+0x6a>
        enable_all_cr4_pce_entry = NULL;
    1aca:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1ad5 <topmc_proc_clean+0x75>
    1ad1:	00 00 00 00 
    1ad5:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 1adb <topmc_proc_clean+0x7b>
    1adb:	4c 8d 75 b0          	lea    -0x50(%rbp),%r14
    1adf:	c7 45 ac ff ff ff ff 	movl   $0xffffffff,-0x54(%rbp)
    1ae6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    1aed:	00 00 00 
    1af0:	8b 55 ac             	mov    -0x54(%rbp),%edx
    1af3:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1afa <topmc_proc_clean+0x9a>
    1afa:	48 63 f6             	movslq %esi,%rsi
    1afd:	83 c2 01             	add    $0x1,%edx
    1b00:	48 63 d2             	movslq %edx,%rdx
    1b03:	e8 00 00 00 00       	callq  1b08 <topmc_proc_clean+0xa8>
    }

	for_each_online_cpu(cpu){
    1b08:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 1b0e <topmc_proc_clean+0xae>
    1b0e:	89 45 ac             	mov    %eax,-0x54(%rbp)
    1b11:	39 f0                	cmp    %esi,%eax
    1b13:	0f 8d 90 01 00 00    	jge    1ca9 <topmc_proc_clean+0x249>
		if(core_dir[cpu]) {
    1b19:	4c 63 7d ac          	movslq -0x54(%rbp),%r15
    1b1d:	4a 83 3c fd 00 00 00 	cmpq   $0x0,0x0(,%r15,8)
    1b24:	00 00 
    1b26:	74 c8                	je     1af0 <topmc_proc_clean+0x90>
			for(counter=0;counter<model->num_counters_core + model->num_counters_uncore;counter++){
    1b28:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1b2f <topmc_proc_clean+0xcf>
    1b2f:	8b 42 2c             	mov    0x2c(%rdx),%eax
    1b32:	03 42 28             	add    0x28(%rdx),%eax
    1b35:	85 c0                	test   %eax,%eax
    1b37:	0f 8e 23 01 00 00    	jle    1c60 <topmc_proc_clean+0x200>
    1b3d:	4b 8d 1c 7f          	lea    (%r15,%r15,2),%rbx
    1b41:	4d 89 fc             	mov    %r15,%r12
    1b44:	45 31 ed             	xor    %r13d,%r13d
    1b47:	49 c1 e4 08          	shl    $0x8,%r12
    1b4b:	48 c1 e3 08          	shl    $0x8,%rbx
    1b4f:	49 81 c4 00 00 00 00 	add    $0x0,%r12
    1b56:	48 81 c3 00 00 00 00 	add    $0x0,%rbx
    1b5d:	eb 53                	jmp    1bb2 <topmc_proc_clean+0x152>
    1b5f:	90                   	nop
					memset(namebuf,0,TOPMC_MAX_NAMELEN);
					if( counter < model->num_counters_core) {
						sprintf(namebuf,"incore_counter%d",counter);
					}
					if( counter >= model->num_counters_core) {
						sprintf(namebuf, "uncore_counter%d",counter- model->num_counters_core);
    1b60:	44 89 e8             	mov    %r13d,%eax
    1b63:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1b6a:	4c 89 f7             	mov    %r14,%rdi
    1b6d:	29 d0                	sub    %edx,%eax
    1b6f:	89 c2                	mov    %eax,%edx
    1b71:	31 c0                	xor    %eax,%eax
    1b73:	e8 00 00 00 00       	callq  1b78 <topmc_proc_clean+0x118>
					}
					remove_proc_entry(namebuf,core_dir[cpu]);
    1b78:	4a 8b 34 fd 00 00 00 	mov    0x0(,%r15,8),%rsi
    1b7f:	00 
    1b80:	4c 89 f7             	mov    %r14,%rdi
    1b83:	e8 00 00 00 00       	callq  1b88 <topmc_proc_clean+0x128>
    1b88:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1b8f <topmc_proc_clean+0x12f>
					counter_dir[cpu][counter] = NULL;
    1b8f:	49 c7 04 24 00 00 00 	movq   $0x0,(%r12)
    1b96:	00 
        enable_all_cr4_pce_entry = NULL;
    }

	for_each_online_cpu(cpu){
		if(core_dir[cpu]) {
			for(counter=0;counter<model->num_counters_core + model->num_counters_uncore;counter++){
    1b97:	8b 42 2c             	mov    0x2c(%rdx),%eax
    1b9a:	03 42 28             	add    0x28(%rdx),%eax
    1b9d:	41 83 c5 01          	add    $0x1,%r13d
    1ba1:	49 83 c4 08          	add    $0x8,%r12
    1ba5:	48 83 c3 18          	add    $0x18,%rbx
    1ba9:	44 39 e8             	cmp    %r13d,%eax
    1bac:	0f 8e ae 00 00 00    	jle    1c60 <topmc_proc_clean+0x200>
				if(counter_dir[cpu][counter]) {
    1bb2:	49 8b 34 24          	mov    (%r12),%rsi
    1bb6:	48 85 f6             	test   %rsi,%rsi
    1bb9:	74 dc                	je     1b97 <topmc_proc_clean+0x137>
					if(entry[cpu][counter][0]) {
    1bbb:	48 83 7b f0 00       	cmpq   $0x0,-0x10(%rbx)
    1bc0:	74 14                	je     1bd6 <topmc_proc_clean+0x176>
						remove_proc_entry("enable",counter_dir[cpu][counter]); 
    1bc2:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1bc9:	e8 00 00 00 00       	callq  1bce <topmc_proc_clean+0x16e>
						entry[cpu][counter][0]=NULL;
    1bce:	48 c7 43 f0 00 00 00 	movq   $0x0,-0x10(%rbx)
    1bd5:	00 
					}
					if(entry[cpu][counter][1]) {
    1bd6:	48 83 7b f8 00       	cmpq   $0x0,-0x8(%rbx)
    1bdb:	74 18                	je     1bf5 <topmc_proc_clean+0x195>
						remove_proc_entry("event",counter_dir[cpu][counter]); 
    1bdd:	49 8b 34 24          	mov    (%r12),%rsi
    1be1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1be8:	e8 00 00 00 00       	callq  1bed <topmc_proc_clean+0x18d>
						entry[cpu][counter][1]=NULL;
    1bed:	48 c7 43 f8 00 00 00 	movq   $0x0,-0x8(%rbx)
    1bf4:	00 
					}
					if(entry[cpu][counter][2]) {
    1bf5:	48 83 3b 00          	cmpq   $0x0,(%rbx)
    1bf9:	74 17                	je     1c12 <topmc_proc_clean+0x1b2>
						remove_proc_entry("value",counter_dir[cpu][counter]); 
    1bfb:	49 8b 34 24          	mov    (%r12),%rsi
    1bff:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1c06:	e8 00 00 00 00       	callq  1c0b <topmc_proc_clean+0x1ab>
						entry[cpu][counter][2]=NULL;
    1c0b:	48 c7 03 00 00 00 00 	movq   $0x0,(%rbx)
					}
					memset(namebuf,0,TOPMC_MAX_NAMELEN);
					if( counter < model->num_counters_core) {
    1c12:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1c19 <topmc_proc_clean+0x1b9>
					}
					if(entry[cpu][counter][2]) {
						remove_proc_entry("value",counter_dir[cpu][counter]); 
						entry[cpu][counter][2]=NULL;
					}
					memset(namebuf,0,TOPMC_MAX_NAMELEN);
    1c19:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
    1c20:	49 c7 46 08 00 00 00 	movq   $0x0,0x8(%r14)
    1c27:	00 
					if( counter < model->num_counters_core) {
    1c28:	8b 50 28             	mov    0x28(%rax),%edx
    1c2b:	44 39 ea             	cmp    %r13d,%edx
    1c2e:	0f 8e 2c ff ff ff    	jle    1b60 <topmc_proc_clean+0x100>
						sprintf(namebuf,"incore_counter%d",counter);
    1c34:	44 89 ea             	mov    %r13d,%edx
    1c37:	31 c0                	xor    %eax,%eax
    1c39:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1c40:	4c 89 f7             	mov    %r14,%rdi
    1c43:	e8 00 00 00 00       	callq  1c48 <topmc_proc_clean+0x1e8>
					}
					if( counter >= model->num_counters_core) {
    1c48:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1c4f <topmc_proc_clean+0x1ef>
    1c4f:	8b 50 28             	mov    0x28(%rax),%edx
    1c52:	44 39 ea             	cmp    %r13d,%edx
    1c55:	0f 8f 1d ff ff ff    	jg     1b78 <topmc_proc_clean+0x118>
    1c5b:	e9 00 ff ff ff       	jmpq   1b60 <topmc_proc_clean+0x100>
					remove_proc_entry(namebuf,core_dir[cpu]);
					counter_dir[cpu][counter] = NULL;
				}
			}
			memset(namebuf,0,TOPMC_MAX_NAMELEN);	
			sprintf(namebuf,"core%02d",cpu);
    1c60:	8b 55 ac             	mov    -0x54(%rbp),%edx
    1c63:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1c6a:	4c 89 f7             	mov    %r14,%rdi
					}
					remove_proc_entry(namebuf,core_dir[cpu]);
					counter_dir[cpu][counter] = NULL;
				}
			}
			memset(namebuf,0,TOPMC_MAX_NAMELEN);	
    1c6d:	49 c7 06 00 00 00 00 	movq   $0x0,(%r14)
    1c74:	49 c7 46 08 00 00 00 	movq   $0x0,0x8(%r14)
    1c7b:	00 
			sprintf(namebuf,"core%02d",cpu);
    1c7c:	31 c0                	xor    %eax,%eax
    1c7e:	e8 00 00 00 00       	callq  1c83 <topmc_proc_clean+0x223>
			remove_proc_entry(namebuf,root_dir);
    1c83:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 1c8a <topmc_proc_clean+0x22a>
    1c8a:	4c 89 f7             	mov    %r14,%rdi
    1c8d:	e8 00 00 00 00       	callq  1c92 <topmc_proc_clean+0x232>
			core_dir[cpu]=NULL;
    1c92:	4a c7 04 fd 00 00 00 	movq   $0x0,0x0(,%r15,8)
    1c99:	00 00 00 00 00 
    1c9e:	8b 35 00 00 00 00    	mov    0x0(%rip),%esi        # 1ca4 <topmc_proc_clean+0x244>
    1ca4:	e9 47 fe ff ff       	jmpq   1af0 <topmc_proc_clean+0x90>
		} 
	}

	if(root_dir) {
    1ca9:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 1cb1 <topmc_proc_clean+0x251>
    1cb0:	00 
    1cb1:	74 19                	je     1ccc <topmc_proc_clean+0x26c>
		remove_proc_entry("topmc",NULL);
    1cb3:	31 f6                	xor    %esi,%esi
    1cb5:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1cbc:	e8 00 00 00 00       	callq  1cc1 <topmc_proc_clean+0x261>
		root_dir = NULL;
    1cc1:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1ccc <topmc_proc_clean+0x26c>
    1cc8:	00 00 00 00 
	}

}
    1ccc:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
    1cd0:	65 48 33 04 25 28 00 	xor    %gs:0x28,%rax
    1cd7:	00 00 
    1cd9:	75 0f                	jne    1cea <topmc_proc_clean+0x28a>
    1cdb:	48 83 c4 38          	add    $0x38,%rsp
    1cdf:	5b                   	pop    %rbx
    1ce0:	41 5c                	pop    %r12
    1ce2:	41 5d                	pop    %r13
    1ce4:	41 5e                	pop    %r14
    1ce6:	41 5f                	pop    %r15
    1ce8:	c9                   	leaveq 
    1ce9:	c3                   	retq   
    1cea:	e8 00 00 00 00       	callq  1cef <topmc_proc_clean+0x28f>
    1cef:	90                   	nop

0000000000001cf0 <init_module>:
 *                      
 *topmc->core*->counter*->entry
 *
 **/
int topmc_init(void)
{
    1cf0:	55                   	push   %rbp
    1cf1:	48 89 e5             	mov    %rsp,%rbp
    1cf4:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
    1cfb:	48 89 5d d8          	mov    %rbx,-0x28(%rbp)
    1cff:	4c 89 65 e0          	mov    %r12,-0x20(%rbp)
    1d03:	4c 89 6d e8          	mov    %r13,-0x18(%rbp)
    1d07:	4c 89 75 f0          	mov    %r14,-0x10(%rbp)
    1d0b:	4c 89 7d f8          	mov    %r15,-0x8(%rbp)
    1d0f:	e8 00 00 00 00       	callq  1d14 <init_module+0x24>
    int ret = 0;
    int cpu,counter;
    char namebuf[TOPMC_MAX_NAMELEN];

    printk("+->topmc_init() start...\n");
    1d14:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
 *                      
 *topmc->core*->counter*->entry
 *
 **/
int topmc_init(void)
{
    1d1b:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
    1d22:	00 00 
    1d24:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    1d28:	31 c0                	xor    %eax,%eax
    int ret = 0;
    int cpu,counter;
    char namebuf[TOPMC_MAX_NAMELEN];

    printk("+->topmc_init() start...\n");
    1d2a:	e8 00 00 00 00       	callq  1d2f <init_module+0x3f>

    topmc_model_detect();
    1d2f:	e8 00 00 00 00       	callq  1d34 <init_module+0x44>
    if(!model)
    1d34:	48 83 3d 00 00 00 00 	cmpq   $0x0,0x0(%rip)        # 1d3c <init_module+0x4c>
    1d3b:	00 
    1d3c:	0f 84 5f 03 00 00    	je     20a1 <init_module+0x3b1>
    {
        printk("The processor is not supported yet.\n");
        return ret;
    }
    topmc_core_global_ctrl_init();
    1d42:	e8 00 00 00 00       	callq  1d47 <init_module+0x57>
    topmc_uncore_global_ctrl_init();
    1d47:	e8 00 00 00 00       	callq  1d4c <init_module+0x5c>
	.write = topmc_value_write,
};

void topmc_msr_init(void)
{
	model->topmc_msr_init();
    1d4c:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 1d53 <init_module+0x63>
    1d53:	ff 10                	callq  *(%rax)
    }
    topmc_core_global_ctrl_init();
    topmc_uncore_global_ctrl_init();
    topmc_msr_init();

    memset(topmc_procs,0,sizeof(topmc_procs));
    1d55:	31 f6                	xor    %esi,%esi
    1d57:	ba 00 00 20 00       	mov    $0x200000,%edx
    1d5c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1d63:	e8 00 00 00 00       	callq  1d68 <init_module+0x78>

    root_dir        = proc_mkdir("topmc",NULL);
    1d68:	31 f6                	xor    %esi,%esi
    1d6a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1d71:	e8 00 00 00 00       	callq  1d76 <init_module+0x86>
    if(!root_dir){
    1d76:	48 85 c0             	test   %rax,%rax
    topmc_uncore_global_ctrl_init();
    topmc_msr_init();

    memset(topmc_procs,0,sizeof(topmc_procs));

    root_dir        = proc_mkdir("topmc",NULL);
    1d79:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1d80 <init_module+0x90>
    if(!root_dir){
    1d80:	0f 84 05 03 00 00    	je     208b <init_module+0x39b>
        ret = -ENOMEM;
        return ret;
    }


    enable_all_cr4_pce_entry = proc_create_data("enable_cr4_pce", 0666, root_dir, &topmc_cr4_pce_fops, &enable_all_cr4_pce);
    1d86:	49 c7 c0 00 00 00 00 	mov    $0x0,%r8
    1d8d:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    1d94:	48 89 c2             	mov    %rax,%rdx
    1d97:	be b6 01 00 00       	mov    $0x1b6,%esi
    1d9c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1da3:	e8 00 00 00 00       	callq  1da8 <init_module+0xb8>
	//enable_all_cr4_pce_entry = create_proc_entry("enable_cr4_pce", 0666, root_dir);
    if(enable_all_cr4_pce_entry == NULL) {
    1da8:	48 85 c0             	test   %rax,%rax
        ret = -ENOMEM;
        return ret;
    }


    enable_all_cr4_pce_entry = proc_create_data("enable_cr4_pce", 0666, root_dir, &topmc_cr4_pce_fops, &enable_all_cr4_pce);
    1dab:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1db2 <init_module+0xc2>
	//enable_all_cr4_pce_entry = create_proc_entry("enable_cr4_pce", 0666, root_dir);
    if(enable_all_cr4_pce_entry == NULL) {
    1db2:	0f 84 ad 02 00 00    	je     2065 <init_module+0x375>
        enable_all_cr4_pce_entry->read_proc  = topmc_cr4_pce_read;
        enable_all_cr4_pce_entry->write_proc = topmc_cr4_pce_write;
    }
#endif

    enable_entry   = proc_create_data("enable_all",0666,root_dir, &topmc_enable_all_fops, NULL);
    1db8:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1dbf <init_module+0xcf>
    1dbf:	45 31 c0             	xor    %r8d,%r8d
    1dc2:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    1dc9:	be b6 01 00 00       	mov    $0x1b6,%esi
    1dce:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1dd5:	e8 00 00 00 00       	callq  1dda <init_module+0xea>
	//enable_entry   = create_proc_entry("enable_all",0666,root_dir);
    if(enable_entry == NULL){
    1dda:	48 85 c0             	test   %rax,%rax
        enable_all_cr4_pce_entry->read_proc  = topmc_cr4_pce_read;
        enable_all_cr4_pce_entry->write_proc = topmc_cr4_pce_write;
    }
#endif

    enable_entry   = proc_create_data("enable_all",0666,root_dir, &topmc_enable_all_fops, NULL);
    1ddd:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1de4 <init_module+0xf4>
	//enable_entry   = create_proc_entry("enable_all",0666,root_dir);
    if(enable_entry == NULL){
    1de4:	0f 84 55 02 00 00    	je     203f <init_module+0x34f>
    1dea:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # 1df1 <init_module+0x101>
        enable_entry->write_proc       = topmc_enable_all_write;
    }
#endif
    for_each_online_cpu(cpu){
        printk("+->topmc_init(): cpu:%d\n",cpu);
        memset(namebuf,0,TOPMC_MAX_NAMELEN);
    1df1:	4c 8d 65 b0          	lea    -0x50(%rbp),%r12
    1df5:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    1dfa:	45 31 ed             	xor    %r13d,%r13d
    1dfd:	41 be 04 00 00 00    	mov    $0x4,%r14d
    1e03:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 1e0a <init_module+0x11a>
    1e0a:	83 c3 01             	add    $0x1,%ebx
    1e0d:	4c 89 ff             	mov    %r15,%rdi
    1e10:	48 63 d3             	movslq %ebx,%rdx
    1e13:	e8 00 00 00 00       	callq  1e18 <init_module+0x128>
	else {
        enable_entry->read_proc        = topmc_enable_all_read;
        enable_entry->write_proc       = topmc_enable_all_write;
    }
#endif
    for_each_online_cpu(cpu){
    1e18:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 1e1e <init_module+0x12e>
    1e1e:	48 89 c2             	mov    %rax,%rdx
    1e21:	89 c3                	mov    %eax,%ebx
    1e23:	7c 37                	jl     1e5c <init_module+0x16c>
        }
    }

//    topmc_enable_rdpmc();
#ifdef TOPMC_PER_SECOND
    topmc_value_read_callable = &topmc_value_read_callable_impl;
    1e25:	48 c7 05 00 00 00 00 	movq   $0x0,0x0(%rip)        # 1e30 <init_module+0x140>
    1e2c:	00 00 00 00 
    1e30:	31 c0                	xor    %eax,%eax
#endif

    return ret;
}
    1e32:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
    1e36:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
    1e3d:	00 00 
    1e3f:	75 16                	jne    1e57 <init_module+0x167>
    1e41:	48 8b 5d d8          	mov    -0x28(%rbp),%rbx
    1e45:	4c 8b 65 e0          	mov    -0x20(%rbp),%r12
    1e49:	4c 8b 6d e8          	mov    -0x18(%rbp),%r13
    1e4d:	4c 8b 75 f0          	mov    -0x10(%rbp),%r14
    1e51:	4c 8b 7d f8          	mov    -0x8(%rbp),%r15
    1e55:	c9                   	leaveq 
    1e56:	c3                   	retq   
    1e57:	e8 00 00 00 00       	callq  1e5c <init_module+0x16c>
        enable_entry->read_proc        = topmc_enable_all_read;
        enable_entry->write_proc       = topmc_enable_all_write;
    }
#endif
    for_each_online_cpu(cpu){
        printk("+->topmc_init(): cpu:%d\n",cpu);
    1e5c:	89 d6                	mov    %edx,%esi
    1e5e:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1e65:	31 c0                	xor    %eax,%eax
    1e67:	48 89 95 70 ff ff ff 	mov    %rdx,-0x90(%rbp)
    1e6e:	e8 00 00 00 00       	callq  1e73 <init_module+0x183>
        memset(namebuf,0,TOPMC_MAX_NAMELEN);
    1e73:	44 89 e8             	mov    %r13d,%eax
    1e76:	4c 89 e7             	mov    %r12,%rdi
    1e79:	4c 89 f1             	mov    %r14,%rcx
    1e7c:	f3 ab                	rep stos %eax,%es:(%rdi)
        sprintf(namebuf,"core%02d",cpu);
    1e7e:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1e85:	4c 89 e7             	mov    %r12,%rdi
    1e88:	31 c0                	xor    %eax,%eax
    1e8a:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
    1e91:	e8 00 00 00 00       	callq  1e96 <init_module+0x1a6>
        core_dir[cpu]        = proc_mkdir(namebuf,root_dir);
    1e96:	48 8b 35 00 00 00 00 	mov    0x0(%rip),%rsi        # 1e9d <init_module+0x1ad>
    1e9d:	4c 89 e7             	mov    %r12,%rdi
    1ea0:	e8 00 00 00 00       	callq  1ea5 <init_module+0x1b5>
    1ea5:	48 63 d3             	movslq %ebx,%rdx
        if(!core_dir[cpu]){
    1ea8:	48 85 c0             	test   %rax,%rax
#endif
    for_each_online_cpu(cpu){
        printk("+->topmc_init(): cpu:%d\n",cpu);
        memset(namebuf,0,TOPMC_MAX_NAMELEN);
        sprintf(namebuf,"core%02d",cpu);
        core_dir[cpu]        = proc_mkdir(namebuf,root_dir);
    1eab:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
    1eaf:	48 89 04 d5 00 00 00 	mov    %rax,0x0(,%rdx,8)
    1eb6:	00 
        if(!core_dir[cpu]){
    1eb7:	0f 84 61 02 00 00    	je     211e <init_module+0x42e>
    1ebd:	48 89 d0             	mov    %rdx,%rax
    1ec0:	c7 45 ac 00 00 00 00 	movl   $0x0,-0x54(%rbp)
    1ec7:	48 c1 e0 08          	shl    $0x8,%rax
    1ecb:	48 05 00 00 00 00    	add    $0x0,%rax
    1ed1:	48 89 45 98          	mov    %rax,-0x68(%rbp)
    1ed5:	48 89 d0             	mov    %rdx,%rax
    1ed8:	48 c1 e0 07          	shl    $0x7,%rax
    1edc:	48 05 00 00 00 00    	add    $0x0,%rax
    1ee2:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
    1ee6:	48 6b c2 30          	imul   $0x30,%rdx,%rax
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }

            mix_cpu_counter[cpu][counter] = topmc_mix16to32((unsigned short)cpu, (unsigned short)counter);
    1eea:	0f b7 d3             	movzwl %bx,%edx
    1eed:	89 95 7c ff ff ff    	mov    %edx,-0x84(%rbp)
    for_each_online_cpu(cpu){
        printk("+->topmc_init(): cpu:%d\n",cpu);
        memset(namebuf,0,TOPMC_MAX_NAMELEN);
        sprintf(namebuf,"core%02d",cpu);
        core_dir[cpu]        = proc_mkdir(namebuf,root_dir);
        if(!core_dir[cpu]){
    1ef3:	48 c1 e0 04          	shl    $0x4,%rax
    1ef7:	48 05 00 00 00 00    	add    $0x0,%rax
    1efd:	48 89 45 90          	mov    %rax,-0x70(%rbp)
    1f01:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
    1f05:	48 89 45 80          	mov    %rax,-0x80(%rbp)
            topmc_proc_clean();
            ret = -ENOMEM;
            return ret;
        }

        for(counter=0;counter<model->num_counters_core+model->num_counters_uncore;counter++){
    1f09:	48 8b 15 00 00 00 00 	mov    0x0(%rip),%rdx        # 1f10 <init_module+0x220>
    1f10:	8b 42 2c             	mov    0x2c(%rdx),%eax
    1f13:	03 42 28             	add    0x28(%rdx),%eax
    1f16:	39 45 ac             	cmp    %eax,-0x54(%rbp)
    1f19:	0f 8d e4 fe ff ff    	jge    1e03 <init_module+0x113>
            memset(namebuf,0,TOPMC_MAX_NAMELEN);
    1f1f:	44 89 e8             	mov    %r13d,%eax
    1f22:	4c 89 e7             	mov    %r12,%rdi
    1f25:	4c 89 f1             	mov    %r14,%rcx
    1f28:	f3 ab                	rep stos %eax,%es:(%rdi)
            if( counter < model->num_counters_core) {
    1f2a:	8b 42 28             	mov    0x28(%rdx),%eax
    1f2d:	39 45 ac             	cmp    %eax,-0x54(%rbp)
    1f30:	0f 8c bc 01 00 00    	jl     20f2 <init_module+0x402>
                sprintf(namebuf,"incore_counter%d",counter);
            }
            if( counter >= model->num_counters_core) {
                sprintf(namebuf, "uncore_counter%d",counter- model->num_counters_core);
    1f36:	8b 55 ac             	mov    -0x54(%rbp),%edx
    1f39:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    1f40:	4c 89 e7             	mov    %r12,%rdi
    1f43:	29 c2                	sub    %eax,%edx
    1f45:	31 c0                	xor    %eax,%eax
    1f47:	e8 00 00 00 00       	callq  1f4c <init_module+0x25c>
            }
            counter_dir[cpu][counter]        = proc_mkdir(namebuf,core_dir[cpu]);
    1f4c:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
    1f50:	4c 89 e7             	mov    %r12,%rdi
    1f53:	48 8b 34 d5 00 00 00 	mov    0x0(,%rdx,8),%rsi
    1f5a:	00 
    1f5b:	e8 00 00 00 00       	callq  1f60 <init_module+0x270>
    1f60:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
            if(!counter_dir[cpu][counter]){
    1f64:	48 85 c0             	test   %rax,%rax
                sprintf(namebuf,"incore_counter%d",counter);
            }
            if( counter >= model->num_counters_core) {
                sprintf(namebuf, "uncore_counter%d",counter- model->num_counters_core);
            }
            counter_dir[cpu][counter]        = proc_mkdir(namebuf,core_dir[cpu]);
    1f67:	48 89 02             	mov    %rax,(%rdx)
            if(!counter_dir[cpu][counter]){
    1f6a:	0f 84 64 01 00 00    	je     20d4 <init_module+0x3e4>
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }

            mix_cpu_counter[cpu][counter] = topmc_mix16to32((unsigned short)cpu, (unsigned short)counter);
    1f70:	8b 75 ac             	mov    -0x54(%rbp),%esi
    1f73:	8b bd 7c ff ff ff    	mov    -0x84(%rbp),%edi
    1f79:	e8 00 00 00 00       	callq  1f7e <init_module+0x28e>
    1f7e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
            entry[cpu][counter][0]   = proc_create_data("enable",0666,counter_dir[cpu][counter], &topmc_enable_fops, &mix_cpu_counter[cpu][counter]);
    1f82:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    1f86:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    1f8d:	be b6 01 00 00       	mov    $0x1b6,%esi
    1f92:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }

            mix_cpu_counter[cpu][counter] = topmc_mix16to32((unsigned short)cpu, (unsigned short)counter);
    1f99:	89 02                	mov    %eax,(%rdx)
            entry[cpu][counter][0]   = proc_create_data("enable",0666,counter_dir[cpu][counter], &topmc_enable_fops, &mix_cpu_counter[cpu][counter]);
    1f9b:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    1f9f:	48 8b 10             	mov    (%rax),%rdx
    1fa2:	e8 00 00 00 00       	callq  1fa7 <init_module+0x2b7>
    1fa7:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
			//entry[cpu][counter][0]   = create_proc_entry("enable",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][0]){
    1fab:	48 85 c0             	test   %rax,%rax
                ret = -ENOMEM;
                return ret;
            }

            mix_cpu_counter[cpu][counter] = topmc_mix16to32((unsigned short)cpu, (unsigned short)counter);
            entry[cpu][counter][0]   = proc_create_data("enable",0666,counter_dir[cpu][counter], &topmc_enable_fops, &mix_cpu_counter[cpu][counter]);
    1fae:	48 89 42 f0          	mov    %rax,-0x10(%rdx)
			//entry[cpu][counter][0]   = create_proc_entry("enable",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][0]){
    1fb2:	0f 84 fe 00 00 00    	je     20b6 <init_module+0x3c6>
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }

            entry[cpu][counter][1]   = proc_create_data("event",0666,counter_dir[cpu][counter], &topmc_event_fops, &mix_cpu_counter[cpu][counter]);
    1fb8:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    1fbc:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    1fc0:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    1fc7:	be b6 01 00 00       	mov    $0x1b6,%esi
    1fcc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1fd3:	48 8b 10             	mov    (%rax),%rdx
    1fd6:	e8 00 00 00 00       	callq  1fdb <init_module+0x2eb>
    1fdb:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
			//entry[cpu][counter][1]   = create_proc_entry("event",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][1]){
    1fdf:	48 85 c0             	test   %rax,%rax
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }

            entry[cpu][counter][1]   = proc_create_data("event",0666,counter_dir[cpu][counter], &topmc_event_fops, &mix_cpu_counter[cpu][counter]);
    1fe2:	48 89 42 f8          	mov    %rax,-0x8(%rdx)
			//entry[cpu][counter][1]   = create_proc_entry("event",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][1]){
    1fe6:	0f 84 ca 00 00 00    	je     20b6 <init_module+0x3c6>
                printk("topmc_mod: create procfile %s error\n",namebuf);
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }
            entry[cpu][counter][2]   = proc_create_data("value",0666,counter_dir[cpu][counter], &topmc_value_fops, &mix_cpu_counter[cpu][counter]);
    1fec:	48 8b 45 98          	mov    -0x68(%rbp),%rax
    1ff0:	4c 8b 45 a0          	mov    -0x60(%rbp),%r8
    1ff4:	48 c7 c1 00 00 00 00 	mov    $0x0,%rcx
    1ffb:	be b6 01 00 00       	mov    $0x1b6,%esi
    2000:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2007:	48 8b 10             	mov    (%rax),%rdx
    200a:	e8 00 00 00 00       	callq  200f <init_module+0x31f>
    200f:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
    2013:	48 83 45 98 08       	addq   $0x8,-0x68(%rbp)
    2018:	48 83 45 a0 04       	addq   $0x4,-0x60(%rbp)
    201d:	48 83 45 80 04       	addq   $0x4,-0x80(%rbp)
    2022:	48 89 02             	mov    %rax,(%rdx)
    2025:	48 83 c2 18          	add    $0x18,%rdx
            //entry[cpu][counter][2]   = create_proc_entry("value",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][2]){
    2029:	48 85 c0             	test   %rax,%rax
                printk("topmc_mod: create procfile %s error\n",namebuf);
                topmc_proc_clean();
                ret = -ENOMEM;
                return ret;
            }
            entry[cpu][counter][2]   = proc_create_data("value",0666,counter_dir[cpu][counter], &topmc_value_fops, &mix_cpu_counter[cpu][counter]);
    202c:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
            //entry[cpu][counter][2]   = create_proc_entry("value",0666,counter_dir[cpu][counter]);
            if(entry[cpu][counter][2]){
    2030:	0f 84 80 00 00 00    	je     20b6 <init_module+0x3c6>
            topmc_proc_clean();
            ret = -ENOMEM;
            return ret;
        }

        for(counter=0;counter<model->num_counters_core+model->num_counters_uncore;counter++){
    2036:	83 45 ac 01          	addl   $0x1,-0x54(%rbp)
    203a:	e9 ca fe ff ff       	jmpq   1f09 <init_module+0x219>
#endif

    enable_entry   = proc_create_data("enable_all",0666,root_dir, &topmc_enable_all_fops, NULL);
	//enable_entry   = create_proc_entry("enable_all",0666,root_dir);
    if(enable_entry == NULL){
        remove_proc_entry("topmc",NULL);
    203f:	31 f6                	xor    %esi,%esi
    2041:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2048:	e8 00 00 00 00       	callq  204d <init_module+0x35d>
        ret = -ENOMEM;
        printk("topmc_mod: create enable_all entry error\n");
    204d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2054:	31 c0                	xor    %eax,%eax
    2056:	e8 00 00 00 00       	callq  205b <init_module+0x36b>
    205b:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
        return ret;
    2060:	e9 cd fd ff ff       	jmpq   1e32 <init_module+0x142>


    enable_all_cr4_pce_entry = proc_create_data("enable_cr4_pce", 0666, root_dir, &topmc_cr4_pce_fops, &enable_all_cr4_pce);
	//enable_all_cr4_pce_entry = create_proc_entry("enable_cr4_pce", 0666, root_dir);
    if(enable_all_cr4_pce_entry == NULL) {
        remove_proc_entry("topmc", NULL);
    2065:	31 f6                	xor    %esi,%esi
    2067:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    206e:	e8 00 00 00 00       	callq  2073 <init_module+0x383>
        ret = -ENOMEM;
        printk("topmc_mod: create enable_cr4_pce entry error\n");
    2073:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    207a:	31 c0                	xor    %eax,%eax
    207c:	e8 00 00 00 00       	callq  2081 <init_module+0x391>
    2081:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
        return ret;
    2086:	e9 a7 fd ff ff       	jmpq   1e32 <init_module+0x142>

    memset(topmc_procs,0,sizeof(topmc_procs));

    root_dir        = proc_mkdir("topmc",NULL);
    if(!root_dir){
        printk("mkprocdir topmc error\n");
    208b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2092:	e8 00 00 00 00       	callq  2097 <init_module+0x3a7>
    2097:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
        ret = -ENOMEM;
        return ret;
    209c:	e9 91 fd ff ff       	jmpq   1e32 <init_module+0x142>
    printk("+->topmc_init() start...\n");

    topmc_model_detect();
    if(!model)
    {
        printk("The processor is not supported yet.\n");
    20a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20a8:	31 c0                	xor    %eax,%eax
    20aa:	e8 00 00 00 00       	callq  20af <init_module+0x3bf>
    20af:	31 c0                	xor    %eax,%eax
        return ret;
    20b1:	e9 7c fd ff ff       	jmpq   1e32 <init_module+0x142>
                //entry[cpu][counter][2]->data                     = &mix_cpu_counter[cpu][counter];
                //entry[cpu][counter][2]->read_proc        = topmc_value_read;
                //entry[cpu][counter][2]->write_proc       = topmc_value_write;
            }
            else {
                printk("topmc_mod: create procfile %s error\n",namebuf);
    20b6:	4c 89 e6             	mov    %r12,%rsi
    20b9:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20c0:	e8 00 00 00 00       	callq  20c5 <init_module+0x3d5>
                topmc_proc_clean();
    20c5:	e8 00 00 00 00       	callq  20ca <init_module+0x3da>
    20ca:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
                ret = -ENOMEM;
                return ret;
    20cf:	e9 5e fd ff ff       	jmpq   1e32 <init_module+0x142>
            if( counter >= model->num_counters_core) {
                sprintf(namebuf, "uncore_counter%d",counter- model->num_counters_core);
            }
            counter_dir[cpu][counter]        = proc_mkdir(namebuf,core_dir[cpu]);
            if(!counter_dir[cpu][counter]){
                printk("mkprocdir %s  error\n",namebuf);
    20d4:	4c 89 e6             	mov    %r12,%rsi
    20d7:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    20de:	e8 00 00 00 00       	callq  20e3 <init_module+0x3f3>
                topmc_proc_clean();
    20e3:	e8 00 00 00 00       	callq  20e8 <init_module+0x3f8>
    20e8:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
                ret = -ENOMEM;
                return ret;
    20ed:	e9 40 fd ff ff       	jmpq   1e32 <init_module+0x142>
        }

        for(counter=0;counter<model->num_counters_core+model->num_counters_uncore;counter++){
            memset(namebuf,0,TOPMC_MAX_NAMELEN);
            if( counter < model->num_counters_core) {
                sprintf(namebuf,"incore_counter%d",counter);
    20f2:	8b 55 ac             	mov    -0x54(%rbp),%edx
    20f5:	31 c0                	xor    %eax,%eax
    20f7:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    20fe:	4c 89 e7             	mov    %r12,%rdi
    2101:	e8 00 00 00 00       	callq  2106 <init_module+0x416>
            }
            if( counter >= model->num_counters_core) {
    2106:	48 8b 05 00 00 00 00 	mov    0x0(%rip),%rax        # 210d <init_module+0x41d>
    210d:	8b 40 28             	mov    0x28(%rax),%eax
    2110:	39 45 ac             	cmp    %eax,-0x54(%rbp)
    2113:	0f 8c 33 fe ff ff    	jl     1f4c <init_module+0x25c>
    2119:	e9 18 fe ff ff       	jmpq   1f36 <init_module+0x246>
        printk("+->topmc_init(): cpu:%d\n",cpu);
        memset(namebuf,0,TOPMC_MAX_NAMELEN);
        sprintf(namebuf,"core%02d",cpu);
        core_dir[cpu]        = proc_mkdir(namebuf,root_dir);
        if(!core_dir[cpu]){
            printk("mkprocdir %s  error\n",namebuf);
    211e:	4c 89 e6             	mov    %r12,%rsi
    2121:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2128:	31 c0                	xor    %eax,%eax
    212a:	e8 00 00 00 00       	callq  212f <init_module+0x43f>
            topmc_proc_clean();
    212f:	e8 00 00 00 00       	callq  2134 <init_module+0x444>
    2134:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
            ret = -ENOMEM;
            return ret;
    2139:	e9 f4 fc ff ff       	jmpq   1e32 <init_module+0x142>
    213e:	66 90                	xchg   %ax,%ax

0000000000002140 <topmc_enable_rdpmc>:
	return;
}


void topmc_enable_rdpmc(void)
{
    2140:	55                   	push   %rbp
    2141:	48 89 e5             	mov    %rsp,%rbp
    2144:	48 83 ec 20          	sub    $0x20,%rsp
    2148:	48 89 5d f0          	mov    %rbx,-0x10(%rbp)
    214c:	4c 89 65 f8          	mov    %r12,-0x8(%rbp)
    2150:	e8 00 00 00 00       	callq  2155 <topmc_enable_rdpmc+0x15>
    2155:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 215c <topmc_enable_rdpmc+0x1c>
    215c:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    2161:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 2168 <topmc_enable_rdpmc+0x28>
    2168:	83 c3 01             	add    $0x1,%ebx
    216b:	4c 89 e7             	mov    %r12,%rdi
    216e:	48 63 d3             	movslq %ebx,%rdx
    2171:	e8 00 00 00 00       	callq  2176 <topmc_enable_rdpmc+0x36>
	int cpu;
    unsigned long cr4;
    int val = 0;

    val = 1;
	for_each_online_cpu(cpu) {
    2176:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 217c <topmc_enable_rdpmc+0x3c>
    217c:	89 c3                	mov    %eax,%ebx
    217e:	7c 0a                	jl     218a <topmc_enable_rdpmc+0x4a>
		topmc_write_cr4_pce(cpu, val);
        cr4 = read_cr4();
		printk("topmc_enable_rdpmc:cpu=%d, cr4:%lx\n",cpu,cr4);
	}

}
    2180:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    2184:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
    2188:	c9                   	leaveq 
    2189:	c3                   	retq   
    unsigned long cr4;
    int val = 0;

    val = 1;
	for_each_online_cpu(cpu) {
		topmc_write_cr4_pce(cpu, val);
    218a:	be 01 00 00 00       	mov    $0x1,%esi
    218f:	89 c7                	mov    %eax,%edi
    2191:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
    2195:	e8 00 00 00 00       	callq  219a <topmc_enable_rdpmc+0x5a>
}

static inline unsigned long native_read_cr4(void)
{
	unsigned long val;
	asm volatile("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
    219a:	0f 20 e2             	mov    %cr4,%rdx
        cr4 = read_cr4();
		printk("topmc_enable_rdpmc:cpu=%d, cr4:%lx\n",cpu,cr4);
    219d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
    21a1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    21a8:	89 c6                	mov    %eax,%esi
    21aa:	31 c0                	xor    %eax,%eax
    21ac:	e8 00 00 00 00       	callq  21b1 <topmc_enable_rdpmc+0x71>
    21b1:	eb ae                	jmp    2161 <topmc_enable_rdpmc+0x21>
    21b3:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    21ba:	84 00 00 00 00 00 

00000000000021c0 <topmc_cr4_pce_write>:

    return count;
}

int topmc_cr4_pce_write(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    21c0:	55                   	push   %rbp
    21c1:	48 89 e5             	mov    %rsp,%rbp
    21c4:	48 83 ec 20          	sub    $0x20,%rsp
    21c8:	48 89 1c 24          	mov    %rbx,(%rsp)
    21cc:	4c 89 64 24 08       	mov    %r12,0x8(%rsp)
    21d1:	4c 89 6c 24 10       	mov    %r13,0x10(%rsp)
    21d6:	4c 89 74 24 18       	mov    %r14,0x18(%rsp)
    21db:	e8 00 00 00 00       	callq  21e0 <topmc_cr4_pce_write+0x20>
    unsigned int sum = 0;
    unsigned int pce;
    char* str = (char*) data;
    long ret;

    ret = strncpy_from_user(str, buffer, count);
    21e0:	48 89 cf             	mov    %rcx,%rdi

    return count;
}

int topmc_cr4_pce_write(struct file *file, const char __user *buffer, unsigned long count, void *data)
{
    21e3:	48 89 d3             	mov    %rdx,%rbx
    21e6:	49 89 cc             	mov    %rcx,%r12
    unsigned int sum = 0;
    unsigned int pce;
    char* str = (char*) data;
    long ret;

    ret = strncpy_from_user(str, buffer, count);
    21e9:	e8 00 00 00 00       	callq  21ee <topmc_cr4_pce_write+0x2e>
    if(ret < 0)
    21ee:	48 85 c0             	test   %rax,%rax
    21f1:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
    21f6:	79 18                	jns    2210 <topmc_cr4_pce_write+0x50>
    for_each_online_cpu(cpu) {
        TOPMC_WRITE_CR4_PCE(cpu, pce);
    }

    return count;
}
    21f8:	89 d0                	mov    %edx,%eax
    21fa:	48 8b 1c 24          	mov    (%rsp),%rbx
    21fe:	4c 8b 64 24 08       	mov    0x8(%rsp),%r12
    2203:	4c 8b 6c 24 10       	mov    0x10(%rsp),%r13
    2208:	4c 8b 74 24 18       	mov    0x18(%rsp),%r14
    220d:	c9                   	leaveq 
    220e:	c3                   	retq   
    220f:	90                   	nop
    long ret;

    ret = strncpy_from_user(str, buffer, count);
    if(ret < 0)
        return -EFAULT;
    if(ret ==0 || ret > count)
    2210:	48 39 d8             	cmp    %rbx,%rax
    2213:	0f 87 87 00 00 00    	ja     22a0 <topmc_cr4_pce_write+0xe0>
    2219:	48 85 c0             	test   %rax,%rax
    221c:	0f 84 7e 00 00 00    	je     22a0 <topmc_cr4_pce_write+0xe0>
        return -EINVAL;

    for(i=0; i<count-1; i++) {
    2222:	48 89 d9             	mov    %rbx,%rcx
    2225:	45 31 ed             	xor    %r13d,%r13d
    2228:	48 83 e9 01          	sub    $0x1,%rcx
    222c:	74 24                	je     2252 <topmc_cr4_pce_write+0x92>
    222e:	31 d2                	xor    %edx,%edx
    2230:	31 c0                	xor    %eax,%eax
    2232:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        sum = sum*10+ str[i] - '0';
    2238:	41 0f be 14 14       	movsbl (%r12,%rdx,1),%edx
    223d:	47 8d 6c ad 00       	lea    0x0(%r13,%r13,4),%r13d
    if(ret < 0)
        return -EFAULT;
    if(ret ==0 || ret > count)
        return -EINVAL;

    for(i=0; i<count-1; i++) {
    2242:	83 c0 01             	add    $0x1,%eax
        sum = sum*10+ str[i] - '0';
    2245:	46 8d 6c 6a d0       	lea    -0x30(%rdx,%r13,2),%r13d
    if(ret < 0)
        return -EFAULT;
    if(ret ==0 || ret > count)
        return -EINVAL;

    for(i=0; i<count-1; i++) {
    224a:	48 63 d0             	movslq %eax,%rdx
    224d:	48 39 ca             	cmp    %rcx,%rdx
    2250:	72 e6                	jb     2238 <topmc_cr4_pce_write+0x78>
    2252:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 2259 <topmc_cr4_pce_write+0x99>
    2259:	41 be ff ff ff ff    	mov    $0xffffffff,%r14d
        pce = 1;
    } else {
        pce = 0;
    }

    for_each_online_cpu(cpu) {
    225f:	eb 17                	jmp    2278 <topmc_cr4_pce_write+0xb8>
    2261:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        TOPMC_WRITE_CR4_PCE(cpu, pce);
    2268:	31 f6                	xor    %esi,%esi
    226a:	45 85 ed             	test   %r13d,%r13d
    226d:	89 c7                	mov    %eax,%edi
    226f:	40 0f 95 c6          	setne  %sil
    2273:	e8 00 00 00 00       	callq  2278 <topmc_cr4_pce_write+0xb8>
    2278:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 227f <topmc_cr4_pce_write+0xbf>
    227f:	41 83 c6 01          	add    $0x1,%r14d
    2283:	4c 89 e7             	mov    %r12,%rdi
    2286:	49 63 d6             	movslq %r14d,%rdx
    2289:	e8 00 00 00 00       	callq  228e <topmc_cr4_pce_write+0xce>
        pce = 1;
    } else {
        pce = 0;
    }

    for_each_online_cpu(cpu) {
    228e:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 2294 <topmc_cr4_pce_write+0xd4>
    2294:	41 89 c6             	mov    %eax,%r14d
    2297:	7c cf                	jl     2268 <topmc_cr4_pce_write+0xa8>
        TOPMC_WRITE_CR4_PCE(cpu, pce);
    }

    return count;
    2299:	89 da                	mov    %ebx,%edx
    229b:	e9 58 ff ff ff       	jmpq   21f8 <topmc_cr4_pce_write+0x38>
    long ret;

    ret = strncpy_from_user(str, buffer, count);
    if(ret < 0)
        return -EFAULT;
    if(ret ==0 || ret > count)
    22a0:	ba ea ff ff ff       	mov    $0xffffffea,%edx
    22a5:	e9 4e ff ff ff       	jmpq   21f8 <topmc_cr4_pce_write+0x38>
    22aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000022b0 <topmc_cr4_pce_read>:
EXPORT_SYMBOL(topmc_pmc_cnt_bitmap);
EXPORT_SYMBOL(topmc_pmc_chg);
*/

int topmc_cr4_pce_read(char *page, char **start, off_t off, int count, int *eof, void *data)
{
    22b0:	55                   	push   %rbp
    22b1:	48 89 e5             	mov    %rsp,%rbp
    22b4:	41 57                	push   %r15
    22b6:	41 56                	push   %r14
    22b8:	41 55                	push   %r13
    22ba:	41 54                	push   %r12
    22bc:	53                   	push   %rbx
    22bd:	48 83 ec 18          	sub    $0x18,%rsp
    22c1:	e8 00 00 00 00       	callq  22c6 <topmc_cr4_pce_read+0x16>
    22c6:	4c 8b 25 00 00 00 00 	mov    0x0(%rip),%r12        # 22cd <topmc_cr4_pce_read+0x1d>
    22cd:	bb 01 00 00 00       	mov    $0x1,%ebx
    22d2:	41 bf ff ff ff ff    	mov    $0xffffffff,%r15d
    22d8:	49 89 fe             	mov    %rdi,%r14
    int cpu;
    int pce;
    int is_set=1;

    for_each_online_cpu(cpu) {
        TOPMC_READ_CR4_PCE(cpu, pce);
    22db:	4c 8d 6d cc          	lea    -0x34(%rbp),%r13
{
    int cpu;
    int pce;
    int is_set=1;

    for_each_online_cpu(cpu) {
    22df:	eb 14                	jmp    22f5 <topmc_cr4_pce_read+0x45>
    22e1:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
        TOPMC_READ_CR4_PCE(cpu, pce);
    22e8:	4c 89 ee             	mov    %r13,%rsi
    22eb:	89 c7                	mov    %eax,%edi
    22ed:	e8 00 00 00 00       	callq  22f2 <topmc_cr4_pce_read+0x42>
        is_set &= pce;
    22f2:	23 5d cc             	and    -0x34(%rbp),%ebx
    22f5:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 22fc <topmc_cr4_pce_read+0x4c>
    22fc:	41 83 c7 01          	add    $0x1,%r15d
    2300:	4c 89 e7             	mov    %r12,%rdi
    2303:	49 63 d7             	movslq %r15d,%rdx
    2306:	e8 00 00 00 00       	callq  230b <topmc_cr4_pce_read+0x5b>
{
    int cpu;
    int pce;
    int is_set=1;

    for_each_online_cpu(cpu) {
    230b:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 2311 <topmc_cr4_pce_read+0x61>
    2311:	41 89 c7             	mov    %eax,%r15d
    2314:	7c d2                	jl     22e8 <topmc_cr4_pce_read+0x38>
        TOPMC_READ_CR4_PCE(cpu, pce);
        is_set &= pce;
    }
    count = sprintf(page, "%d\n", is_set);
    2316:	89 da                	mov    %ebx,%edx
    2318:	4c 89 f7             	mov    %r14,%rdi
    231b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
    2322:	31 c0                	xor    %eax,%eax
    2324:	e8 00 00 00 00       	callq  2329 <topmc_cr4_pce_read+0x79>

    return count;
}
    2329:	48 83 c4 18          	add    $0x18,%rsp
    232d:	5b                   	pop    %rbx
    232e:	41 5c                	pop    %r12
    2330:	41 5d                	pop    %r13
    2332:	41 5e                	pop    %r14
    2334:	41 5f                	pop    %r15
    2336:	c9                   	leaveq 
    2337:	c3                   	retq   
    2338:	90                   	nop
    2339:	90                   	nop
    233a:	90                   	nop
    233b:	90                   	nop
    233c:	90                   	nop
    233d:	90                   	nop
    233e:	90                   	nop
    233f:	90                   	nop

0000000000002340 <topmc_mix16to32>:
//#include <asm/system.h>	//2.6.32

#define TOLOWER(x) ((x) | 0x20)

unsigned int topmc_mix16to32(unsigned short high,unsigned short low)
{
    2340:	55                   	push   %rbp
    2341:	48 89 e5             	mov    %rsp,%rbp
    2344:	e8 00 00 00 00       	callq  2349 <topmc_mix16to32+0x9>
        mix     = (unsigned int)high;
        mix     = mix<<16;
        mix     = mix | (unsigned int)low;

        return mix;
}
    2349:	c9                   	leaveq 
unsigned int topmc_mix16to32(unsigned short high,unsigned short low)
{
        unsigned int mix;
        
        mix     = (unsigned int)high;
        mix     = mix<<16;
    234a:	c1 e7 10             	shl    $0x10,%edi
    234d:	0f b7 c6             	movzwl %si,%eax
    2350:	09 f8                	or     %edi,%eax
        mix     = mix | (unsigned int)low;

        return mix;
}
    2352:	c3                   	retq   
    2353:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    235a:	84 00 00 00 00 00 

0000000000002360 <topmc_split32to16>:
        

void topmc_split32to16(unsigned int mix,unsigned short *high,unsigned short *low)
{       
    2360:	55                   	push   %rbp
    2361:	48 89 e5             	mov    %rsp,%rbp
    2364:	e8 00 00 00 00       	callq  2369 <topmc_split32to16+0x9>
        *low    = (unsigned short)mix;
    2369:	66 89 3a             	mov    %di,(%rdx)
        *high   = (unsigned short)(mix>>16);
    236c:	c1 ef 10             	shr    $0x10,%edi
    236f:	66 89 3e             	mov    %di,(%rsi)
}
    2372:	c9                   	leaveq 
    2373:	c3                   	retq   
    2374:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
    237b:	00 00 00 00 00 

0000000000002380 <topmc_str2int>:
 * @count: number of character, 0 stands for all of the string
 * @base: The number base to use
 */

unsigned int topmc_str2int(const char *cp,unsigned int count,unsigned int base)
{
    2380:	55                   	push   %rbp
    2381:	48 89 e5             	mov    %rsp,%rbp
    2384:	e8 00 00 00 00       	callq  2389 <topmc_str2int+0x9>
        int i=0;
        unsigned int result = 0,value;
                        
        if (!base) {
    2389:	85 d2                	test   %edx,%edx
    238b:	75 23                	jne    23b0 <topmc_str2int+0x30>
                base = 10;
                if (*cp == '0') {
    238d:	0f b6 0f             	movzbl (%rdi),%ecx
    2390:	80 f9 30             	cmp    $0x30,%cl
    2393:	0f 84 9f 00 00 00    	je     2438 <topmc_str2int+0xb8>
    2399:	0f b6 c1             	movzbl %cl,%eax
    239c:	b2 0a                	mov    $0xa,%dl
    239e:	44 0f b6 80 00 00 00 	movzbl 0x0(%rax),%r8d
    23a5:	00 
    23a6:	eb 1f                	jmp    23c7 <topmc_str2int+0x47>
    23a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    23af:	00 
                        if ((TOLOWER(*cp) == 'x') && isxdigit(cp[1])) {
                                cp++;
                                base = 16;
                        }
                }
        } else if (base == 16) {
    23b0:	83 fa 10             	cmp    $0x10,%edx
    23b3:	0f 84 af 00 00 00    	je     2468 <topmc_str2int+0xe8>
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
    23b9:	0f b6 0f             	movzbl (%rdi),%ecx
    23bc:	0f b6 c1             	movzbl %cl,%eax
    23bf:	44 0f b6 80 00 00 00 	movzbl 0x0(%rax),%r8d
    23c6:	00 
        }
        while (isxdigit(*cp) &&
    23c7:	45 0f b6 c0          	movzbl %r8b,%r8d
                                base = 16;
                        }
                }
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
    23cb:	31 c0                	xor    %eax,%eax
    23cd:	45 31 c9             	xor    %r9d,%r9d
        }
        while (isxdigit(*cp) &&
    23d0:	41 f6 c0 44          	test   $0x44,%r8b
    23d4:	74 4a                	je     2420 <topmc_str2int+0xa0>
                (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
    23d6:	41 83 e0 04          	and    $0x4,%r8d
    23da:	74 4c                	je     2428 <topmc_str2int+0xa8>
    23dc:	0f be c9             	movsbl %cl,%ecx
    23df:	83 e9 30             	sub    $0x30,%ecx
                }
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
        }
        while (isxdigit(*cp) &&
    23e2:	39 d1                	cmp    %edx,%ecx
    23e4:	73 3a                	jae    2420 <topmc_str2int+0xa0>
                (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
                result = result*base + value;
    23e6:	0f af c2             	imul   %edx,%eax
                cp++;
                if((count==0)||(++i<count))
    23e9:	85 f6                	test   %esi,%esi
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
        }
        while (isxdigit(*cp) &&
                (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
                result = result*base + value;
    23eb:	8d 04 01             	lea    (%rcx,%rax,1),%eax
                cp++;
                if((count==0)||(++i<count))
    23ee:	74 09                	je     23f9 <topmc_str2int+0x79>
    23f0:	41 83 c1 01          	add    $0x1,%r9d
    23f4:	44 39 ce             	cmp    %r9d,%esi
    23f7:	76 27                	jbe    2420 <topmc_str2int+0xa0>
                        cp += 2;
        }
        while (isxdigit(*cp) &&
                (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
                result = result*base + value;
                cp++;
    23f9:	48 83 c7 01          	add    $0x1,%rdi
    23fd:	0f b6 0f             	movzbl (%rdi),%ecx
    2400:	44 0f b6 c1          	movzbl %cl,%r8d
    2404:	45 0f b6 80 00 00 00 	movzbl 0x0(%r8),%r8d
    240b:	00 
                }
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
        }
        while (isxdigit(*cp) &&
    240c:	45 0f b6 c0          	movzbl %r8b,%r8d
    2410:	41 f6 c0 44          	test   $0x44,%r8b
    2414:	75 c0                	jne    23d6 <topmc_str2int+0x56>
    2416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    241d:	00 00 00 
                else
                        break;
        }

        return result;
}
    2420:	c9                   	leaveq 
    2421:	c3                   	retq   
    2422:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
        }
        while (isxdigit(*cp) &&
                (value = isdigit(*cp) ? *cp-'0' : TOLOWER(*cp)-'a'+10) < base) {
    2428:	83 c9 20             	or     $0x20,%ecx
    242b:	0f be c9             	movsbl %cl,%ecx
    242e:	83 e9 57             	sub    $0x57,%ecx
    2431:	eb af                	jmp    23e2 <topmc_str2int+0x62>
    2433:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
        if (!base) {
                base = 10;
                if (*cp == '0') {
                        base = 8;
                        cp++;
                        if ((TOLOWER(*cp) == 'x') && isxdigit(cp[1])) {
    2438:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
                        
        if (!base) {
                base = 10;
                if (*cp == '0') {
                        base = 8;
                        cp++;
    243c:	4c 8d 4f 01          	lea    0x1(%rdi),%r9
                        if ((TOLOWER(*cp) == 'x') && isxdigit(cp[1])) {
    2440:	89 c2                	mov    %eax,%edx
    2442:	83 ca 20             	or     $0x20,%edx
    2445:	80 fa 78             	cmp    $0x78,%dl
    2448:	74 42                	je     248c <topmc_str2int+0x10c>
    244a:	0f b6 d0             	movzbl %al,%edx
    244d:	89 c1                	mov    %eax,%ecx
    244f:	4c 89 cf             	mov    %r9,%rdi
    2452:	44 0f b6 82 00 00 00 	movzbl 0x0(%rdx),%r8d
    2459:	00 
    245a:	ba 08 00 00 00       	mov    $0x8,%edx
    245f:	e9 63 ff ff ff       	jmpq   23c7 <topmc_str2int+0x47>
    2464:	0f 1f 40 00          	nopl   0x0(%rax)
                                cp++;
                                base = 16;
                        }
                }
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
    2468:	0f b6 0f             	movzbl (%rdi),%ecx
    246b:	80 f9 30             	cmp    $0x30,%cl
    246e:	0f 85 48 ff ff ff    	jne    23bc <topmc_str2int+0x3c>
    2474:	0f b6 47 01          	movzbl 0x1(%rdi),%eax
    2478:	83 c8 20             	or     $0x20,%eax
    247b:	3c 78                	cmp    $0x78,%al
    247d:	74 30                	je     24af <topmc_str2int+0x12f>
    247f:	44 0f b6 05 00 00 00 	movzbl 0x0(%rip),%r8d        # 2487 <topmc_str2int+0x107>
    2486:	00 
    2487:	e9 3b ff ff ff       	jmpq   23c7 <topmc_str2int+0x47>
        if (!base) {
                base = 10;
                if (*cp == '0') {
                        base = 8;
                        cp++;
                        if ((TOLOWER(*cp) == 'x') && isxdigit(cp[1])) {
    248c:	48 83 c7 02          	add    $0x2,%rdi
    2490:	0f b6 0f             	movzbl (%rdi),%ecx
    2493:	0f b6 d1             	movzbl %cl,%edx
    2496:	44 0f b6 82 00 00 00 	movzbl 0x0(%rdx),%r8d
    249d:	00 
    249e:	ba 10 00 00 00       	mov    $0x10,%edx
    24a3:	41 f6 c0 44          	test   $0x44,%r8b
    24a7:	0f 85 1a ff ff ff    	jne    23c7 <topmc_str2int+0x47>
    24ad:	eb 9b                	jmp    244a <topmc_str2int+0xca>
                                base = 16;
                        }
                }
        } else if (base == 16) {
                if (cp[0] == '0' && TOLOWER(cp[1]) == 'x')
                        cp += 2;
    24af:	48 83 c7 02          	add    $0x2,%rdi
    24b3:	e9 01 ff ff ff       	jmpq   23b9 <topmc_str2int+0x39>
    24b8:	90                   	nop
    24b9:	90                   	nop
    24ba:	90                   	nop
    24bb:	90                   	nop
    24bc:	90                   	nop
    24bd:	90                   	nop
    24be:	90                   	nop
    24bf:	90                   	nop

00000000000024c0 <topmc_rdmsr_smp>:
    u32 low;
    u32 high;
};

static void topmc_rdmsr_smp(void *cmd_block)
{
    24c0:	55                   	push   %rbp
    24c1:	48 89 e5             	mov    %rsp,%rbp
    24c4:	e8 00 00 00 00       	callq  24c9 <topmc_rdmsr_smp+0x9>
    struct topmc_msr_command *cmd = (struct topmc_msr_command *)cmd_block;

    if (cmd->cpu == smp_processor_id()) {
    24c9:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    24d0:	00 
    24d1:	39 07                	cmp    %eax,(%rdi)
    24d3:	74 0b                	je     24e0 <topmc_rdmsr_smp+0x20>
        rdmsr(cmd->reg, cmd->low, cmd->high);
    }
} 
    24d5:	c9                   	leaveq 
    24d6:	c3                   	retq   
    24d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    24de:	00 00 

static inline unsigned long long native_read_msr(unsigned int msr)
{
	DECLARE_ARGS(val, low, high);

	asm volatile("rdmsr" : EAX_EDX_RET(val, low, high) : "c" (msr));
    24e0:	8b 4f 08             	mov    0x8(%rdi),%ecx
    24e3:	0f 32                	rdmsr  
	return EAX_EDX_VAL(val, low, high);
    24e5:	48 c1 e2 20          	shl    $0x20,%rdx
    24e9:	89 c0                	mov    %eax,%eax
    24eb:	48 09 c2             	or     %rax,%rdx
static void topmc_rdmsr_smp(void *cmd_block)
{
    struct topmc_msr_command *cmd = (struct topmc_msr_command *)cmd_block;

    if (cmd->cpu == smp_processor_id()) {
        rdmsr(cmd->reg, cmd->low, cmd->high);
    24ee:	89 57 0c             	mov    %edx,0xc(%rdi)
    24f1:	48 c1 ea 20          	shr    $0x20,%rdx
    24f5:	89 57 10             	mov    %edx,0x10(%rdi)
    }
} 
    24f8:	c9                   	leaveq 
    24f9:	c3                   	retq   
    24fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000002500 <topmc_wrmsr_smp>:
    }
    preempt_enable();
}

static void topmc_wrmsr_smp(void *cmd_block)
{
    2500:	55                   	push   %rbp
    2501:	48 89 e5             	mov    %rsp,%rbp
    2504:	e8 00 00 00 00       	callq  2509 <topmc_wrmsr_smp+0x9>
    struct topmc_msr_command *cmd = (struct topmc_msr_command *)cmd_block;

    if (cmd->cpu == smp_processor_id()) {
    2509:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    2510:	00 
    2511:	39 07                	cmp    %eax,(%rdi)
    2513:	74 0b                	je     2520 <topmc_wrmsr_smp+0x20>
        wrmsr(cmd->reg, cmd->low, cmd->high);
    }
}
    2515:	c9                   	leaveq 
    2516:	c3                   	retq   
    2517:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    251e:	00 00 
}

static inline void native_write_msr(unsigned int msr,
				    unsigned low, unsigned high)
{
	asm volatile("wrmsr" : : "c" (msr), "a"(low), "d" (high) : "memory");
    2520:	8b 4f 08             	mov    0x8(%rdi),%ecx
    2523:	8b 47 0c             	mov    0xc(%rdi),%eax
    2526:	8b 57 10             	mov    0x10(%rdi),%edx
    2529:	0f 30                	wrmsr  
    252b:	c9                   	leaveq 
    252c:	c3                   	retq   
    252d:	0f 1f 00             	nopl   (%rax)

0000000000002530 <topmc_wrmsr>:

void topmc_wrmsr(int cpu, u32 reg, u32 low, u32 high)
{
    2530:	55                   	push   %rbp
    2531:	48 89 e5             	mov    %rsp,%rbp
    2534:	48 83 ec 20          	sub    $0x20,%rsp
    2538:	e8 00 00 00 00       	callq  253d <topmc_wrmsr+0xd>
    253d:	89 d0                	mov    %edx,%eax
    253f:	41 89 c8             	mov    %ecx,%r8d
    struct topmc_msr_command cmd;

    preempt_disable();
    if (cpu == smp_processor_id()) {
    2542:	65 8b 14 25 00 00 00 	mov    %gs:0x0,%edx
    2549:	00 
    254a:	39 fa                	cmp    %edi,%edx
    254c:	74 2a                	je     2578 <topmc_wrmsr+0x48>
        wrmsr(reg, low, high);
    } else {
        cmd.cpu = cpu;
        cmd.reg = reg;
    254e:	89 75 e8             	mov    %esi,-0x18(%rbp)
        cmd.low = low;
        cmd.high = high;

        smp_call_function(topmc_wrmsr_smp, &cmd, 1);
    2551:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi

    preempt_disable();
    if (cpu == smp_processor_id()) {
        wrmsr(reg, low, high);
    } else {
        cmd.cpu = cpu;
    2555:	89 7d e0             	mov    %edi,-0x20(%rbp)
        cmd.reg = reg;
        cmd.low = low;
        cmd.high = high;

        smp_call_function(topmc_wrmsr_smp, &cmd, 1);
    2558:	ba 01 00 00 00       	mov    $0x1,%edx
    255d:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    if (cpu == smp_processor_id()) {
        wrmsr(reg, low, high);
    } else {
        cmd.cpu = cpu;
        cmd.reg = reg;
        cmd.low = low;
    2564:	89 45 ec             	mov    %eax,-0x14(%rbp)
        cmd.high = high;
    2567:	89 4d f0             	mov    %ecx,-0x10(%rbp)

        smp_call_function(topmc_wrmsr_smp, &cmd, 1);
    256a:	e8 00 00 00 00       	callq  256f <topmc_wrmsr+0x3f>
    }
    preempt_enable();
}
    256f:	c9                   	leaveq 
    2570:	c3                   	retq   
    2571:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2578:	89 f1                	mov    %esi,%ecx
    257a:	44 89 c2             	mov    %r8d,%edx
    257d:	0f 30                	wrmsr  
    257f:	c9                   	leaveq 
    2580:	c3                   	retq   
    2581:	66 66 66 66 66 66 2e 	data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
    2588:	0f 1f 84 00 00 00 00 
    258f:	00 

0000000000002590 <topmc_rdmsr>:
        rdmsr(cmd->reg, cmd->low, cmd->high);
    }
} 

void topmc_rdmsr(int cpu, u32 reg, u32 *low, u32 *high)
{
    2590:	55                   	push   %rbp
    2591:	48 89 e5             	mov    %rsp,%rbp
    2594:	48 83 ec 30          	sub    $0x30,%rsp
    2598:	48 89 5d f0          	mov    %rbx,-0x10(%rbp)
    259c:	4c 89 65 f8          	mov    %r12,-0x8(%rbp)
    25a0:	e8 00 00 00 00       	callq  25a5 <topmc_rdmsr+0x15>
    25a5:	49 89 d4             	mov    %rdx,%r12
    25a8:	48 89 cb             	mov    %rcx,%rbx
    struct topmc_msr_command cmd;

    preempt_disable();
    if (cpu == smp_processor_id()) {
    25ab:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    25b2:	00 
    25b3:	39 f8                	cmp    %edi,%eax
    25b5:	74 39                	je     25f0 <topmc_rdmsr+0x60>
        rdmsr(reg, *low, *high);
    } else {
        cmd.cpu = cpu;
        cmd.reg = reg;
    25b7:	89 75 d8             	mov    %esi,-0x28(%rbp)

        smp_call_function(topmc_rdmsr_smp, &cmd, 1);
    25ba:	48 8d 75 d0          	lea    -0x30(%rbp),%rsi

    preempt_disable();
    if (cpu == smp_processor_id()) {
        rdmsr(reg, *low, *high);
    } else {
        cmd.cpu = cpu;
    25be:	89 7d d0             	mov    %edi,-0x30(%rbp)
        cmd.reg = reg;

        smp_call_function(topmc_rdmsr_smp, &cmd, 1);
    25c1:	ba 01 00 00 00       	mov    $0x1,%edx
    25c6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    25cd:	e8 00 00 00 00       	callq  25d2 <topmc_rdmsr+0x42>

        *low = cmd.low;
    25d2:	8b 45 dc             	mov    -0x24(%rbp),%eax
    25d5:	41 89 04 24          	mov    %eax,(%r12)
        *high = cmd.high;
    25d9:	8b 45 e0             	mov    -0x20(%rbp),%eax
    25dc:	89 03                	mov    %eax,(%rbx)
    }
    preempt_enable();
}
    25de:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    25e2:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
    25e6:	c9                   	leaveq 
    25e7:	c3                   	retq   
    25e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
    25ef:	00 

static inline unsigned long long native_read_msr(unsigned int msr)
{
	DECLARE_ARGS(val, low, high);

	asm volatile("rdmsr" : EAX_EDX_RET(val, low, high) : "c" (msr));
    25f0:	89 f1                	mov    %esi,%ecx
    25f2:	0f 32                	rdmsr  
	return EAX_EDX_VAL(val, low, high);
    25f4:	48 c1 e2 20          	shl    $0x20,%rdx
    25f8:	89 c0                	mov    %eax,%eax
    25fa:	48 09 c2             	or     %rax,%rdx
{
    struct topmc_msr_command cmd;

    preempt_disable();
    if (cpu == smp_processor_id()) {
        rdmsr(reg, *low, *high);
    25fd:	41 89 14 24          	mov    %edx,(%r12)
    2601:	48 c1 ea 20          	shr    $0x20,%rdx
    2605:	89 13                	mov    %edx,(%rbx)

        *low = cmd.low;
        *high = cmd.high;
    }
    preempt_enable();
}
    2607:	48 8b 5d f0          	mov    -0x10(%rbp),%rbx
    260b:	4c 8b 65 f8          	mov    -0x8(%rbp),%r12
    260f:	c9                   	leaveq 
    2610:	c3                   	retq   
    2611:	90                   	nop
    2612:	90                   	nop
    2613:	90                   	nop
    2614:	90                   	nop
    2615:	90                   	nop
    2616:	90                   	nop
    2617:	90                   	nop
    2618:	90                   	nop
    2619:	90                   	nop
    261a:	90                   	nop
    261b:	90                   	nop
    261c:	90                   	nop
    261d:	90                   	nop
    261e:	90                   	nop
    261f:	90                   	nop

0000000000002620 <topmc_read_cr4_pce_smp>:
    write_cr4(cr4);
    printk("+->core%d: clear cr4.pce (%lx)\n", smp_processor_id(), read_cr4());
}

static void topmc_read_cr4_pce_smp(void *cmd_block)
{
    2620:	55                   	push   %rbp
    2621:	48 89 e5             	mov    %rsp,%rbp
    2624:	e8 00 00 00 00       	callq  2629 <topmc_read_cr4_pce_smp+0x9>
    struct topmc_cr4_command *cmd = (struct topmc_cr4_command *)cmd_block;
    unsigned long cr4;
    int pce;

    if (cmd->cpu == smp_processor_id()) {
    2629:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    2630:	00 
    2631:	39 07                	cmp    %eax,(%rdi)
    2633:	74 0b                	je     2640 <topmc_read_cr4_pce_smp+0x20>
        cr4 = read_cr4();
        pce = (cr4 >> 8) & 0x1;
        cmd->data = pce;
    }
}
    2635:	c9                   	leaveq 
    2636:	c3                   	retq   
    2637:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    263e:	00 00 
    2640:	0f 20 e0             	mov    %cr4,%rax
    int pce;

    if (cmd->cpu == smp_processor_id()) {
        cr4 = read_cr4();
        pce = (cr4 >> 8) & 0x1;
        cmd->data = pce;
    2643:	48 c1 e8 08          	shr    $0x8,%rax
    2647:	83 e0 01             	and    $0x1,%eax
    264a:	89 47 04             	mov    %eax,0x4(%rdi)
    }
}
    264d:	c9                   	leaveq 
    264e:	c3                   	retq   
    264f:	90                   	nop

0000000000002650 <topmc_read_cr4_pce>:

void topmc_read_cr4_pce(int cpu, int *val) 
{
    2650:	55                   	push   %rbp
    2651:	48 89 e5             	mov    %rsp,%rbp
    2654:	53                   	push   %rbx
    2655:	48 83 ec 18          	sub    $0x18,%rsp
    2659:	e8 00 00 00 00       	callq  265e <topmc_read_cr4_pce+0xe>
    265e:	48 89 f3             	mov    %rsi,%rbx
    unsigned long cr4;
    int pce;
    struct topmc_cr4_command cmd;

    preempt_disable();
    if(cpu == smp_processor_id()) {
    2661:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    2668:	00 
    2669:	39 f8                	cmp    %edi,%eax
    266b:	74 2b                	je     2698 <topmc_read_cr4_pce+0x48>
        cr4 = read_cr4();
        pce = (cr4 >> 8) & 0x1;
    } else {
        cmd.cpu = cpu;
        smp_call_function(topmc_read_cr4_pce_smp, &cmd, 1);
    266d:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
    preempt_disable();
    if(cpu == smp_processor_id()) {
        cr4 = read_cr4();
        pce = (cr4 >> 8) & 0x1;
    } else {
        cmd.cpu = cpu;
    2671:	89 7d e0             	mov    %edi,-0x20(%rbp)
        smp_call_function(topmc_read_cr4_pce_smp, &cmd, 1);
    2674:	ba 01 00 00 00       	mov    $0x1,%edx
    2679:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2680:	e8 00 00 00 00       	callq  2685 <topmc_read_cr4_pce+0x35>
        pce = cmd.data;
    2685:	8b 45 e4             	mov    -0x1c(%rbp),%eax
    }
    preempt_enable();

    *val = pce;
    2688:	89 03                	mov    %eax,(%rbx)
}
    268a:	48 83 c4 18          	add    $0x18,%rsp
    268e:	5b                   	pop    %rbx
    268f:	c9                   	leaveq 
    2690:	c3                   	retq   
    2691:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
    2698:	0f 20 e0             	mov    %cr4,%rax
    struct topmc_cr4_command cmd;

    preempt_disable();
    if(cpu == smp_processor_id()) {
        cr4 = read_cr4();
        pce = (cr4 >> 8) & 0x1;
    269b:	48 c1 e8 08          	shr    $0x8,%rax
    269f:	83 e0 01             	and    $0x1,%eax
        smp_call_function(topmc_read_cr4_pce_smp, &cmd, 1);
        pce = cmd.data;
    }
    preempt_enable();

    *val = pce;
    26a2:	89 03                	mov    %eax,(%rbx)
}
    26a4:	48 83 c4 18          	add    $0x18,%rsp
    26a8:	5b                   	pop    %rbx
    26a9:	c9                   	leaveq 
    26aa:	c3                   	retq   
    26ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

00000000000026b0 <topmc_write_cr4_pce>:
        }
    }
}    

void topmc_write_cr4_pce(int cpu, int val) 
{ 
    26b0:	55                   	push   %rbp
    26b1:	48 89 e5             	mov    %rsp,%rbp
    26b4:	48 83 ec 10          	sub    $0x10,%rsp
    26b8:	e8 00 00 00 00       	callq  26bd <topmc_write_cr4_pce+0xd>
    struct topmc_cr4_command cmd;

    preempt_disable();
    if(cpu == smp_processor_id()) {
    26bd:	65 8b 04 25 00 00 00 	mov    %gs:0x0,%eax
    26c4:	00 
    26c5:	39 f8                	cmp    %edi,%eax
    26c7:	74 27                	je     26f0 <topmc_write_cr4_pce+0x40>
        } else {
            topmc_clear_cr4_pce();
        }
    } else {
        cmd.cpu = cpu;
        cmd.data = val;
    26c9:	89 75 f4             	mov    %esi,-0xc(%rbp)
        smp_call_function(topmc_write_cr4_pce_smp, &cmd, 1);
    26cc:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
            topmc_set_cr4_pce();
        } else {
            topmc_clear_cr4_pce();
        }
    } else {
        cmd.cpu = cpu;
    26d0:	89 7d f0             	mov    %edi,-0x10(%rbp)
        cmd.data = val;
        smp_call_function(topmc_write_cr4_pce_smp, &cmd, 1);
    26d3:	ba 01 00 00 00       	mov    $0x1,%edx
    26d8:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    26df:	e8 00 00 00 00       	callq  26e4 <topmc_write_cr4_pce+0x34>
    }
    preempt_enable();
}
    26e4:	c9                   	leaveq 
    26e5:	c3                   	retq   
    26e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    26ed:	00 00 00 
{ 
    struct topmc_cr4_command cmd;

    preempt_disable();
    if(cpu == smp_processor_id()) {
        if(val) { //enable
    26f0:	85 f6                	test   %esi,%esi
    26f2:	74 24                	je     2718 <topmc_write_cr4_pce+0x68>
    26f4:	0f 20 e2             	mov    %cr4,%rdx
	return val;
}

static inline void native_write_cr4(unsigned long val)
{
	asm volatile("mov %0,%%cr4": : "r" (val), "m" (__force_order));
    26f7:	80 ce 01             	or     $0x1,%dh
    26fa:	0f 22 e2             	mov    %rdx,%cr4
}

static inline unsigned long native_read_cr4(void)
{
	unsigned long val;
	asm volatile("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
    26fd:	0f 20 e2             	mov    %cr4,%rdx
    unsigned long cr4;

    cr4 = read_cr4();
    cr4 |= (1<<8);
    write_cr4(cr4);
    printk("+->core%d: set cr4.pce (%lx)\n", smp_processor_id(), read_cr4());
    2700:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    2707:	89 c6                	mov    %eax,%esi
    2709:	31 c0                	xor    %eax,%eax
    270b:	e8 00 00 00 00       	callq  2710 <topmc_write_cr4_pce+0x60>
        cmd.cpu = cpu;
        cmd.data = val;
        smp_call_function(topmc_write_cr4_pce_smp, &cmd, 1);
    }
    preempt_enable();
}
    2710:	c9                   	leaveq 
    2711:	c3                   	retq   
    2712:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
    2718:	0f 20 e2             	mov    %cr4,%rdx
	return val;
}

static inline void native_write_cr4(unsigned long val)
{
	asm volatile("mov %0,%%cr4": : "r" (val), "m" (__force_order));
    271b:	80 e6 fe             	and    $0xfe,%dh
    271e:	0f 22 e2             	mov    %rdx,%cr4
}

static inline unsigned long native_read_cr4(void)
{
	unsigned long val;
	asm volatile("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
    2721:	0f 20 e2             	mov    %cr4,%rdx
    unsigned long cr4;

    cr4 = read_cr4();
    cr4 &= ~(1<<8);
    write_cr4(cr4);
    printk("+->core%d: clear cr4.pce (%lx)\n", smp_processor_id(), read_cr4());
    2724:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    272b:	89 c6                	mov    %eax,%esi
    272d:	31 c0                	xor    %eax,%eax
    272f:	e8 00 00 00 00       	callq  2734 <topmc_write_cr4_pce+0x84>
        cmd.cpu = cpu;
        cmd.data = val;
        smp_call_function(topmc_write_cr4_pce_smp, &cmd, 1);
    }
    preempt_enable();
}
    2734:	c9                   	leaveq 
    2735:	c3                   	retq   
    2736:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
    273d:	00 00 00 

0000000000002740 <topmc_write_cr4_pce_smp>:

    *val = pce;
}

static void topmc_write_cr4_pce_smp(void *cmd_block)
{
    2740:	55                   	push   %rbp
    2741:	48 89 e5             	mov    %rsp,%rbp
    2744:	e8 00 00 00 00       	callq  2749 <topmc_write_cr4_pce_smp+0x9>
    struct topmc_cr4_command *cmd = (struct topmc_cr4_command *)cmd_block;

    if(cmd->cpu == smp_processor_id()) {
    2749:	65 8b 34 25 00 00 00 	mov    %gs:0x0,%esi
    2750:	00 
    2751:	39 37                	cmp    %esi,(%rdi)
    2753:	74 0b                	je     2760 <topmc_write_cr4_pce_smp+0x20>
            topmc_set_cr4_pce();
        } else {
            topmc_clear_cr4_pce();
        }
    }
}    
    2755:	c9                   	leaveq 
    2756:	c3                   	retq   
    2757:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
    275e:	00 00 
static void topmc_write_cr4_pce_smp(void *cmd_block)
{
    struct topmc_cr4_command *cmd = (struct topmc_cr4_command *)cmd_block;

    if(cmd->cpu == smp_processor_id()) {
        if(cmd->data) {
    2760:	8b 47 04             	mov    0x4(%rdi),%eax
    2763:	85 c0                	test   %eax,%eax
    2765:	75 21                	jne    2788 <topmc_write_cr4_pce_smp+0x48>
    2767:	0f 20 e0             	mov    %cr4,%rax
	return val;
}

static inline void native_write_cr4(unsigned long val)
{
	asm volatile("mov %0,%%cr4": : "r" (val), "m" (__force_order));
    276a:	80 e4 fe             	and    $0xfe,%ah
    276d:	0f 22 e0             	mov    %rax,%cr4
}

static inline unsigned long native_read_cr4(void)
{
	unsigned long val;
	asm volatile("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
    2770:	0f 20 e2             	mov    %cr4,%rdx
    unsigned long cr4;

    cr4 = read_cr4();
    cr4 &= ~(1<<8);
    write_cr4(cr4);
    printk("+->core%d: clear cr4.pce (%lx)\n", smp_processor_id(), read_cr4());
    2773:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    277a:	31 c0                	xor    %eax,%eax
    277c:	e8 00 00 00 00       	callq  2781 <topmc_write_cr4_pce_smp+0x41>
            topmc_set_cr4_pce();
        } else {
            topmc_clear_cr4_pce();
        }
    }
}    
    2781:	c9                   	leaveq 
    2782:	c3                   	retq   
    2783:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
    2788:	0f 20 e0             	mov    %cr4,%rax
	return val;
}

static inline void native_write_cr4(unsigned long val)
{
	asm volatile("mov %0,%%cr4": : "r" (val), "m" (__force_order));
    278b:	80 cc 01             	or     $0x1,%ah
    278e:	0f 22 e0             	mov    %rax,%cr4
}

static inline unsigned long native_read_cr4(void)
{
	unsigned long val;
	asm volatile("mov %%cr4,%0\n\t" : "=r" (val), "=m" (__force_order));
    2791:	0f 20 e2             	mov    %cr4,%rdx
    unsigned long cr4;

    cr4 = read_cr4();
    cr4 |= (1<<8);
    write_cr4(cr4);
    printk("+->core%d: set cr4.pce (%lx)\n", smp_processor_id(), read_cr4());
    2794:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    279b:	31 c0                	xor    %eax,%eax
    279d:	e8 00 00 00 00       	callq  27a2 <topmc_write_cr4_pce_smp+0x62>
            topmc_set_cr4_pce();
        } else {
            topmc_clear_cr4_pce();
        }
    }
}    
    27a2:	c9                   	leaveq 
    27a3:	c3                   	retq   

Disassembly of section .exit.text:

0000000000000000 <cleanup_module>:
}



void __exit topmc_cleanup(void )
{
   0:	55                   	push   %rbp
	printk("+->topmc_mod: unloaded\n");
   1:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
   8:	31 c0                	xor    %eax,%eax
}



void __exit topmc_cleanup(void )
{
   a:	48 89 e5             	mov    %rsp,%rbp
	printk("+->topmc_mod: unloaded\n");
   d:	e8 00 00 00 00       	callq  12 <cleanup_module+0x12>
	topmc_proc_clean();
  12:	e8 00 00 00 00       	callq  17 <cleanup_module+0x17>


}
  17:	c9                   	leaveq 
  18:	c3                   	retq   
