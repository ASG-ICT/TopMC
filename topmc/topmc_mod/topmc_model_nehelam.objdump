
topmc_model_nehelam.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <topmc_uncore_global_ctrl_init_nehelam>:
	}
}

/* initialization uncore global msrs*/
void topmc_uncore_global_ctrl_init_nehelam(void)
{
       0:	55                   	push   %rbp
       1:	48 89 e5             	mov    %rsp,%rbp
       4:	41 57                	push   %r15
       6:	41 56                	push   %r14
       8:	41 55                	push   %r13
       a:	41 54                	push   %r12
       c:	53                   	push   %rbx
       d:	48 83 ec 18          	sub    $0x18,%rsp
      11:	e8 00 00 00 00       	callq  16 <topmc_uncore_global_ctrl_init_nehelam+0x16>
static inline unsigned int cpumask_next(int n, const struct cpumask *srcp)
{
	/* -1 is a legal arg here. */
	if (n != -1)
		cpumask_check(n);
	return find_next_bit(cpumask_bits(srcp), nr_cpumask_bits, n+1);
      16:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      1b:	41 bf 01 00 00 00    	mov    $0x1,%r15d
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      21:	4c 8d 75 c8          	lea    -0x38(%rbp),%r14
      25:	4c 8d 6d cc          	lea    -0x34(%rbp),%r13
void topmc_uncore_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      29:	eb 63                	jmp    8e <topmc_uncore_global_ctrl_init_nehelam+0x8e>
      2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      30:	4c 89 f1             	mov    %r14,%rcx
      33:	4c 89 ea             	mov    %r13,%rdx
      36:	be 91 03 00 00       	mov    $0x391,%esi
      3b:	44 89 e7             	mov    %r12d,%edi
      3e:	e8 00 00 00 00       	callq  43 <topmc_uncore_global_ctrl_init_nehelam+0x43>
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      43:	89 d8                	mov    %ebx,%eax
		//mask |= 1ULL << ( 48 + cpu_data(smp_processor_id()).cpu_core_id);
		//      printk("+->topmc: topmc_uncore_global_ctrl_init(): global control mask-> %llu\n",mask);
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      45:	be 91 03 00 00       	mov    $0x391,%esi
      4a:	44 89 e7             	mov    %r12d,%edi
		// initialization global control msr
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
		mask &= 0ULL;
		mask |= ((1ULL << TOPMC_MSR_XEON55XX_UNC_BITS_NUM_PMC) - 1) << TOPMC_MSR_XEON55XX_UNC_IDX_PMC;
		mask |=  (1ULL << TOPMC_MSR_XEON55XX_UNC_IDX_FIXED);
		mask |= 1ULL <<( 48 + cpu%4);
      4d:	c1 f8 1f             	sar    $0x1f,%eax
      50:	c1 e8 1e             	shr    $0x1e,%eax
      53:	8d 14 03             	lea    (%rbx,%rax,1),%edx
      56:	83 e2 03             	and    $0x3,%edx
      59:	29 c2                	sub    %eax,%edx
      5b:	48 b8 ff 00 00 00 01 	mov    $0x1000000ff,%rax
      62:	00 00 00 
      65:	8d 4a 30             	lea    0x30(%rdx),%ecx
      68:	4c 89 fa             	mov    %r15,%rdx
      6b:	48 d3 e2             	shl    %cl,%rdx
      6e:	48 09 c2             	or     %rax,%rdx
		//mask |= 1ULL << ( 48 + cpu_data(smp_processor_id()).cpu_core_id);
		//      printk("+->topmc: topmc_uncore_global_ctrl_init(): global control mask-> %llu\n",mask);
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_CTRL, mask, cpu);
      71:	48 89 d1             	mov    %rdx,%rcx
      74:	48 c1 e9 20          	shr    $0x20,%rcx
      78:	e8 00 00 00 00       	callq  7d <topmc_uncore_global_ctrl_init_nehelam+0x7d>

		//initialization global global overflow control msr ----------not needed at the moment
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, 0ULL, cpu);
      7d:	31 c9                	xor    %ecx,%ecx
      7f:	31 d2                	xor    %edx,%edx
      81:	be 93 03 00 00       	mov    $0x393,%esi
      86:	44 89 e7             	mov    %r12d,%edi
      89:	e8 00 00 00 00       	callq  8e <topmc_uncore_global_ctrl_init_nehelam+0x8e>
      8e:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 95 <topmc_uncore_global_ctrl_init_nehelam+0x95>
      95:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 9c <topmc_uncore_global_ctrl_init_nehelam+0x9c>
      9c:	83 c3 01             	add    $0x1,%ebx
      9f:	48 63 d3             	movslq %ebx,%rdx
      a2:	e8 00 00 00 00       	callq  a7 <topmc_uncore_global_ctrl_init_nehelam+0xa7>
void topmc_uncore_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      a7:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # ad <topmc_uncore_global_ctrl_init_nehelam+0xad>
      ad:	49 89 c4             	mov    %rax,%r12
      b0:	89 c3                	mov    %eax,%ebx
      b2:	0f 8c 78 ff ff ff    	jl     30 <topmc_uncore_global_ctrl_init_nehelam+0x30>
		//initialization global global overflow control msr ----------not needed at the moment
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, 0ULL, cpu);
		//    TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_GLOBAL_OVF_CTRL, mask, cpu);
		//  printk("+->topmc: topmc_uncore_global_ctrl_init(): global overflowed control mask-> %llu\n",mask);
	}
}
      b8:	48 83 c4 18          	add    $0x18,%rsp
      bc:	5b                   	pop    %rbx
      bd:	41 5c                	pop    %r12
      bf:	41 5d                	pop    %r13
      c1:	41 5e                	pop    %r14
      c3:	41 5f                	pop    %r15
      c5:	c9                   	leaveq 
      c6:	c3                   	retq   
      c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
      ce:	00 00 

00000000000000d0 <topmc_core_global_ctrl_init_nehelam>:

	}
}

void topmc_core_global_ctrl_init_nehelam(void)
{
      d0:	55                   	push   %rbp
      d1:	48 89 e5             	mov    %rsp,%rbp
      d4:	41 57                	push   %r15
      d6:	41 56                	push   %r14
      d8:	41 55                	push   %r13
      da:	41 54                	push   %r12
      dc:	53                   	push   %rbx
      dd:	48 83 ec 18          	sub    $0x18,%rsp
      e1:	e8 00 00 00 00       	callq  e6 <topmc_core_global_ctrl_init_nehelam+0x16>
      e6:	4c 8b 3d 00 00 00 00 	mov    0x0(%rip),%r15        # ed <topmc_core_global_ctrl_init_nehelam+0x1d>
      ed:	41 bc ff ff ff ff    	mov    $0xffffffff,%r12d
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
      f3:	4c 8d 75 c8          	lea    -0x38(%rbp),%r14
      f7:	4c 8d 6d cc          	lea    -0x34(%rbp),%r13
void topmc_core_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
      fb:	eb 4f                	jmp    14c <topmc_core_global_ctrl_init_nehelam+0x7c>
      fd:	0f 1f 00             	nopl   (%rax)
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     100:	4c 89 f1             	mov    %r14,%rcx
     103:	4c 89 ea             	mov    %r13,%rdx
     106:	be 8f 03 00 00       	mov    $0x38f,%esi
     10b:	89 df                	mov    %ebx,%edi
     10d:	e8 00 00 00 00       	callq  112 <topmc_core_global_ctrl_init_nehelam+0x42>
		mask &=0ULL;
		mask |= ((1ULL << MSR_CORE_PERF_NUM_PMC) -1) << MSR_CORE_PERF_IDX_PMC;
		mask |= ((1ULL << MSR_CORE_PERF_NUM_FIX) -1) << MSR_CORE_PERF_IDX_FIX;
		TOPMC_WRMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     112:	b9 07 00 00 00       	mov    $0x7,%ecx
     117:	ba 0f 00 00 00       	mov    $0xf,%edx
     11c:	be 8f 03 00 00       	mov    $0x38f,%esi
     121:	89 df                	mov    %ebx,%edi
     123:	e8 00 00 00 00       	callq  128 <topmc_core_global_ctrl_init_nehelam+0x58>
		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_CTRL, mask, cpu);
     128:	4c 89 e9             	mov    %r13,%rcx
     12b:	4c 89 f2             	mov    %r14,%rdx
     12e:	be 8f 03 00 00       	mov    $0x38f,%esi
     133:	89 df                	mov    %ebx,%edi
     135:	e8 00 00 00 00       	callq  13a <topmc_core_global_ctrl_init_nehelam+0x6a>
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global control mask -> %llu\n", mask);

		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_OVF_CTRL, mask, cpu);
     13a:	4c 89 f1             	mov    %r14,%rcx
     13d:	4c 89 ea             	mov    %r13,%rdx
     140:	be 90 03 00 00       	mov    $0x390,%esi
     145:	89 df                	mov    %ebx,%edi
     147:	e8 00 00 00 00       	callq  14c <topmc_core_global_ctrl_init_nehelam+0x7c>
     14c:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 153 <topmc_core_global_ctrl_init_nehelam+0x83>
     153:	41 83 c4 01          	add    $0x1,%r12d
     157:	4c 89 ff             	mov    %r15,%rdi
     15a:	49 63 d4             	movslq %r12d,%rdx
     15d:	e8 00 00 00 00       	callq  162 <topmc_core_global_ctrl_init_nehelam+0x92>
void topmc_core_global_ctrl_init_nehelam(void)
{
	u64 mask;
	int cpu;

	for_each_online_cpu(cpu) {
     162:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 168 <topmc_core_global_ctrl_init_nehelam+0x98>
     168:	48 89 c3             	mov    %rax,%rbx
     16b:	41 89 c4             	mov    %eax,%r12d
     16e:	7c 90                	jl     100 <topmc_core_global_ctrl_init_nehelam+0x30>
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global control mask -> %llu\n", mask);

		TOPMC_RDMSRL(MSR_CORE_PERF_GLOBAL_OVF_CTRL, mask, cpu);
		//      printk("+->topmc: topmc_core_global_ctrl_init(): global overflow control mask -> %llu\n", mask);
	}
}
     170:	48 83 c4 18          	add    $0x18,%rsp
     174:	5b                   	pop    %rbx
     175:	41 5c                	pop    %r12
     177:	41 5d                	pop    %r13
     179:	41 5e                	pop    %r14
     17b:	41 5f                	pop    %r15
     17d:	c9                   	leaveq 
     17e:	c3                   	retq   
     17f:	90                   	nop

0000000000000180 <topmc_msr_init_nehelam>:

	return count;
}

void topmc_msr_init_nehelam(void)
{
     180:	55                   	push   %rbp
     181:	48 89 e5             	mov    %rsp,%rbp
     184:	41 57                	push   %r15
     186:	41 56                	push   %r14
     188:	41 55                	push   %r13
     18a:	41 54                	push   %r12
     18c:	53                   	push   %rbx
     18d:	48 83 ec 18          	sub    $0x18,%rsp
     191:	e8 00 00 00 00       	callq  196 <topmc_msr_init_nehelam+0x16>
     196:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     19b:	49 bf 00 00 20 00 ff 	mov    $0xffffffff00200000,%r15
     1a2:	ff ff ff 
		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1a5:	4c 8d 75 cc          	lea    -0x34(%rbp),%r14
     1a9:	4c 8d 6d c8          	lea    -0x38(%rbp),%r13
     1ad:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # 1b4 <topmc_msr_init_nehelam+0x34>
     1b4:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # 1bb <topmc_msr_init_nehelam+0x3b>
     1bb:	83 c3 01             	add    $0x1,%ebx
     1be:	48 63 d3             	movslq %ebx,%rdx
     1c1:	e8 00 00 00 00       	callq  1c6 <topmc_msr_init_nehelam+0x46>
void topmc_msr_init_nehelam(void)
{
	int i,cpu;
	u64 val;

	for_each_online_cpu(cpu){
     1c6:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # 1cc <topmc_msr_init_nehelam+0x4c>
     1cc:	89 c3                	mov    %eax,%ebx
     1ce:	0f 8d fc 00 00 00    	jge    2d0 <topmc_msr_init_nehelam+0x150>
     1d4:	41 bc 01 00 00 00    	mov    $0x1,%r12d
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
     1da:	41 83 fc 01          	cmp    $0x1,%r12d
     1de:	75 3f                	jne    21f <topmc_msr_init_nehelam+0x9f>
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1e0:	4c 89 f1             	mov    %r14,%rcx
     1e3:	4c 89 ea             	mov    %r13,%rdx
     1e6:	be 86 01 00 00       	mov    $0x186,%esi
     1eb:	89 df                	mov    %ebx,%edi
     1ed:	e8 00 00 00 00       	callq  1f2 <topmc_msr_init_nehelam+0x72>
     1f2:	8b 55 cc             	mov    -0x34(%rbp),%edx
     1f5:	8b 45 c8             	mov    -0x38(%rbp),%eax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1f8:	be 86 01 00 00       	mov    $0x186,%esi
     1fd:	89 df                	mov    %ebx,%edi
		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     1ff:	48 c1 e2 20          	shl    $0x20,%rdx
     203:	48 09 c2             	or     %rax,%rdx
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     206:	4c 21 fa             	and    %r15,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
     209:	48 89 d1             	mov    %rdx,%rcx
     20c:	48 c1 e9 20          	shr    $0x20,%rcx
     210:	e8 00 00 00 00       	callq  215 <topmc_msr_init_nehelam+0x95>
void topmc_msr_init_nehelam(void)
{
	int i,cpu;
	u64 val;

	for_each_online_cpu(cpu){
     215:	41 83 c4 01          	add    $0x1,%r12d
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_EVNTSEL0+i))
     219:	41 83 fc 01          	cmp    $0x1,%r12d
     21d:	74 c1                	je     1e0 <topmc_msr_init_nehelam+0x60>
	for_each_online_cpu(cpu){
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     21f:	41 83 fc 03          	cmp    $0x3,%r12d
     223:	7e f0                	jle    215 <topmc_msr_init_nehelam+0x95>
     225:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     22b:	eb 17                	jmp    244 <topmc_msr_init_nehelam+0xc4>
     22d:	0f 1f 00             	nopl   (%rax)

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_PERFCTR0+i))
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
     230:	31 c9                	xor    %ecx,%ecx
     232:	31 d2                	xor    %edx,%edx
     234:	be c1 00 00 00       	mov    $0xc1,%esi
     239:	89 df                	mov    %ebx,%edi
     23b:	e8 00 00 00 00       	callq  240 <topmc_msr_init_nehelam+0xc0>
	for_each_online_cpu(cpu){
		//      printk("+-> topmc_msr_init(): cpu:%d\n",cpu);

		/* in core section */
		//first: clear the event selectors
		for (i = 0 ; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     240:	41 83 c4 01          	add    $0x1,%r12d
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_PERFCTR0+i))
     244:	41 83 fc 01          	cmp    $0x1,%r12d
     248:	74 e6                	je     230 <topmc_msr_init_nehelam+0xb0>
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     24a:	41 83 fc 03          	cmp    $0x3,%r12d
     24e:	7e f0                	jle    240 <topmc_msr_init_nehelam+0xc0>
     250:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     256:	eb 2e                	jmp    286 <topmc_msr_init_nehelam+0x106>
     258:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     25f:	00 

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i))
				continue;
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
     260:	4c 89 e9             	mov    %r13,%rcx
     263:	4c 89 f2             	mov    %r14,%rdx
     266:	be c0 03 00 00       	mov    $0x3c0,%esi
     26b:	89 df                	mov    %ebx,%edi
     26d:	e8 00 00 00 00       	callq  272 <topmc_msr_init_nehelam+0xf2>
			val &= 0ULL;
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
     272:	31 c9                	xor    %ecx,%ecx
     274:	31 d2                	xor    %edx,%edx
     276:	be c0 03 00 00       	mov    $0x3c0,%esi
     27b:	89 df                	mov    %ebx,%edi
     27d:	e8 00 00 00 00       	callq  282 <topmc_msr_init_nehelam+0x102>
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+i, val, cpu);
		}

		//second: clear the counter
		for (i = 0; i < TOPMC_MSR_XEON55XX_PerfCtrNum; ++i) {
     282:	41 83 c4 01          	add    $0x1,%r12d
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i))
     286:	41 83 fc 01          	cmp    $0x1,%r12d
     28a:	74 d4                	je     260 <topmc_msr_init_nehelam+0xe0>
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     28c:	41 83 fc 07          	cmp    $0x7,%r12d
     290:	7e f0                	jle    282 <topmc_msr_init_nehelam+0x102>
     292:	41 bc 01 00 00 00    	mov    $0x1,%r12d
     298:	eb 1a                	jmp    2b4 <topmc_msr_init_nehelam+0x134>
     29a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i))
				continue;

			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i, 0LL, cpu);
     2a0:	31 c9                	xor    %ecx,%ecx
     2a2:	31 d2                	xor    %edx,%edx
     2a4:	be b0 03 00 00       	mov    $0x3b0,%esi
     2a9:	89 df                	mov    %ebx,%edi
     2ab:	e8 00 00 00 00       	callq  2b0 <topmc_msr_init_nehelam+0x130>
				continue;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+i, 0LL, cpu);
		}

		/* uncore section */
		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     2b0:	41 83 c4 01          	add    $0x1,%r12d
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
		}

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
			if (unlikely(!TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i))
     2b4:	41 83 fc 01          	cmp    $0x1,%r12d
     2b8:	74 e6                	je     2a0 <topmc_msr_init_nehelam+0x120>
			val &= 0ULL;
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+i, val, cpu);
		}

		for (i = 0; i < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; ++i) {
     2ba:	41 83 fc 07          	cmp    $0x7,%r12d
     2be:	0f 8f e9 fe ff ff    	jg     1ad <topmc_msr_init_nehelam+0x2d>
     2c4:	eb ea                	jmp    2b0 <topmc_msr_init_nehelam+0x130>
     2c6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     2cd:	00 00 00 

			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+i, 0LL, cpu);
		}

	}
}
     2d0:	48 83 c4 18          	add    $0x18,%rsp
     2d4:	5b                   	pop    %rbx
     2d5:	41 5c                	pop    %r12
     2d7:	41 5d                	pop    %r13
     2d9:	41 5e                	pop    %r14
     2db:	41 5f                	pop    %r15
     2dd:	c9                   	leaveq 
     2de:	c3                   	retq   
     2df:	90                   	nop

00000000000002e0 <topmc_enable_read_nehelam>:
	return count;
}


int topmc_enable_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     2e0:	55                   	push   %rbp
     2e1:	48 89 e5             	mov    %rsp,%rbp
     2e4:	53                   	push   %rbx
     2e5:	48 83 ec 18          	sub    $0x18,%rsp
     2e9:	e8 00 00 00 00       	callq  2ee <topmc_enable_read_nehelam+0xe>
     2ee:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     2f1:	41 8b 39             	mov    (%r9),%edi
     2f4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     2f8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     2fc:	e8 00 00 00 00       	callq  301 <topmc_enable_read_nehelam+0x21>

	*page   = topmc_procs[cpu][counter].enable==1?'1':'0';
     301:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
     305:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
     309:	48 c1 e0 05          	shl    $0x5,%rax
     30d:	48 01 d0             	add    %rdx,%rax
     310:	48 c1 e0 04          	shl    $0x4,%rax
     314:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
	*(page+1) = '\n';
     31b:	c6 43 01 0a          	movb   $0xa,0x1(%rbx)
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);

	*page   = topmc_procs[cpu][counter].enable==1?'1':'0';
     31f:	0f 94 c0             	sete   %al
     322:	83 c0 30             	add    $0x30,%eax
     325:	88 03                	mov    %al,(%rbx)
	*(page+1) = '\n';
	return 2; //len of read
}
     327:	48 83 c4 18          	add    $0x18,%rsp
     32b:	b8 02 00 00 00       	mov    $0x2,%eax
     330:	5b                   	pop    %rbx
     331:	c9                   	leaveq 
     332:	c3                   	retq   
     333:	66 66 66 66 2e 0f 1f 	data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
     33a:	84 00 00 00 00 00 

0000000000000340 <topmc_enable_all_read_nehelam>:
extern struct topmc_proc_entry topmc_procs[NR_CPUS][TOPMC_MAX_COUNTER];

static int topmc_all_enabled = 0;

int topmc_enable_all_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     340:	55                   	push   %rbp
     341:	48 89 e5             	mov    %rsp,%rbp
     344:	53                   	push   %rbx
     345:	48 83 ec 18          	sub    $0x18,%rsp
     349:	e8 00 00 00 00       	callq  34e <topmc_enable_all_read_nehelam+0xe>
     34e:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     351:	41 8b 39             	mov    (%r9),%edi
     354:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     358:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     35c:	e8 00 00 00 00       	callq  361 <topmc_enable_all_read_nehelam+0x21>

	*page   = topmc_all_enabled==1?'1':'0';
     361:	83 3d 00 00 00 00 01 	cmpl   $0x1,0x0(%rip)        # 368 <topmc_enable_all_read_nehelam+0x28>
	*(page+1) = '\n';
     368:	c6 43 01 0a          	movb   $0xa,0x1(%rbx)
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);

	*page   = topmc_all_enabled==1?'1':'0';
     36c:	0f 94 c0             	sete   %al
     36f:	83 c0 30             	add    $0x30,%eax
     372:	88 03                	mov    %al,(%rbx)
	*(page+1) = '\n';
	return 2; //len of read
}
     374:	48 83 c4 18          	add    $0x18,%rsp
     378:	b8 02 00 00 00       	mov    $0x2,%eax
     37d:	5b                   	pop    %rbx
     37e:	c9                   	leaveq 
     37f:	c3                   	retq   

0000000000000380 <topmc_value_write_nehelam>:

	return strlen(page); //len of read
}

int topmc_value_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     380:	55                   	push   %rbp
     381:	48 89 e5             	mov    %rsp,%rbp
     384:	53                   	push   %rbx
     385:	48 83 ec 18          	sub    $0x18,%rsp
     389:	e8 00 00 00 00       	callq  38e <topmc_value_write_nehelam+0xe>
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);
     38e:	8b 39                	mov    (%rcx),%edi
     390:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi

	return strlen(page); //len of read
}

int topmc_value_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     394:	48 89 d3             	mov    %rdx,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);
     397:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     39b:	e8 00 00 00 00       	callq  3a0 <topmc_value_write_nehelam+0x20>

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     3a0:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3a4:	66 83 fe 0b          	cmp    $0xb,%si
     3a8:	0f 87 ba 00 00 00    	ja     468 <topmc_value_write_nehelam+0xe8>
		printk("+->topmc: topmc_value_write(): counter err : %d!!!\n",counter);
		return 0;
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
     3ae:	66 83 fe 03          	cmp    $0x3,%si
     3b2:	76 54                	jbe    408 <topmc_value_write_nehelam+0x88>
		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
	}
	else if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum) {
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter-TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     3b4:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3b8:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
     3bc:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
     3c0:	0f b7 f6             	movzwl %si,%esi
     3c3:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     3c9:	e8 00 00 00 00       	callq  3ce <topmc_value_write_nehelam+0x4e>
		//      printk("+->uncore event selector val: 0x%llu\n", val);
		//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
		val &= 0ULL;
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter-TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     3ce:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3d2:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3d6:	31 c9                	xor    %ecx,%ecx
     3d8:	31 d2                	xor    %edx,%edx
     3da:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     3e0:	e8 00 00 00 00       	callq  3e5 <topmc_value_write_nehelam+0x65>

		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     3e5:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     3e9:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     3ed:	31 c9                	xor    %ecx,%ecx
     3ef:	31 d2                	xor    %edx,%edx
     3f1:	81 c6 b0 03 00 00    	add    $0x3b0,%esi
     3f7:	e8 00 00 00 00       	callq  3fc <topmc_value_write_nehelam+0x7c>
	}


	return count;
     3fc:	89 d8                	mov    %ebx,%eax
}
     3fe:	48 83 c4 18          	add    $0x18,%rsp
     402:	5b                   	pop    %rbx
     403:	c9                   	leaveq 
     404:	c3                   	retq   
     405:	0f 1f 00             	nopl   (%rax)
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     408:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     40c:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
     410:	48 8d 55 e4          	lea    -0x1c(%rbp),%rdx
     414:	0f b7 f6             	movzwl %si,%esi
     417:	81 c6 86 01 00 00    	add    $0x186,%esi
     41d:	e8 00 00 00 00       	callq  422 <topmc_value_write_nehelam+0xa2>
     422:	8b 45 e8             	mov    -0x18(%rbp),%eax
     425:	8b 55 e4             	mov    -0x1c(%rbp),%edx
		//        printk("+->incore event selector val: 0x%llu\n", val);
		val &= MSR_PPRO_EVENTSEL_RESERVED;
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     428:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     42c:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
	}

	//FIXME:just set counter to zero
	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum){
		//first: clear the event selector
		TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     430:	48 c1 e0 20          	shl    $0x20,%rax
		//        printk("+->incore event selector val: 0x%llu\n", val);
		val &= MSR_PPRO_EVENTSEL_RESERVED;
     434:	81 e2 00 00 20 00    	and    $0x200000,%edx
     43a:	48 09 c2             	or     %rax,%rdx
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     43d:	81 c6 86 01 00 00    	add    $0x186,%esi
     443:	48 89 d1             	mov    %rdx,%rcx
     446:	48 c1 e9 20          	shr    $0x20,%rcx
     44a:	e8 00 00 00 00       	callq  44f <topmc_value_write_nehelam+0xcf>

		//second: clear the counter
		TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     44f:	0f b7 75 ec          	movzwl -0x14(%rbp),%esi
     453:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     457:	31 c9                	xor    %ecx,%ecx
     459:	31 d2                	xor    %edx,%edx
     45b:	81 c6 c1 00 00 00    	add    $0xc1,%esi
     461:	e8 00 00 00 00       	callq  466 <topmc_value_write_nehelam+0xe6>
     466:	eb 94                	jmp    3fc <topmc_value_write_nehelam+0x7c>
	u64 val;

	topmc_split32to16(mix,&cpu,&counter);

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_write(): counter err : %d!!!\n",counter);
     468:	0f b7 f6             	movzwl %si,%esi
     46b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     472:	31 c0                	xor    %eax,%eax
     474:	e8 00 00 00 00       	callq  479 <topmc_value_write_nehelam+0xf9>
     479:	31 c0                	xor    %eax,%eax
		return 0;
     47b:	eb 81                	jmp    3fe <topmc_value_write_nehelam+0x7e>
     47d:	0f 1f 00             	nopl   (%rax)

0000000000000480 <topmc_value_read_callable_impl_nehelam>:
}


#ifdef TOPMC_PER_SECOND
u64 topmc_value_read_callable_impl_nehelam(unsigned short cpu, unsigned short counter)
{
     480:	55                   	push   %rbp
     481:	48 89 e5             	mov    %rsp,%rbp
     484:	e8 00 00 00 00       	callq  489 <topmc_value_read_callable_impl_nehelam+0x9>
	u64 val;
	u32 lo,hi;
	unsigned int perfctr;

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     489:	66 83 fe 0b          	cmp    $0xb,%si
     48d:	77 2c                	ja     4bb <topmc_value_read_callable_impl_nehelam+0x3b>
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     48f:	66 83 fe 03          	cmp    $0x3,%si
     493:	76 1b                	jbe    4b0 <topmc_value_read_callable_impl_nehelam+0x30>
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
		//      perfctrl = TOPMC_MSR_XEON55XX_EVNTSEL0 + counter;
	}
	else {  
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
     495:	0f b7 ce             	movzwl %si,%ecx
     498:	81 c1 ac 03 00 00    	add    $0x3ac,%ecx
	//      printk("+->topmc_value_read() : enable == 0\n");
	val = topmc_procs[cpu][counter].value;
	}
	 */
//	printk("topmc_value_read_callable:perfctr= %x\n", perfctr);
	__asm__ __volatile__ ("rdmsr" : "=a" (lo), "=d" (hi) : "c" (perfctr));
     49e:	0f 32                	rdmsr  
     4a0:	89 c1                	mov    %eax,%ecx
	val = (u64)hi<<32 | lo;
     4a2:	48 89 d0             	mov    %rdx,%rax
     4a5:	48 c1 e0 20          	shl    $0x20,%rax
     4a9:	89 c9                	mov    %ecx,%ecx
     4ab:	48 09 c8             	or     %rcx,%rax
//	val = counter + cpu;
//	printk("topmc_value_read_callable: %llu\n", val);
	return val;
}
     4ae:	c9                   	leaveq 
     4af:	c3                   	retq   

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
     4b0:	0f b7 ce             	movzwl %si,%ecx
     4b3:	81 c1 c1 00 00 00    	add    $0xc1,%ecx
     4b9:	eb e3                	jmp    49e <topmc_value_read_callable_impl_nehelam+0x1e>
	u64 val;
	u32 lo,hi;
	unsigned int perfctr;

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);
     4bb:	0f b7 f6             	movzwl %si,%esi
     4be:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     4c5:	31 c0                	xor    %eax,%eax
     4c7:	e8 00 00 00 00       	callq  4cc <topmc_value_read_callable_impl_nehelam+0x4c>
     4cc:	31 c0                	xor    %eax,%eax
	__asm__ __volatile__ ("rdmsr" : "=a" (lo), "=d" (hi) : "c" (perfctr));
	val = (u64)hi<<32 | lo;
//	val = counter + cpu;
//	printk("topmc_value_read_callable: %llu\n", val);
	return val;
}
     4ce:	c9                   	leaveq 
     4cf:	c3                   	retq   

00000000000004d0 <topmc_value_read_nehelam>:

#endif
//EXPORT_SYMBOL(topmc_value_read_callable);

int topmc_value_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     4d0:	55                   	push   %rbp
     4d1:	48 89 e5             	mov    %rsp,%rbp
     4d4:	53                   	push   %rbx
     4d5:	48 83 ec 18          	sub    $0x18,%rsp
     4d9:	e8 00 00 00 00       	callq  4de <topmc_value_read_nehelam+0xe>
     4de:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	u64 val;
	//u64 val_ctrl;

	topmc_split32to16(mix,&cpu,&counter);
     4e1:	41 8b 39             	mov    (%r9),%edi
     4e4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     4e8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     4ec:	e8 00 00 00 00       	callq  4f1 <topmc_value_read_nehelam+0x21>

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
     4f1:	0f b7 45 ec          	movzwl -0x14(%rbp),%eax
     4f5:	66 83 f8 0b          	cmp    $0xb,%ax
     4f9:	0f 87 96 00 00 00    	ja     595 <topmc_value_read_nehelam+0xc5>
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     4ff:	66 83 f8 03          	cmp    $0x3,%ax
     503:	76 53                	jbe    558 <topmc_value_read_nehelam+0x88>
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
	}
	else {
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
     505:	0f b7 c0             	movzwl %ax,%eax
     508:	8d b0 ac 03 00 00    	lea    0x3ac(%rax),%esi
	}
	if(topmc_procs[cpu][counter].enable == 1){
     50e:	0f b7 7d ee          	movzwl -0x12(%rbp),%edi
     512:	48 98                	cltq   
     514:	48 63 d7             	movslq %edi,%rdx
     517:	48 c1 e2 05          	shl    $0x5,%rdx
     51b:	48 8d 04 02          	lea    (%rdx,%rax,1),%rax
     51f:	48 c1 e0 04          	shl    $0x4,%rax
     523:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     52a:	74 3c                	je     568 <topmc_value_read_nehelam+0x98>
		TOPMC_RDMSRL(perfctr, val, cpu);
		sprintf(page, "%llu\n", val);

	}else{
		//      printk("+->topmc_value_read() : enable == 0\n");
		sprintf(page,"%llu\n",topmc_procs[cpu][counter].value);
     52c:	48 8b 90 00 00 00 00 	mov    0x0(%rax),%rdx
     533:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     53a:	48 89 df             	mov    %rbx,%rdi
     53d:	31 c0                	xor    %eax,%eax
     53f:	e8 00 00 00 00       	callq  544 <topmc_value_read_nehelam+0x74>
	}

	return strlen(page); //len of read
     544:	48 89 df             	mov    %rbx,%rdi
     547:	e8 00 00 00 00       	callq  54c <topmc_value_read_nehelam+0x7c>
}
     54c:	48 83 c4 18          	add    $0x18,%rsp
     550:	5b                   	pop    %rbx
     551:	c9                   	leaveq 
     552:	c3                   	retq   
     553:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

		return 0;
	}

	if(counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		perfctr = TOPMC_MSR_XEON55XX_PERFCTR0 + counter;
     558:	0f b7 c0             	movzwl %ax,%eax
     55b:	8d b0 c1 00 00 00    	lea    0xc1(%rax),%esi
     561:	eb ab                	jmp    50e <topmc_value_read_nehelam+0x3e>
     563:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	else {
		perfctr =  TOPMC_MSR_XEON55XX_UNC_PERFCTR0 + counter - TOPMC_MSR_XEON55XX_PerfCtrNum;
	}
	if(topmc_procs[cpu][counter].enable == 1){
		//      printk("+->topmc_value_read() : enable ==1   \n");
		TOPMC_RDMSRL(perfctr, val, cpu);
     568:	48 8d 55 e8          	lea    -0x18(%rbp),%rdx
     56c:	48 8d 4d e4          	lea    -0x1c(%rbp),%rcx
     570:	e8 00 00 00 00       	callq  575 <topmc_value_read_nehelam+0xa5>
		sprintf(page, "%llu\n", val);
     575:	8b 55 e4             	mov    -0x1c(%rbp),%edx
     578:	8b 45 e8             	mov    -0x18(%rbp),%eax
     57b:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     582:	48 89 df             	mov    %rbx,%rdi
     585:	48 c1 e2 20          	shl    $0x20,%rdx
     589:	48 09 c2             	or     %rax,%rdx
     58c:	31 c0                	xor    %eax,%eax
     58e:	e8 00 00 00 00       	callq  593 <topmc_value_read_nehelam+0xc3>
     593:	eb af                	jmp    544 <topmc_value_read_nehelam+0x74>
	//u64 val_ctrl;

	topmc_split32to16(mix,&cpu,&counter);

	if(counter>=TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum){
		printk("+->topmc: topmc_value_read(): counter err : %d!!!\n",counter);
     595:	0f b7 f0             	movzwl %ax,%esi
     598:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     59f:	31 c0                	xor    %eax,%eax
     5a1:	e8 00 00 00 00       	callq  5a6 <topmc_value_read_nehelam+0xd6>
     5a6:	31 c0                	xor    %eax,%eax

		return 0;
     5a8:	eb a2                	jmp    54c <topmc_value_read_nehelam+0x7c>
     5aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

00000000000005b0 <topmc_event_read_nehelam>:
unit---MUST BE two numbers
kernel/user---MUST BE one of the following number: 0-"neither",1-"only user",2-"only kernel",3-"both"

*/
int topmc_event_read_nehelam(char *page, char **start, off_t off, int count, int *eof, void *data)
{
     5b0:	55                   	push   %rbp
     5b1:	48 89 e5             	mov    %rsp,%rbp
     5b4:	53                   	push   %rbx
     5b5:	48 83 ec 18          	sub    $0x18,%rsp
     5b9:	e8 00 00 00 00       	callq  5be <topmc_event_read_nehelam+0xe>
     5be:	48 89 fb             	mov    %rdi,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;

	topmc_split32to16(mix,&cpu,&counter);
     5c1:	41 8b 39             	mov    (%r9),%edi
     5c4:	48 8d 55 ec          	lea    -0x14(%rbp),%rdx
     5c8:	48 8d 75 ee          	lea    -0x12(%rbp),%rsi
     5cc:	e8 00 00 00 00       	callq  5d1 <topmc_event_read_nehelam+0x21>

	sprintf(page,"0x%08x\n",topmc_procs[cpu][counter].event);
     5d1:	0f b7 45 ee          	movzwl -0x12(%rbp),%eax
     5d5:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
     5d9:	48 89 df             	mov    %rbx,%rdi
     5dc:	48 c7 c6 00 00 00 00 	mov    $0x0,%rsi
     5e3:	48 c1 e0 05          	shl    $0x5,%rax
     5e7:	48 01 d0             	add    %rdx,%rax
     5ea:	48 c1 e0 04          	shl    $0x4,%rax
     5ee:	8b 90 00 00 00 00    	mov    0x0(%rax),%edx
     5f4:	31 c0                	xor    %eax,%eax
     5f6:	e8 00 00 00 00       	callq  5fb <topmc_event_read_nehelam+0x4b>

	return strlen(page); //len of read, event must between 01~99
     5fb:	48 89 df             	mov    %rbx,%rdi
     5fe:	e8 00 00 00 00       	callq  603 <topmc_event_read_nehelam+0x53>
}
     603:	48 83 c4 18          	add    $0x18,%rsp
     607:	5b                   	pop    %rbx
     608:	c9                   	leaveq 
     609:	c3                   	retq   
     60a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

0000000000000610 <topmc_event_write_nehelam>:

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     610:	55                   	push   %rbp
     611:	48 89 e5             	mov    %rsp,%rbp
     614:	48 83 ec 40          	sub    $0x40,%rsp
     618:	48 89 5d e0          	mov    %rbx,-0x20(%rbp)
     61c:	4c 89 65 e8          	mov    %r12,-0x18(%rbp)
     620:	4c 89 6d f0          	mov    %r13,-0x10(%rbp)
     624:	4c 89 75 f8          	mov    %r14,-0x8(%rbp)
     628:	e8 00 00 00 00       	callq  62d <topmc_event_write_nehelam+0x1d>
     62d:	65 48 8b 04 25 28 00 	mov    %gs:0x28,%rax
     634:	00 00 
     636:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
     63a:	31 c0                	xor    %eax,%eax
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     63c:	8b 39                	mov    (%rcx),%edi

	return strlen(page); //len of read, event must between 01~99
}

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     63e:	49 89 f5             	mov    %rsi,%r13
     641:	48 89 d3             	mov    %rdx,%rbx
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     644:	48 8d 75 ce          	lea    -0x32(%rbp),%rsi
     648:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
     64c:	4c 8d 65 d0          	lea    -0x30(%rbp),%r12
	unsigned int mix        = *(unsigned int *)data;
	unsigned short cpu,counter;
	int i;
	long ret;

	topmc_split32to16(mix,&cpu,&counter);
     650:	e8 00 00 00 00       	callq  655 <topmc_event_write_nehelam+0x45>

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
     655:	ba 08 00 00 00       	mov    $0x8,%edx
     65a:	4c 89 ee             	mov    %r13,%rsi
     65d:	4c 89 e7             	mov    %r12,%rdi
     660:	e8 00 00 00 00       	callq  665 <topmc_event_write_nehelam+0x55>
	if (ret < 0)
     665:	48 85 c0             	test   %rax,%rax
     668:	ba f2 ff ff ff       	mov    $0xfffffff2,%edx
     66d:	79 31                	jns    6a0 <topmc_event_write_nehelam+0x90>
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
}
     66f:	89 d0                	mov    %edx,%eax
     671:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
     675:	65 48 33 14 25 28 00 	xor    %gs:0x28,%rdx
     67c:	00 00 
     67e:	0f 85 96 00 00 00    	jne    71a <topmc_event_write_nehelam+0x10a>
     684:	48 8b 5d e0          	mov    -0x20(%rbp),%rbx
     688:	4c 8b 65 e8          	mov    -0x18(%rbp),%r12
     68c:	4c 8b 6d f0          	mov    -0x10(%rbp),%r13
     690:	4c 8b 75 f8          	mov    -0x8(%rbp),%r14
     694:	c9                   	leaveq 
     695:	c3                   	retq   
     696:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     69d:	00 00 00 
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     6a0:	48 83 f8 08          	cmp    $0x8,%rax
     6a4:	7f 6a                	jg     710 <topmc_event_write_nehelam+0x100>
     6a6:	48 85 c0             	test   %rax,%rax
     6a9:	74 65                	je     710 <topmc_event_write_nehelam+0x100>
	sprintf(page,"0x%08x\n",topmc_procs[cpu][counter].event);

	return strlen(page); //len of read, event must between 01~99
}

int topmc_event_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
     6ab:	49 8d 4c 24 08       	lea    0x8(%r12),%rcx
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     6b0:	4c 89 e0             	mov    %r12,%rax
     6b3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
     6b8:	0f b6 10             	movzbl (%rax),%edx
     6bb:	0f b6 92 00 00 00 00 	movzbl 0x0(%rdx),%edx
     6c2:	83 e2 44             	and    $0x44,%edx
     6c5:	74 58                	je     71f <topmc_event_write_nehelam+0x10f>
			topmc_procs[cpu][counter].event = 0;
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
     6c7:	48 83 c0 01          	add    $0x1,%rax
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
     6cb:	48 39 c8             	cmp    %rcx,%rax
     6ce:	75 e8                	jne    6b8 <topmc_event_write_nehelam+0xa8>
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
     6d0:	44 0f b7 6d ce       	movzwl -0x32(%rbp),%r13d
     6d5:	44 0f b7 75 cc       	movzwl -0x34(%rbp),%r14d
     6da:	ba 10 00 00 00       	mov    $0x10,%edx
     6df:	be 08 00 00 00       	mov    $0x8,%esi
     6e4:	4c 89 e7             	mov    %r12,%rdi
     6e7:	e8 00 00 00 00       	callq  6ec <topmc_event_write_nehelam+0xdc>
out:
	return count;
     6ec:	89 da                	mov    %ebx,%edx
			printk("+->topmc_event_write():event error:%s!!!\n",event);
			goto out;
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
     6ee:	4d 63 ed             	movslq %r13d,%r13
     6f1:	4d 63 f6             	movslq %r14d,%r14
     6f4:	49 c1 e5 05          	shl    $0x5,%r13
     6f8:	4d 01 f5             	add    %r14,%r13
     6fb:	49 c1 e5 04          	shl    $0x4,%r13
     6ff:	41 89 85 00 00 00 00 	mov    %eax,0x0(%r13)
out:
	return count;
     706:	e9 64 ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
     70b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
	topmc_split32to16(mix,&cpu,&counter);

	ret     = strncpy_from_user(event,buffer,TOPMC_EVENT_LENGTH);
	if (ret < 0)
		return -EFAULT;
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
     710:	ba ea ff ff ff       	mov    $0xffffffea,%edx
     715:	e9 55 ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
}
     71a:	e8 00 00 00 00       	callq  71f <topmc_event_write_nehelam+0x10f>
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
			topmc_procs[cpu][counter].event = 0;
     71f:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     723:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
			printk("+->topmc_event_write():event error:%s!!!\n",event);
     727:	4c 89 e6             	mov    %r12,%rsi
     72a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
	if (ret == 0 || ret > TOPMC_EVENT_LENGTH)
		return -EINVAL;

	for(i=0;i<TOPMC_EVENT_LENGTH;i++){
		if(!isxdigit(event[i])){
			topmc_procs[cpu][counter].event = 0;
     731:	48 c1 e0 05          	shl    $0x5,%rax
     735:	48 01 d0             	add    %rdx,%rax
     738:	48 c1 e0 04          	shl    $0x4,%rax
     73c:	c7 80 00 00 00 00 00 	movl   $0x0,0x0(%rax)
     743:	00 00 00 
			printk("+->topmc_event_write():event error:%s!!!\n",event);
     746:	31 c0                	xor    %eax,%eax
     748:	e8 00 00 00 00       	callq  74d <topmc_event_write_nehelam+0x13d>
		}
	}

	topmc_procs[cpu][counter].event = topmc_str2int(event,8,16);
out:
	return count;
     74d:	89 da                	mov    %ebx,%edx
     74f:	e9 1b ff ff ff       	jmpq   66f <topmc_event_write_nehelam+0x5f>
     754:	66 66 66 2e 0f 1f 84 	data32 data32 nopw %cs:0x0(%rax,%rax,1)
     75b:	00 00 00 00 00 

0000000000000760 <topmc_enable_write_nehelam>:
	return 2; //len of read
}


int topmc_enable_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     760:	55                   	push   %rbp
     761:	48 89 e5             	mov    %rsp,%rbp
     764:	41 57                	push   %r15
     766:	41 56                	push   %r14
     768:	41 55                	push   %r13
     76a:	41 54                	push   %r12
     76c:	53                   	push   %rbx
     76d:	48 83 ec 18          	sub    $0x18,%rsp
     771:	e8 00 00 00 00       	callq  776 <topmc_enable_write_nehelam+0x16>
	//unsigned int low = 0,high =0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
     776:	8b 39                	mov    (%rcx),%edi
	return 2; //len of read
}


int topmc_enable_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     778:	48 89 f3             	mov    %rsi,%rbx
     77b:	49 89 d4             	mov    %rdx,%r12
	//unsigned int low = 0,high =0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
     77e:	48 8d 75 ce          	lea    -0x32(%rbp),%rsi
     782:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     786:	e8 00 00 00 00       	callq  78b <topmc_enable_write_nehelam+0x2b>
	get_user(enable,buffer);
     78b:	48 89 d8             	mov    %rbx,%rax
     78e:	e8 00 00 00 00       	callq  793 <topmc_enable_write_nehelam+0x33>

	event   = topmc_procs[cpu][counter].event;
     793:	44 0f b7 45 ce       	movzwl -0x32(%rbp),%r8d
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);
     798:	41 89 d7             	mov    %edx,%r15d

	event   = topmc_procs[cpu][counter].event;
     79b:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
     79f:	41 0f b7 f8          	movzwl %r8w,%edi
     7a3:	0f b7 ca             	movzwl %dx,%ecx
     7a6:	48 63 c7             	movslq %edi,%rax
     7a9:	48 63 d9             	movslq %ecx,%rbx
     7ac:	48 c1 e0 05          	shl    $0x5,%rax
     7b0:	48 01 d8             	add    %rbx,%rax
     7b3:	48 c1 e0 04          	shl    $0x4,%rax
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     7b7:	66 83 fa 03          	cmp    $0x3,%dx
	u64 val = 0;

	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
     7bb:	8b 98 00 00 00 00    	mov    0x0(%rax),%ebx
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
     7c1:	0f 87 99 01 00 00    	ja     960 <topmc_enable_write_nehelam+0x200>
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     7c7:	89 de                	mov    %ebx,%esi
     7c9:	45 31 f6             	xor    %r14d,%r14d
     7cc:	41 bd 01 00 00 00    	mov    $0x1,%r13d
     7d2:	83 e6 0f             	and    $0xf,%esi
     7d5:	83 fe 01             	cmp    $0x1,%esi
     7d8:	74 39                	je     813 <topmc_enable_write_nehelam+0xb3>
     7da:	0f 8e 00 04 00 00    	jle    be0 <topmc_enable_write_nehelam+0x480>
     7e0:	45 31 ed             	xor    %r13d,%r13d
     7e3:	83 fe 02             	cmp    $0x2,%esi
     7e6:	41 be 01 00 00 00    	mov    $0x1,%r14d
     7ec:	74 25                	je     813 <topmc_enable_write_nehelam+0xb3>
     7ee:	83 fe 03             	cmp    $0x3,%esi
				user=1;
				break;
			case 2:
				kernel=1;
				user=0;
				break;
     7f1:	41 b5 01             	mov    $0x1,%r13b
	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     7f4:	74 1d                	je     813 <topmc_enable_write_nehelam+0xb3>
				break;
			case 3:
				kernel=user=1;
				break;
			default:
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
     7f6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     7fd:	31 c0                	xor    %eax,%eax
     7ff:	45 31 ed             	xor    %r13d,%r13d
     802:	e8 00 00 00 00       	callq  807 <topmc_enable_write_nehelam+0xa7>
     807:	0f b7 4d cc          	movzwl -0x34(%rbp),%ecx
     80b:	44 0f b7 45 ce       	movzwl -0x32(%rbp),%r8d
     810:	45 31 f6             	xor    %r14d,%r14d
				break;
		}
		if(enable=='1'){
     813:	41 80 ff 31          	cmp    $0x31,%r15b
     817:	0f 84 1b 02 00 00    	je     a38 <topmc_enable_write_nehelam+0x2d8>
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     81d:	8d b1 c1 00 00 00    	lea    0xc1(%rcx),%esi
     823:	41 0f b7 f8          	movzwl %r8w,%edi
     827:	31 c9                	xor    %ecx,%ecx
     829:	31 d2                	xor    %edx,%edx
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     82b:	48 8d 5d c4          	lea    -0x3c(%rbp),%rbx
     82f:	4c 8d 6d c8          	lea    -0x38(%rbp),%r13
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     833:	e8 00 00 00 00       	callq  838 <topmc_enable_write_nehelam+0xd8>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     838:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     83c:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     840:	48 89 d9             	mov    %rbx,%rcx
     843:	4c 89 ea             	mov    %r13,%rdx
     846:	81 c6 86 01 00 00    	add    $0x186,%esi
     84c:	e8 00 00 00 00       	callq  851 <topmc_enable_write_nehelam+0xf1>
     851:	8b 45 c4             	mov    -0x3c(%rbp),%eax
     854:	8b 55 c8             	mov    -0x38(%rbp),%edx
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     857:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     85b:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			topmc_procs[cpu][counter].enable        = 1;
		}
		else{
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     85f:	48 c1 e0 20          	shl    $0x20,%rax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     863:	81 e2 00 00 20 00    	and    $0x200000,%edx
     869:	48 09 c2             	or     %rax,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     86c:	81 c6 86 01 00 00    	add    $0x186,%esi
     872:	48 89 d1             	mov    %rdx,%rcx
     875:	48 c1 e9 20          	shr    $0x20,%rcx
     879:	e8 00 00 00 00       	callq  87e <topmc_enable_write_nehelam+0x11e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
     87e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     882:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     886:	4c 89 e9             	mov    %r13,%rcx
     889:	48 89 da             	mov    %rbx,%rdx
     88c:	81 c6 c1 00 00 00    	add    $0xc1,%esi
     892:	e8 00 00 00 00       	callq  897 <topmc_enable_write_nehelam+0x137>
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     897:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     89b:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     89f:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
     8a2:	0f b7 c7             	movzwl %di,%eax
     8a5:	48 63 d6             	movslq %esi,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     8a8:	81 c6 c1 00 00 00    	add    $0xc1,%esi
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     8ae:	48 c1 e0 05          	shl    $0x5,%rax
     8b2:	48 8d 14 10          	lea    (%rax,%rdx,1),%rdx
     8b6:	8b 45 c8             	mov    -0x38(%rbp),%eax
     8b9:	48 c1 e2 04          	shl    $0x4,%rdx
     8bd:	48 c1 e0 20          	shl    $0x20,%rax
     8c1:	48 09 c8             	or     %rcx,%rax
     8c4:	48 89 82 00 00 00 00 	mov    %rax,0x0(%rdx)
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     8cb:	31 c9                	xor    %ecx,%ecx
     8cd:	31 d2                	xor    %edx,%edx
     8cf:	e8 00 00 00 00       	callq  8d4 <topmc_enable_write_nehelam+0x174>
			topmc_procs[cpu][counter].enable = 0;
     8d4:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     8d8:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     8dc:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
			topmc_procs[cpu][counter].enable = 0;
     8e3:	48 c1 e0 05          	shl    $0x5,%rax
     8e7:	48 01 d0             	add    %rdx,%rax
     8ea:	48 c1 e0 04          	shl    $0x4,%rax
     8ee:	c7 80 00 00 00 00 00 	movl   $0x0,0x0(%rax)
     8f5:	00 00 00 
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     8f8:	e8 00 00 00 00       	callq  8fd <topmc_enable_write_nehelam+0x19d>
     8fd:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 904 <topmc_enable_write_nehelam+0x1a4>
	{
		set_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
	}
	else
	{
		clr_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
     904:	66 c7 05 00 00 00 00 	movw   $0x0,0x0(%rip)        # 90d <topmc_enable_write_nehelam+0x1ad>
     90b:	00 00 
	raw_spin_unlock_irq(&lock->rlock);
}

static inline void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)
{
	raw_spin_unlock_irqrestore(&lock->rlock, flags);
     90d:	48 89 c6             	mov    %rax,%rsi
     910:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     917:	e8 00 00 00 00       	callq  91c <topmc_enable_write_nehelam+0x1bc>
	}
	spin_unlock_irqrestore(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
	spin_lock_irqsave(&topmc_chg_lock, topmc_pmc_chg_flags);
     91c:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     923:	e8 00 00 00 00       	callq  928 <topmc_enable_write_nehelam+0x1c8>
     928:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     92f:	48 89 c6             	mov    %rax,%rsi
     932:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 939 <topmc_enable_write_nehelam+0x1d9>
//	printk("topmc_enable_write: before topmc_pmc_chg=%d\n",topmc_pmc_chg);
	topmc_pmc_chg = 1;
     939:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 943 <topmc_enable_write_nehelam+0x1e3>
     940:	00 00 00 
     943:	e8 00 00 00 00       	callq  948 <topmc_enable_write_nehelam+0x1e8>
	spin_unlock_irqrestore(&topmc_chg_lock, topmc_pmc_chg_flags);
#endif

out:
	return count;
}
     948:	48 83 c4 18          	add    $0x18,%rsp
     94c:	44 89 e0             	mov    %r12d,%eax
     94f:	5b                   	pop    %rbx
     950:	41 5c                	pop    %r12
     952:	41 5d                	pop    %r13
     954:	41 5e                	pop    %r14
     956:	41 5f                	pop    %r15
     958:	c9                   	leaveq 
     959:	c3                   	retq   
     95a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			topmc_procs[cpu][counter].value = value;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			topmc_procs[cpu][counter].enable        = 0;
		}
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
     960:	83 ea 04             	sub    $0x4,%edx
     963:	66 83 fa 07          	cmp    $0x7,%dx
     967:	0f 87 a3 00 00 00    	ja     a10 <topmc_enable_write_nehelam+0x2b0>
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
     96d:	41 80 ff 31          	cmp    $0x31,%r15b
     971:	0f 84 d9 01 00 00    	je     b50 <topmc_enable_write_nehelam+0x3f0>
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
			//printk("+->topmc_enable_write() enabled [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
		}
		else {
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     977:	8d b1 ac 03 00 00    	lea    0x3ac(%rcx),%esi
     97d:	31 d2                	xor    %edx,%edx
     97f:	31 c9                	xor    %ecx,%ecx
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     981:	48 8d 5d c8          	lea    -0x38(%rbp),%rbx
     985:	4c 8d 6d c4          	lea    -0x3c(%rbp),%r13
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
			//printk("+->topmc_enable_write() enabled [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
		}
		else {
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     989:	e8 00 00 00 00       	callq  98e <topmc_enable_write_nehelam+0x22e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     98e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     992:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     996:	48 89 d9             	mov    %rbx,%rcx
     999:	4c 89 ea             	mov    %r13,%rdx
     99c:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     9a2:	e8 00 00 00 00       	callq  9a7 <topmc_enable_write_nehelam+0x247>
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     9a7:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9ab:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9af:	31 c9                	xor    %ecx,%ecx
     9b1:	31 d2                	xor    %edx,%edx
     9b3:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     9b9:	e8 00 00 00 00       	callq  9be <topmc_enable_write_nehelam+0x25e>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     9be:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9c2:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9c6:	4c 89 e9             	mov    %r13,%rcx
     9c9:	48 89 da             	mov    %rbx,%rdx
     9cc:	81 c6 ac 03 00 00    	add    $0x3ac,%esi
     9d2:	e8 00 00 00 00       	callq  9d7 <topmc_enable_write_nehelam+0x277>
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     9d7:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     9db:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     9df:	8b 4d c8             	mov    -0x38(%rbp),%ecx
     9e2:	0f b7 c7             	movzwl %di,%eax
     9e5:	48 63 d6             	movslq %esi,%rdx
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     9e8:	81 c6 ac 03 00 00    	add    $0x3ac,%esi
			//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
			val &= 0ULL;
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			value = (unsigned long long)val;
			topmc_procs[cpu][counter].value = value;
     9ee:	48 c1 e0 05          	shl    $0x5,%rax
     9f2:	48 8d 14 10          	lea    (%rax,%rdx,1),%rdx
     9f6:	8b 45 c4             	mov    -0x3c(%rbp),%eax
     9f9:	48 c1 e2 04          	shl    $0x4,%rdx
     9fd:	48 c1 e0 20          	shl    $0x20,%rax
     a01:	48 09 c8             	or     %rcx,%rax
     a04:	48 89 82 00 00 00 00 	mov    %rax,0x0(%rdx)
     a0b:	e9 bb fe ff ff       	jmpq   8cb <topmc_enable_write_nehelam+0x16b>
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     a10:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     a17:	e8 00 00 00 00       	callq  a1c <topmc_enable_write_nehelam+0x2bc>
	if(enable == '1')
     a1c:	41 80 ff 31          	cmp    $0x31,%r15b
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     a20:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # a27 <topmc_enable_write_nehelam+0x2c7>
	if(enable == '1')
     a27:	0f 85 d7 fe ff ff    	jne    904 <topmc_enable_write_nehelam+0x1a4>
     a2d:	e9 01 01 00 00       	jmpq   b33 <topmc_enable_write_nehelam+0x3d3>
     a32:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			default:
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
				break;
		}
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
     a38:	41 0f b7 c0          	movzwl %r8w,%eax
     a3c:	48 63 d1             	movslq %ecx,%rdx
     a3f:	48 c1 e0 05          	shl    $0x5,%rax
     a43:	48 01 d0             	add    %rdx,%rax
     a46:	48 c1 e0 04          	shl    $0x4,%rax
     a4a:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     a51:	0f 84 99 01 00 00    	je     bf0 <topmc_enable_write_nehelam+0x490>
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     a57:	8d b1 c1 00 00 00    	lea    0xc1(%rcx),%esi
     a5d:	41 0f b7 f8          	movzwl %r8w,%edi
     a61:	31 c9                	xor    %ecx,%ecx
     a63:	31 d2                	xor    %edx,%edx
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     a65:	41 c1 e5 10          	shl    $0x10,%r13d
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     a69:	41 c1 e6 11          	shl    $0x11,%r14d
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     a6d:	e8 00 00 00 00       	callq  a72 <topmc_enable_write_nehelam+0x312>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a72:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     a76:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     a7a:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     a7e:	48 8d 55 c4          	lea    -0x3c(%rbp),%rdx
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     a82:	4d 63 ed             	movslq %r13d,%r13
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     a85:	4d 63 f6             	movslq %r14d,%r14
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a88:	81 c6 86 01 00 00    	add    $0x186,%esi
     a8e:	e8 00 00 00 00       	callq  a93 <topmc_enable_write_nehelam+0x333>
     a93:	8b 45 c8             	mov    -0x38(%rbp),%eax
     a96:	8b 55 c4             	mov    -0x3c(%rbp),%edx
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     a99:	89 d9                	mov    %ebx,%ecx
     a9b:	c1 e1 0f             	shl    $0xf,%ecx
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     a9e:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     aa2:	81 e1 00 00 80 00    	and    $0x800000,%ecx
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     aa8:	48 c1 e0 20          	shl    $0x20,%rax
			val &= MSR_PPRO_EVENTSEL_RESERVED;
     aac:	81 e2 00 00 20 00    	and    $0x200000,%edx
     ab2:	48 09 c2             	or     %rax,%rdx
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
     ab5:	89 d8                	mov    %ebx,%eax
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     ab7:	81 c6 86 01 00 00    	add    $0x186,%esi
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
			val &= MSR_PPRO_EVENTSEL_RESERVED;
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
     abd:	c1 e8 18             	shr    $0x18,%eax
     ac0:	89 c0                	mov    %eax,%eax
     ac2:	48 0d 00 00 50 00    	or     $0x500000,%rax
			TOPMC_CTRL_SET_KERN(val, kernel);
     ac8:	48 09 d0             	or     %rdx,%rax
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     acb:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ace:	c1 e3 0e             	shl    $0xe,%ebx
			//low = (unsigned int)(val & 0xffff);
			//high = (unsigned int)((val & 0xffff0000) >> 32);
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     ad1:	48 c1 ea 08          	shr    $0x8,%rdx
     ad5:	81 e2 00 ff 00 00    	and    $0xff00,%edx
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
     adb:	48 09 d0             	or     %rdx,%rax
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ade:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_ENABLE(val);
			TOPMC_CTRL_SET_USR(val, user);
			TOPMC_CTRL_SET_KERN(val, kernel);
			TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
			TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     ae1:	48 09 c1             	or     %rax,%rcx
			TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     ae4:	81 e2 00 00 04 00    	and    $0x40000,%edx
     aea:	48 09 ca             	or     %rcx,%rdx
			TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     aed:	4c 09 ea             	or     %r13,%rdx
			//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
			//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
			//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

			TOPMC_CTRL_SET_ACTIVE(val);
     af0:	4c 09 f2             	or     %r14,%rdx
			//val = (u64)( low | ((u64)(high) << 32));
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     af3:	48 89 d1             	mov    %rdx,%rcx
     af6:	48 c1 e9 20          	shr    $0x20,%rcx
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     afa:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     afe:	e8 00 00 00 00       	callq  b03 <topmc_enable_write_nehelam+0x3a3>
			topmc_procs[cpu][counter].enable = 1;
     b03:	0f b7 45 ce          	movzwl -0x32(%rbp),%eax
     b07:	0f b7 55 cc          	movzwl -0x34(%rbp),%edx
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     b0b:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
			topmc_procs[cpu][counter].enable = 1;
     b12:	48 c1 e0 05          	shl    $0x5,%rax
     b16:	48 01 d0             	add    %rdx,%rax
     b19:	48 c1 e0 04          	shl    $0x4,%rax
     b1d:	c7 80 00 00 00 00 01 	movl   $0x1,0x0(%rax)
     b24:	00 00 00 
	}
	//display some useful information
	// printk("+->topmc_enable_write() [cpu:%2d,counter:%d,smp_processor_id:%d]mask:%llu\n",cpu,counter,smp_processor_id(),val);
	
#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     b27:	e8 00 00 00 00       	callq  b2c <topmc_enable_write_nehelam+0x3cc>
     b2c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # b33 <topmc_enable_write_nehelam+0x3d3>
	if(enable == '1')
	{
		set_topmc_cnt(topmc_pmc_cnt_bitmap, counter);
     b33:	0f b7 4d cc          	movzwl -0x34(%rbp),%ecx
     b37:	ba 01 00 00 00       	mov    $0x1,%edx
     b3c:	d3 e2                	shl    %cl,%edx
     b3e:	66 09 15 00 00 00 00 	or     %dx,0x0(%rip)        # b45 <topmc_enable_write_nehelam+0x3e5>
     b45:	e9 c3 fd ff ff       	jmpq   90d <topmc_enable_write_nehelam+0x1ad>
     b4a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
		}
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
			if( topmc_procs[cpu][counter].enable == 1) {
     b50:	83 b8 00 00 00 00 01 	cmpl   $0x1,0x0(%rax)
     b57:	0f 84 a6 00 00 00    	je     c03 <topmc_enable_write_nehelam+0x4a3>
				printk("+->topmc_enable_write(): already enabled, skip this!!!\n");
				goto out;
			}
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, 0LL, cpu);
     b5d:	8d b1 ac 03 00 00    	lea    0x3ac(%rcx),%esi
     b63:	31 d2                	xor    %edx,%edx
     b65:	31 c9                	xor    %ecx,%ecx
     b67:	e8 00 00 00 00       	callq  b6c <topmc_enable_write_nehelam+0x40c>
			TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     b6c:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
     b70:	0f b7 7d ce          	movzwl -0x32(%rbp),%edi
     b74:	48 8d 4d c4          	lea    -0x3c(%rbp),%rcx
     b78:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     b7c:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     b82:	e8 00 00 00 00       	callq  b87 <topmc_enable_write_nehelam+0x427>
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b87:	89 d8                	mov    %ebx,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b89:	48 89 da             	mov    %rbx,%rdx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     b8c:	89 d9                	mov    %ebx,%ecx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b8e:	c1 e8 18             	shr    $0x18,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b91:	48 c1 ea 08          	shr    $0x8,%rdx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     b95:	c1 e1 0f             	shl    $0xf,%ecx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     b98:	89 c0                	mov    %eax,%eax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     b9a:	81 e2 00 ff 00 00    	and    $0xff00,%edx
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     ba0:	c1 e3 0e             	shl    $0xe,%ebx
			val &= 0ULL;
			TOPMC_CTRL_SET_ENABLE(val);
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     ba3:	48 0d 00 00 50 00    	or     $0x500000,%rax
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     ba9:	81 e1 00 00 80 00    	and    $0x800000,%ecx
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     baf:	0f b7 75 cc          	movzwl -0x34(%rbp),%esi
			//printk("+->topmc_enable_write(): event: %d\n", event);
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     bb3:	48 09 d0             	or     %rdx,%rax
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     bb6:	48 89 da             	mov    %rbx,%rdx
			TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
			//printk("+->topmc_enable_wirte(): val:%llu event_mask:%d\n",val, event & TOPMC_EVENT_MASK_UNIT);
			TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                        TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     bb9:	48 09 c1             	or     %rax,%rcx
			//printk("+->topmc_enable_wirte(): val:%llu event_mask_mask:%d\n",val, event & TOPMC_EVENT_MASK_LOW_EVENT);

			TOPMC_CTRL_SET_ACTIVE(val);
     bbc:	81 e2 00 00 04 00    	and    $0x40000,%edx
     bc2:	48 09 ca             	or     %rcx,%rdx
			//printk("+->topmc_enable_wirte(): val:%llu\n",val);
			TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter- TOPMC_MSR_XEON55XX_PerfCtrNum, val, cpu);
     bc5:	48 89 d1             	mov    %rdx,%rcx
     bc8:	81 c6 bc 03 00 00    	add    $0x3bc,%esi
     bce:	48 c1 e9 20          	shr    $0x20,%rcx
     bd2:	e9 23 ff ff ff       	jmpq   afa <topmc_enable_write_nehelam+0x39a>
     bd7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
     bde:	00 00 
	topmc_split32to16(mix,&cpu,&counter);
	get_user(enable,buffer);

	event   = topmc_procs[cpu][counter].event;
	if (counter < TOPMC_MSR_XEON55XX_PerfCtrNum) {
		switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     be0:	45 30 ed             	xor    %r13b,%r13b
     be3:	85 f6                	test   %esi,%esi
     be5:	0f 84 28 fc ff ff    	je     813 <topmc_enable_write_nehelam+0xb3>
     beb:	e9 06 fc ff ff       	jmpq   7f6 <topmc_enable_write_nehelam+0x96>
				printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
				break;
		}
		if(enable=='1'){
			if(topmc_procs[cpu][counter].enable==1){
				printk("+->topmc_enable_write():already enabled, skip this!!!\n");
     bf0:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     bf7:	31 c0                	xor    %eax,%eax
     bf9:	e8 00 00 00 00       	callq  bfe <topmc_enable_write_nehelam+0x49e>
				goto out;
     bfe:	e9 45 fd ff ff       	jmpq   948 <topmc_enable_write_nehelam+0x1e8>
	}
	else if ((counter >= TOPMC_MSR_XEON55XX_PerfCtrNum) && (counter < TOPMC_MSR_XEON55XX_PerfCtrNum + TOPMC_MSR_XEON55XX_UNC_PerfCtrNum)) {
		event = topmc_procs[cpu][counter].event;
		if (enable == '1') {
			if( topmc_procs[cpu][counter].enable == 1) {
				printk("+->topmc_enable_write(): already enabled, skip this!!!\n");
     c03:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     c0a:	31 c0                	xor    %eax,%eax
     c0c:	e8 00 00 00 00       	callq  c11 <topmc_enable_write_nehelam+0x4b1>
				goto out;
     c11:	e9 32 fd ff ff       	jmpq   948 <topmc_enable_write_nehelam+0x1e8>
     c16:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
     c1d:	00 00 00 

0000000000000c20 <topmc_enable_all_write_nehelam>:
	*(page+1) = '\n';
	return 2; //len of read
}

int topmc_enable_all_write_nehelam(struct file *file, const char __user * buffer, unsigned long count, void * data)
{
     c20:	55                   	push   %rbp
     c21:	48 89 e5             	mov    %rsp,%rbp
     c24:	41 57                	push   %r15
     c26:	41 56                	push   %r14
     c28:	41 55                	push   %r13
     c2a:	41 54                	push   %r12
     c2c:	53                   	push   %rbx
     c2d:	48 83 ec 38          	sub    $0x38,%rsp
     c31:	e8 00 00 00 00       	callq  c36 <topmc_enable_all_write_nehelam+0x16>
     c36:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
	//unsigned int low=0,high=0;
	int kernel=0,user=0,event;
	unsigned long long value;
	u64 val;

	get_user(enable,buffer);
     c3a:	48 89 f0             	mov    %rsi,%rax
     c3d:	e8 00 00 00 00       	callq  c42 <topmc_enable_all_write_nehelam+0x22>
     c42:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
     c47:	88 55 bf             	mov    %dl,-0x41(%rbp)
     c4a:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     c51:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     c58:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
     c5f:	00 
     c60:	48 63 35 00 00 00 00 	movslq 0x0(%rip),%rsi        # c67 <topmc_enable_all_write_nehelam+0x47>
     c67:	48 8b 3d 00 00 00 00 	mov    0x0(%rip),%rdi        # c6e <topmc_enable_all_write_nehelam+0x4e>
     c6e:	83 c3 01             	add    $0x1,%ebx
     c71:	48 63 d3             	movslq %ebx,%rdx
     c74:	e8 00 00 00 00       	callq  c79 <topmc_enable_all_write_nehelam+0x59>
	for_each_online_cpu(cpu){
     c79:	3b 05 00 00 00 00    	cmp    0x0(%rip),%eax        # c7f <topmc_enable_all_write_nehelam+0x5f>
     c7f:	89 c3                	mov    %eax,%ebx
     c81:	0f 8d 64 03 00 00    	jge    feb <topmc_enable_all_write_nehelam+0x3cb>
     c87:	48 98                	cltq   
     c89:	41 be 86 01 00 00    	mov    $0x186,%r14d
     c8f:	41 bc c1 00 00 00    	mov    $0xc1,%r12d
     c95:	49 89 c5             	mov    %rax,%r13
     c98:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
     c9c:	49 c1 e5 09          	shl    $0x9,%r13
     ca0:	49 81 c5 00 00 00 00 	add    $0x0,%r13
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
     ca7:	45 8b 7d 00          	mov    0x0(%r13),%r15d
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     cab:	44 89 fe             	mov    %r15d,%esi
     cae:	83 e6 0f             	and    $0xf,%esi
     cb1:	83 fe 01             	cmp    $0x1,%esi
     cb4:	0f 84 fe 02 00 00    	je     fb8 <topmc_enable_all_write_nehelam+0x398>
     cba:	0f 8e 10 03 00 00    	jle    fd0 <topmc_enable_all_write_nehelam+0x3b0>
     cc0:	83 fe 02             	cmp    $0x2,%esi
     cc3:	0f 84 d7 02 00 00    	je     fa0 <topmc_enable_all_write_nehelam+0x380>
     cc9:	83 fe 03             	cmp    $0x3,%esi
     ccc:	0f 1f 40 00          	nopl   0x0(%rax)
     cd0:	0f 84 b2 02 00 00    	je     f88 <topmc_enable_all_write_nehelam+0x368>
					break;
				case 3:
					kernel=user=1;
					break;
				default:
					printk("+->topmc_enable_write():kernel_user error:%d\n",(event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER);
     cd6:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     cdd:	31 c0                	xor    %eax,%eax
     cdf:	e8 00 00 00 00       	callq  ce4 <topmc_enable_all_write_nehelam+0xc4>
					break;
			}

			if(enable=='1'){
     ce4:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
     ce8:	0f 85 0a 02 00 00    	jne    ef8 <topmc_enable_all_write_nehelam+0x2d8>
				if(topmc_procs[cpu][counter].enable==1){
     cee:	41 83 7d fc 01       	cmpl   $0x1,-0x4(%r13)
     cf3:	0f 84 80 03 00 00    	je     1079 <topmc_enable_all_write_nehelam+0x459>
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}

				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     cf9:	31 c9                	xor    %ecx,%ecx
     cfb:	31 d2                	xor    %edx,%edx
     cfd:	44 89 e6             	mov    %r12d,%esi
     d00:	89 df                	mov    %ebx,%edi
     d02:	e8 00 00 00 00       	callq  d07 <topmc_enable_all_write_nehelam+0xe7>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d07:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     d0b:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     d0f:	44 89 f6             	mov    %r14d,%esi
     d12:	89 df                	mov    %ebx,%edi
     d14:	e8 00 00 00 00       	callq  d19 <topmc_enable_all_write_nehelam+0xf9>
     d19:	8b 55 cc             	mov    -0x34(%rbp),%edx
     d1c:	8b 45 c8             	mov    -0x38(%rbp),%eax
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d1f:	44 89 f9             	mov    %r15d,%ecx
     d22:	c1 e1 0f             	shl    $0xf,%ecx
				//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
				//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

				TOPMC_CTRL_SET_ACTIVE(val);
				//val = (u64)( low | ((u64)(high) << 32));
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d25:	44 89 f6             	mov    %r14d,%esi
     d28:	89 df                	mov    %ebx,%edi
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d2a:	81 e1 00 00 80 00    	and    $0x800000,%ecx
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}

				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d30:	48 c1 e2 20          	shl    $0x20,%rdx
     d34:	48 09 c2             	or     %rax,%rdx
				val &= MSR_PPRO_EVENTSEL_RESERVED;
     d37:	48 b8 00 00 20 00 ff 	mov    $0xffffffff00200000,%rax
     d3e:	ff ff ff 
     d41:	48 21 c2             	and    %rax,%rdx
				//low = (unsigned int)(val & 0xffffffff);
				//high = (unsigned int)((val & 0xffffffff00000000) >> 32);
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
     d44:	44 89 f8             	mov    %r15d,%eax
     d47:	c1 e8 18             	shr    $0x18,%eax
     d4a:	89 c0                	mov    %eax,%eax
     d4c:	48 0d 00 00 50 00    	or     $0x500000,%rax
				TOPMC_CTRL_SET_KERN(val, kernel);
     d52:	48 09 d0             	or     %rdx,%rax
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     d55:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d58:	41 c1 e7 0e          	shl    $0xe,%r15d
				//low = (unsigned int)(val & 0xffffffff);
				//high = (unsigned int)((val & 0xffffffff00000000) >> 32);
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
     d5c:	48 c1 ea 08          	shr    $0x8,%rdx
     d60:	81 e2 00 ff 00 00    	and    $0xff00,%edx
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
     d66:	48 09 d0             	or     %rdx,%rax
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d69:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     d6c:	48 09 c1             	or     %rax,%rcx
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                                TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     d6f:	8b 45 b8             	mov    -0x48(%rbp),%eax
				TOPMC_CTRL_SET_USR(val, user);
				TOPMC_CTRL_SET_KERN(val, kernel);
				TOPMC_CTRL_SET_UM(val,(event&TOPMC_EVENT_MASK_UNIT)>>TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event&TOPMC_EVENT_MASK_LOW_EVENT)>>TOPMC_EVENT_BITS_LOW_EVENT);
				TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
                                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     d72:	81 e2 00 00 04 00    	and    $0x40000,%edx
     d78:	48 09 ca             	or     %rcx,%rdx
                                TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     d7b:	c1 e0 10             	shl    $0x10,%eax
     d7e:	48 98                	cltq   
     d80:	48 09 c2             	or     %rax,%rdx
				//TOPMC_CTRL_SET_EVENT_HIGH(high,(event&TOPMC_EVENT_MASK_HIGH_EVENT)>>TOPMC_EVENT_BITS_HIGH_EVENT);
				//TOPMC_CTRL_SET_HOST_ONLY(high, 0);
				//TOPMC_CTRL_SET_GUEST_ONLY(high, 0);

				TOPMC_CTRL_SET_ACTIVE(val);
     d83:	8b 45 b4             	mov    -0x4c(%rbp),%eax
     d86:	c1 e0 11             	shl    $0x11,%eax
     d89:	48 98                	cltq   
     d8b:	48 09 c2             	or     %rax,%rdx
				//val = (u64)( low | ((u64)(high) << 32));
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     d8e:	48 89 d1             	mov    %rdx,%rcx
     d91:	48 c1 e9 20          	shr    $0x20,%rcx
     d95:	e8 00 00 00 00       	callq  d9a <topmc_enable_all_write_nehelam+0x17a>
				topmc_procs[cpu][counter].enable        = 1;
     d9a:	41 c7 45 fc 01 00 00 	movl   $0x1,-0x4(%r13)
     da1:	00 
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][counter].enable        = 0;
     da2:	41 83 c4 01          	add    $0x1,%r12d
     da6:	49 83 c5 10          	add    $0x10,%r13
     daa:	41 83 c6 01          	add    $0x1,%r14d
	unsigned long long value;
	u64 val;

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
     dae:	41 81 fc c5 00 00 00 	cmp    $0xc5,%r12d
     db5:	0f 85 ec fe ff ff    	jne    ca7 <topmc_enable_all_write_nehelam+0x87>
     dbb:	4c 8b 6d a8          	mov    -0x58(%rbp),%r13
     dbf:	41 be c0 03 00 00    	mov    $0x3c0,%r14d
     dc5:	66 41 bc b0 03       	mov    $0x3b0,%r12w
     dca:	49 c1 e5 09          	shl    $0x9,%r13
     dce:	49 81 c5 00 00 00 00 	add    $0x0,%r13
     dd5:	e9 a0 00 00 00       	jmpq   e7a <topmc_enable_all_write_nehelam+0x25a>
     dda:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
				if( topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable == 1) {
     de0:	41 83 7d fc 01       	cmpl   $0x1,-0x4(%r13)
     de5:	0f 84 8e 02 00 00    	je     1079 <topmc_enable_all_write_nehelam+0x459>
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
					goto out;
				}                                     
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     deb:	31 c9                	xor    %ecx,%ecx
     ded:	31 d2                	xor    %edx,%edx
     def:	44 89 e6             	mov    %r12d,%esi
     df2:	89 df                	mov    %ebx,%edi
     df4:	e8 00 00 00 00       	callq  df9 <topmc_enable_all_write_nehelam+0x1d9>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     df9:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     dfd:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     e01:	44 89 f6             	mov    %r14d,%esi
     e04:	89 df                	mov    %ebx,%edi
     e06:	e8 00 00 00 00       	callq  e0b <topmc_enable_all_write_nehelam+0x1eb>
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e0b:	44 89 f8             	mov    %r15d,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e0e:	4c 89 fa             	mov    %r15,%rdx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e11:	44 89 f9             	mov    %r15d,%ecx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e14:	c1 e8 18             	shr    $0x18,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e17:	48 c1 ea 08          	shr    $0x8,%rdx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e1b:	c1 e1 0f             	shl    $0xf,%ecx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e1e:	89 c0                	mov    %eax,%eax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
     e20:	81 e2 00 ff 00 00    	and    $0xff00,%edx
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);

				TOPMC_CTRL_SET_ACTIVE(val);
     e26:	41 c1 e7 0e          	shl    $0xe,%r15d
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
     e2a:	48 0d 00 00 50 00    	or     $0x500000,%rax
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e30:	81 e1 00 00 80 00    	and    $0x800000,%ecx

				TOPMC_CTRL_SET_ACTIVE(val);
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e36:	44 89 f6             	mov    %r14d,%esi
				val &= 0ULL;
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
     e39:	48 09 d0             	or     %rdx,%rax
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);

				TOPMC_CTRL_SET_ACTIVE(val);
     e3c:	4c 89 fa             	mov    %r15,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e3f:	89 df                	mov    %ebx,%edi
				TOPMC_CTRL_SET_ENABLE(val);
				TOPMC_CTRL_SET_UM(val, (event & TOPMC_EVENT_MASK_UNIT) >> TOPMC_EVENT_BITS_UNIT);
				TOPMC_CTRL_SET_EVENT_LOW(val, (event & TOPMC_EVENT_MASK_LOW_EVENT) >> TOPMC_EVENT_BITS_LOW_EVENT);
	                        TOPMC_CTRL_SET_CM(val, (event&TOPMC_EVENT_MASK_CMASK)>>TOPMC_EVENT_BITS_CMASK);
        	                TOPMC_CTRL_SET_INV(val, (event&TOPMC_EVENT_MASK_INV)>>TOPMC_EVENT_BITS_INV);
                	        TOPMC_CTRL_SET_EDGE(val, (event&TOPMC_EVENT_MASK_EDGE)>>TOPMC_EVENT_BITS_EDGE);
     e41:	48 09 c1             	or     %rax,%rcx

				TOPMC_CTRL_SET_ACTIVE(val);
     e44:	81 e2 00 00 04 00    	and    $0x40000,%edx
     e4a:	48 09 ca             	or     %rcx,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e4d:	48 89 d1             	mov    %rdx,%rcx
     e50:	48 c1 e9 20          	shr    $0x20,%rcx
     e54:	e8 00 00 00 00       	callq  e59 <topmc_enable_all_write_nehelam+0x239>
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 1;
     e59:	41 c7 45 fc 01 00 00 	movl   $0x1,-0x4(%r13)
     e60:	00 
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 0;
     e61:	41 83 c4 01          	add    $0x1,%r12d
     e65:	49 83 c5 10          	add    $0x10,%r13
     e69:	41 83 c6 01          	add    $0x1,%r14d
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				topmc_procs[cpu][counter].enable        = 0;
				//                              printk("+->topmc_enable_all_write(): disabled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);                                      
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
     e6d:	41 81 fc b8 03 00 00 	cmp    $0x3b8,%r12d
     e74:	0f 84 e6 fd ff ff    	je     c60 <topmc_enable_all_write_nehelam+0x40>
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
     e7a:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
				topmc_procs[cpu][counter].enable        = 0;
				//                              printk("+->topmc_enable_all_write(): disabled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);                                      
			}
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
     e7e:	45 8b 7d 00          	mov    0x0(%r13),%r15d
			if (enable == '1') {
     e82:	0f 84 58 ff ff ff    	je     de0 <topmc_enable_all_write_nehelam+0x1c0>
				TOPMC_CTRL_SET_ACTIVE(val);
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 1;
			}
			else {
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     e88:	31 c9                	xor    %ecx,%ecx
     e8a:	31 d2                	xor    %edx,%edx
     e8c:	44 89 e6             	mov    %r12d,%esi
     e8f:	89 df                	mov    %ebx,%edi
     e91:	e8 00 00 00 00       	callq  e96 <topmc_enable_all_write_nehelam+0x276>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     e96:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     e9a:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     e9e:	44 89 f6             	mov    %r14d,%esi
     ea1:	89 df                	mov    %ebx,%edi
     ea3:	e8 00 00 00 00       	callq  ea8 <topmc_enable_all_write_nehelam+0x288>
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
     ea8:	31 c9                	xor    %ecx,%ecx
     eaa:	31 d2                	xor    %edx,%edx
     eac:	44 89 f6             	mov    %r14d,%esi
     eaf:	89 df                	mov    %ebx,%edi
     eb1:	e8 00 00 00 00       	callq  eb6 <topmc_enable_all_write_nehelam+0x296>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
     eb6:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     eba:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     ebe:	44 89 e6             	mov    %r12d,%esi
     ec1:	89 df                	mov    %ebx,%edi
     ec3:	e8 00 00 00 00       	callq  ec8 <topmc_enable_all_write_nehelam+0x2a8>
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ec8:	8b 45 c8             	mov    -0x38(%rbp),%eax
     ecb:	8b 55 cc             	mov    -0x34(%rbp),%edx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     ece:	31 c9                	xor    %ecx,%ecx
     ed0:	44 89 e6             	mov    %r12d,%esi
     ed3:	89 df                	mov    %ebx,%edi
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ed5:	48 c1 e0 20          	shl    $0x20,%rax
     ed9:	48 09 d0             	or     %rdx,%rax
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     edc:	31 d2                	xor    %edx,%edx
				//val &= TOPMC_MSR_XEON55XX_UNC_EVENTSEL_RESERVED;
				val &= 0ULL;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].value = value;
     ede:	49 89 45 04          	mov    %rax,0x4(%r13)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_UNC_PERFCTR0+counter, 0LL, cpu);
     ee2:	e8 00 00 00 00       	callq  ee7 <topmc_enable_all_write_nehelam+0x2c7>
				topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable = 0;
     ee7:	41 c7 45 fc 00 00 00 	movl   $0x0,-0x4(%r13)
     eee:	00 
     eef:	e9 6d ff ff ff       	jmpq   e61 <topmc_enable_all_write_nehelam+0x241>
     ef4:	0f 1f 40 00          	nopl   0x0(%rax)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				topmc_procs[cpu][counter].enable        = 1;
				//                              printk("+->topmc_enable_all_write(): abled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);
			}
			else{
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     ef8:	31 c9                	xor    %ecx,%ecx
     efa:	31 d2                	xor    %edx,%edx
     efc:	44 89 e6             	mov    %r12d,%esi
     eff:	89 df                	mov    %ebx,%edi
     f01:	e8 00 00 00 00       	callq  f06 <topmc_enable_all_write_nehelam+0x2e6>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f06:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
     f0a:	48 8d 55 cc          	lea    -0x34(%rbp),%rdx
     f0e:	44 89 f6             	mov    %r14d,%esi
     f11:	89 df                	mov    %ebx,%edi
     f13:	e8 00 00 00 00       	callq  f18 <topmc_enable_all_write_nehelam+0x2f8>
     f18:	8b 55 c8             	mov    -0x38(%rbp),%edx
     f1b:	8b 45 cc             	mov    -0x34(%rbp),%eax
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f1e:	44 89 f6             	mov    %r14d,%esi
     f21:	89 df                	mov    %ebx,%edi
				topmc_procs[cpu][counter].enable        = 1;
				//                              printk("+->topmc_enable_all_write(): abled [cpu:%2d,counter:%d,smp_processor_id:%d]high:0x%x,low:0x%x\n",cpu,counter,smp_processor_id(),high,low);
			}
			else{
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f23:	48 c1 e2 20          	shl    $0x20,%rdx
     f27:	48 09 c2             	or     %rax,%rdx
				val &= MSR_PPRO_EVENTSEL_RESERVED;
     f2a:	48 b8 00 00 20 00 ff 	mov    $0xffffffff00200000,%rax
     f31:	ff ff ff 
     f34:	48 21 c2             	and    %rax,%rdx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
     f37:	48 89 d1             	mov    %rdx,%rcx
     f3a:	48 c1 e9 20          	shr    $0x20,%rcx
     f3e:	e8 00 00 00 00       	callq  f43 <topmc_enable_all_write_nehelam+0x323>
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
     f43:	48 8d 4d cc          	lea    -0x34(%rbp),%rcx
     f47:	48 8d 55 c8          	lea    -0x38(%rbp),%rdx
     f4b:	44 89 e6             	mov    %r12d,%esi
     f4e:	89 df                	mov    %ebx,%edi
     f50:	e8 00 00 00 00       	callq  f55 <topmc_enable_all_write_nehelam+0x335>
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f55:	8b 45 cc             	mov    -0x34(%rbp),%eax
     f58:	8b 55 c8             	mov    -0x38(%rbp),%edx
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f5b:	31 c9                	xor    %ecx,%ecx
     f5d:	44 89 e6             	mov    %r12d,%esi
     f60:	89 df                	mov    %ebx,%edi
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f62:	48 c1 e0 20          	shl    $0x20,%rax
     f66:	48 09 d0             	or     %rdx,%rax
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f69:	31 d2                	xor    %edx,%edx
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				val &= MSR_PPRO_EVENTSEL_RESERVED;
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_EVNTSEL0+counter, val, cpu);
				TOPMC_RDMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, val, cpu);
				value = (unsigned long long)val;
				topmc_procs[cpu][counter].value = value;
     f6b:	49 89 45 04          	mov    %rax,0x4(%r13)
				TOPMC_WRMSRL(TOPMC_MSR_XEON55XX_PERFCTR0+counter, 0LL, cpu);
     f6f:	e8 00 00 00 00       	callq  f74 <topmc_enable_all_write_nehelam+0x354>
				topmc_procs[cpu][counter].enable        = 0;
     f74:	41 c7 45 fc 00 00 00 	movl   $0x0,-0x4(%r13)
     f7b:	00 
     f7c:	e9 21 fe ff ff       	jmpq   da2 <topmc_enable_all_write_nehelam+0x182>
     f81:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)
					user=1;
					break;
				case 2:
					kernel=1;
					user=0;
					break;
     f88:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
     f8f:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
				case 3:
					kernel=user=1;
					break;
     f96:	e9 49 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     f9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     fa0:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     fa7:	c7 45 b4 01 00 00 00 	movl   $0x1,-0x4c(%rbp)
					user=1;
					break;
				case 2:
					kernel=1;
					user=0;
					break;
     fae:	e9 31 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     fb3:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

	get_user(enable,buffer);
	for_each_online_cpu(cpu){
		for(counter=0;counter < TOPMC_MSR_XEON55XX_PerfCtrNum;counter++){
			event   = topmc_procs[cpu][counter].event;
			switch((event&TOPMC_EVENT_MASK_KERNEL_USER)>>TOPMC_EVENT_BITS_KERNEL_USER){
     fb8:	c7 45 b8 01 00 00 00 	movl   $0x1,-0x48(%rbp)
     fbf:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     fc6:	e9 19 fd ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
     fcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)
     fd0:	85 f6                	test   %esi,%esi
     fd2:	0f 85 fe fc ff ff    	jne    cd6 <topmc_enable_all_write_nehelam+0xb6>
     fd8:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
     fdf:	c7 45 b4 00 00 00 00 	movl   $0x0,-0x4c(%rbp)
     fe6:	e9 f9 fc ff ff       	jmpq   ce4 <topmc_enable_all_write_nehelam+0xc4>
		}
	}


#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     feb:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
     ff2:	e8 00 00 00 00       	callq  ff7 <topmc_enable_all_write_nehelam+0x3d7>
#endif

	if(enable=='1')
     ff7:	80 7d bf 31          	cmpb   $0x31,-0x41(%rbp)
		}
	}


#ifdef TOPMC_PER_SECOND
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
     ffb:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1002 <topmc_enable_all_write_nehelam+0x3e2>
#endif

	if(enable=='1')
    1002:	74 60                	je     1064 <topmc_enable_all_write_nehelam+0x444>
#endif

	}
	else
	{
		topmc_all_enabled       = 0;
    1004:	c7 05 00 00 00 00 00 	movl   $0x0,0x0(%rip)        # 100e <topmc_enable_all_write_nehelam+0x3ee>
    100b:	00 00 00 

#ifdef TOPMC_PER_SECOND
		clr_topmc_cnt_all(topmc_pmc_cnt_bitmap);
    100e:	66 c7 05 00 00 00 00 	movw   $0x0,0x0(%rip)        # 1017 <topmc_enable_all_write_nehelam+0x3f7>
    1015:	00 00 
    1017:	48 89 c6             	mov    %rax,%rsi
    101a:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1021:	e8 00 00 00 00       	callq  1026 <topmc_enable_all_write_nehelam+0x406>

	}

#ifdef TOPMC_PER_SECOND
	spin_unlock_irqrestore(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
	spin_lock_irqsave(&topmc_chg_lock, topmc_pmc_chg_flags);
    1026:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    102d:	e8 00 00 00 00       	callq  1032 <topmc_enable_all_write_nehelam+0x412>
    1032:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1039:	48 89 c6             	mov    %rax,%rsi
    103c:	48 89 05 00 00 00 00 	mov    %rax,0x0(%rip)        # 1043 <topmc_enable_all_write_nehelam+0x423>
//	printk("topmc_enable_all_write: before topmc_pmc_chg=%d\n",topmc_pmc_chg);
	topmc_pmc_chg = 1;
    1043:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 104d <topmc_enable_all_write_nehelam+0x42d>
    104a:	00 00 00 
    104d:	e8 00 00 00 00       	callq  1052 <topmc_enable_all_write_nehelam+0x432>
	spin_unlock_irqrestore(&topmc_chg_lock, topmc_pmc_chg_flags);
#endif

out:
	return count;
}
    1052:	8b 45 a0             	mov    -0x60(%rbp),%eax
    1055:	48 83 c4 38          	add    $0x38,%rsp
    1059:	5b                   	pop    %rbx
    105a:	41 5c                	pop    %r12
    105c:	41 5d                	pop    %r13
    105e:	41 5e                	pop    %r14
    1060:	41 5f                	pop    %r15
    1062:	c9                   	leaveq 
    1063:	c3                   	retq   
	spin_lock_irqsave(&topmc_bitmap_lock, topmc_pmc_cnt_flags);
#endif

	if(enable=='1')
	{
		topmc_all_enabled       = 1;
    1064:	c7 05 00 00 00 00 01 	movl   $0x1,0x0(%rip)        # 106e <topmc_enable_all_write_nehelam+0x44e>
    106b:	00 00 00 

#ifdef TOPMC_PER_SECOND
		set_topmc_cnt_all(topmc_pmc_cnt_bitmap);
    106e:	66 81 0d 00 00 00 00 	orw    $0xfff,0x0(%rip)        # 1077 <topmc_enable_all_write_nehelam+0x457>
    1075:	ff 0f 
    1077:	eb 9e                	jmp    1017 <topmc_enable_all_write_nehelam+0x3f7>
		}
		for (counter = 0; counter < TOPMC_MSR_XEON55XX_UNC_PerfCtrNum; counter++) {
			event = topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].event;
			if (enable == '1') {
				if( topmc_procs[cpu][TOPMC_MSR_XEON55XX_PerfCtrNum+counter].enable == 1) {
					printk("+->topmc_enable_all_write(): already enabled, skip this!!!\n");
    1079:	48 c7 c7 00 00 00 00 	mov    $0x0,%rdi
    1080:	31 c0                	xor    %eax,%eax
    1082:	e8 00 00 00 00       	callq  1087 <topmc_enable_all_write_nehelam+0x467>
					goto out;
    1087:	eb c9                	jmp    1052 <topmc_enable_all_write_nehelam+0x432>
